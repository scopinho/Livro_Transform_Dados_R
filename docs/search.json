[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Transformação e Manipulação de Dados com a linguagem R",
    "section": "",
    "text": "Este livro eletrônico contém uma série de informações sobre transformação e manipulação de dados utilizando a linguagem R, mais especificamente o pacote tidyverse.\nEstas são etapas muito importantes para quem trabalha com dados, como por exemplo uma área de negócio de uma organização, buscando tomar decisões com base em seus dados, ou até mesmo no ciclo de vida de um projeto de ciência de dados.\nA comunidade R tem produzido ao longo dos anos uma série Folhas de Referências (cheatsheets) que fazem parte também da ferramenta de desenvolvimento RStudio.\nEstas Folhas de Referências, são anotações de uma ou duas páginas que visam resumir as principais informações sobre determinado tema ou pacote do R. São uma espécie de “cola” para nos lembrarmos dos comandos e informações mais relevantes.\nEste livro se baseia nestas folhas de referências, que apesar de extremamente úteis, podem ser de difícil interpretação para usuários iniciantes.\nOutro motivador para este livro, foi a escassez de documentação sobre o tema em língua Portuguesa, que apesar dos grandes esforços da comunidade brasileira e voluntários, ainda sofre com falta de acesso para quem não domina o idioma inglês.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar o conteúdo deste livro, é importante que você já possua uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Não iremos abortar comandos básicos da linguagem e nem mesmo instalação da ferramenta de desenvolvimento.\nPara mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nOs temas abordados neste livro são:\n\nImportação de Dados: Trata sobre importação de dados tabulados (.csv, .tsv, .txt), planilhas do Excel e Google Sheets, através do pacote tidyverse (readr, readxl and googlesheets4). Ver folha de referência: data-import cheatsheet.\nOrganização de Dados: Sobre organização de dados com o pacote tidyr. Mover colunas e linhas de forma a estruturar seus dados em tabelas organizadas. Ver folha de referência: tidyr cheatsheet.\nTransformação de dados : Apresenta a transformação de dados com o pacote dplyr. Aplicação de filtros, sumarização, criação de colunas calculadas e muitas outras funções de transformação. Ver folha de referência: data transformation cheatsheet\nManipulação de strings: Fala sobre manipulação de strings (textos) com o pacote stringr. Apresenta também um bom conteúdo sobre expressões regulares (regex). Ver folha de referência: stringr cheatsheet\nFatores: Fala sobre manipulação de fatores (estruturas de dados para variáveis qualitativas) com o pacote forcats. Ver folha de referência: factors cheatsheet\nDatas e horas: Sobre a formatação e cálculos de variáveis com datas e horas com o pacote lubridate. Ver folha da referência: lubridate cheatsheet.\nProgramação Funcional: Sobre programação funcional, listas e funções com o pacote purrr. Ver folha da referência: purrr cheatsheet.\nVisualização de Dados: Traz uma introdução à criação de gráficos através do pacote ggplot2 e também uma introdução ao pacote gt para criação de tabelas de relatórios. Ver folha da referência: data visualization cheatsheet.\n\n\n\n\n\n\n\nConteúdo gerado à partir do sitema de publicação Quarto.\n\n\n\n\n\n\n\n\n\n\n\nEste livro é uma pequena contribuição à comunidade de software livre. Ele é (e sempre será) livre, e está licenciado sob a Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License.\nSe você quiser contribuir, por favor, considere em reportar algum erro ou sugestão em github.com/scopinho/Livro_Transform_Dados_R."
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "",
    "text": "A seguir temos vários exemplos de importação de dados utilizando o pacote TIDYVERSE do R. O pacote tidyverse possui vários pacotes de importação de dados, aqui iremos cobrir três deles (readr, readxl e googlesheets4). Para saber mais sobre estes pacotes, acesse:\nhttps://cran.r-project.org/package=tidyverse.\nhttps://cran.r-project.org/package=readr.\nhttps://cran.r-project.org/package=readxl.\nhttps://cran.r-project.org/package=googlesheets4.\nOs pacotes acima, serão utilzados para importação de dados tabulados (ex: .CSV ou TXT), planilhas do Excel e do Google.\nCaso você precise trabalhar com outras formatos de arquivos que não sejam os vistos neste capítulo, pode buscar maiores informações sobre os pacotes a seguir:\n\n\n\nPacote\nFormato\n\n\n\n\nhaven\nArquivos SPSS, Stata e SAS\n\n\nDBI\nBancos de Dados\n\n\njsonlite\nJSON\n\n\nxml2\nXML\n\n\nhttr\nWeb APIs\n\n\nrvest\nHTML (Web scraping)\n\n\nreadr::read_lines()\ndados texto\n\n\npdftools\nPDF\n\n\n\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\nreadxl\ngooglesheets4\nopenxlsx\n\n\nlibrary (tidyverse)\nlibrary (readxl)\nlibrary (googlesheets4)\nlibrary (openxlsx)\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência de importação de dados com tidyverse disponível no site do RStudio.\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara a maioria dos exemplos utilizaremos os seguintes arquivos de dados:\nAlguns desses arquivos são baseados nas tabelas mtcars, storms e starwars provenientes do pacote datasets e dplyr e também algumas tabelas (Table1, 2, 3, 4a, 4b e 5) que vem com o pacote tidyr.\n\nARQUIVOS TABULADOS: (TXT, CSV, TSV e FWF):\nIremos criar os arquivos tabulados para que possamos usá-los posteriormente. Para isso, execute o código abaixo:\n\nwrite_file(\"A|B|C\\n1|2|3\\n4|5|NA\", file = \"file.txt\")\nwrite_file(\"A,B,C\\n1,2,3\\n4,5,NA\", file = \"file.csv\")\nwrite_file(\"A;B;C\\n1,5;2;3\\n4,5;5;NA\", file = \"file2.csv\")\nwrite_file(\"A\\tB\\tC\\n1\\t2\\t3\\n4\\t5\\tNA\\n\", file = \"file.tsv\")\n\n\nEXCEL_FILE.XLSX:\nA seguir, você tem um link para o arquivo Excel utilizado nos exemplos.\nArquivo Exemplo - MS Excel\nÉ um arquivo com três planilhas (S1, S2 e S3) e em cada uma delas um pequeno conjunto de dados.\n\nE a primeira planilha (S1) possui algo como:\n\n\nGOOGLE_SHEET:\nA seguir, você tem o link para a planilha do google que será utilizado mais adiante.\nPlanilha exemplo - Google Sheets"
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html#readr",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html#readr",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "1.2 READR",
    "text": "1.2 READR\nO pacote readr possui diversas funções para ler dados tabulados (ex: .csv, .tsv, .txt, etc). Estas funções começam com read_*().\nread_* (file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale, n_max = Inf, skip = 0, na = c(““,”NA”), guess_max = min(1000, n_max), show_col_types = TRUE)\nOs parametros acima, são comuns à estas funções. Veja a seguir algumas delas. Digite ?read_delim para obter maiores detalhes de como utilzá-las.\n\n1.2.1 Ler dados tabulados com readr\n\n1.2.1.1 read_delim\nUse para ler um arquivo tabulado com qualquer delimitador. Se nenhum delimitador é especificado, a função tentará advinhar automaticamente.\nPor exemplo, para ler um arquivo .TXT tabulado com o caractere “|” como delimitador, fazemos:\n\nread_delim(\"file.txt\", delim = \"|\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara armazenar a leitura do arquivo em um objeto no R, podemos usar o operador <-.\n\n\n\nmeu_arquivo_csv <-read_delim(\"file.txt\", delim = \"|\")\nmeu_arquivo_csv\n\n\n\n  \n\n\n\n\n\n1.2.1.2 read_cvs\nUse para ler um arquivo tabulado separado por vírgula. Esta função entende que casas decimais que usam o ponto (ex 1.00) como separador de casas decimais.\n\nread_csv(\"file.csv\") \n\n\n\n  \n\n\n\n\n\n1.2.1.3 read_cvs2\nUse para ler um arquivo tabulado separado por ponto-e-vírgula. Esta função entende que casas decimais que usam a vírgula (ex: 1,00) como separador de casas decimais.\n\nread_csv2(\"file2.csv\") \n\n\n\n  \n\n\n\n\n\n1.2.1.4 read_tsv\nUse para ler um arquivo tabulado separado por tab.\n\nread_tsv(\"file.tsv\") \n\n\n\n  \n\n\n\n\n\n1.2.1.5 read_fwf\nUse para ler um arquivo tabulado com tamanhos fixos de colunas.\n\n\n\n\n\n\nNota\n\n\n\nVeja que a largura das colunas deve ser passada como um vetor para a parametro col_positions = usando a função fwf_width().\n\n\n\nread_fwf(\"file.tsv\", fwf_widths(c(2,2,NA)))\n\n\n\n  \n\n\n\n\n\n\n1.2.2 Parâmetros Úteis\nAlguns parametros das funções read_*() são muito úteis durante o processo de leitura pois permitem controlar melhor o que iremos obter como resultado da leitura.\n\n1.2.2.1 Sem cabeçalho\nUse o parâmetro COL_NAMES para não trazer a primeira linha como nome das colunas.\n\nread_csv2(\"file2.csv\", col_names = FALSE) \n\n\n\n  \n\n\n\n\n\n1.2.2.2 Definir cabeçalho\nUse o parâmetro COL_NAMES para definir manualmente os nomes das colunas.\n\nread_csv(\"file.csv\", col_names = c(\"X\", \"Y\", \"Z\")) \n\n\n\n  \n\n\n\n\n\n1.2.2.3 Ler vários arquivos\nUse o parametro ID para ler multiplos arquivos e armazená-los em uma mesma tabela.\n\nwrite_file(\"A,B,C\\n1,2,3\\n4,5,NA\", file = \"f1.csv\")\nwrite_file(\"A,B,C\\n6,7,8\\n9,10,11\", file = \"f2.csv\")\nread_csv(c(\"f1.csv\", \"f2.csv\"), id = \"arq_origem\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nObserve que as colunas dos diversos arquivos devem corresponder, ou seja, ter o mesmo nome de colunas.\n\n\n\n\n1.2.2.4 Pular linhas\nUse o prâmetro SKIP para pular as primeiras n linhas.\n\nread_csv(\"file.csv\", skip = 1) \n\n\n\n  \n\n\n\n\n\n1.2.2.5 Ler um número máximo de linhas\nUse o prâmetro N_MAX para ler um número máximo de linhas.\n\nread_csv(\"file.csv\", n_max = 1) \n\n\n\n  \n\n\n\n\n\n1.2.2.6 Ler valores como NA\nUse o prâmetro NA para definir um ou mais valores como NA.\n\nread_csv(\"file.csv\", na = c(\"1\")) \n\n\n\n  \n\n\n\n\n\n1.2.2.7 Especificar caractere decimal\nUse o prâmetro LOCALE para definir o caractere de casa decimais.\n\nread_delim(\"file2.csv\", locale = locale(decimal_mark = \",\")) \n\n\n\n  \n\n\n\n\n\n\n1.2.3 Salvar dados com readr\nSimilar às funções descritas na seção “Ler dados tabulados com readr” usadas para ler os aqruivos de texto tabulados, temos o conjunto de funções write_*() para gravar os arquivos correspondentes. Estas funções seguem o seguinte padrão:\nwrite_*(x, file, na = “NA”, append, col_names, quote, escape, eol, num_threads, progress)\nAs principais funções são:\n\n1.2.3.1 write_delim\nUse para gravar um arquivo delimitado por algum caractere específico. O parametro delim= permite definir este caractere. O caracteres padrão é o espaço (” “).\nPor exemplo, se quisermos gravar uma tabela (tibble) em um arquivo .txt delimitado por ponto-e-vírgula”;“, podemos usar:\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, \"C\")\nwrite_delim(conteudo, file = \"arquivo_exemplo1.txt\", delim=\";\")\n\n\n\n1.2.3.2 write_csv\nUse para gravar uma tabela em uma arquivo delimitado por “vírgula”.\n\n\n\n\n\n\nDica\n\n\n\nPodemos usar o arqumento na = para definirmos qual valor será usando para os valore ausentes, por padrão é utilizado “NA”. No exemplo a seguir, iremos trocar por “NULL”.\n\n\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, NA,\n                   4, \"D\")\nwrite_csv(conteudo, file = \"arquivo_exemplo2.csv\", na = \"NULL\")\n\n\n\n1.2.3.3 write_csv2\nUse para gravar uma tabela em um arquivo delimitado por “ponto-e-vírgula”.\n\n\n\n\n\n\nDica\n\n\n\nPode usar o parametro “col_names =” para incluir ou não os nomes das colunas no arquivo de saída. No exemplo a seguir, não iremos incluir os nomes das colunas:\n\n\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, \"C\")\nwrite_csv2(conteudo, file = \"arquivo_exemplo3.csv\", col_names = FALSE)\n\n\n\n1.2.3.4 write_tsv\nUse para gravar uma tabela em um arquivo delimitado por “TAB”:\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, \"C\")\nwrite_tsv(conteudo, file = \"arquivo_exemplo4.tsv\")\n\n\n\n\n1.2.4 Especificação de colunas com readr\nAo importar um arquivo com readr, podemos definir qual o tipo de coluna que determinado dado será importado. Por padrão, o readr irá gerar a especificação de cada coluna quando o arquivo form lido e gerará um resumo na saída.\nPodemos usar o argumento spec() para extrair as especificações das colunas de um arquivo importato para um data frame.\nPor exemplo:\n\narq <- read_csv2(\"file2.csv\") \nspec(arq)\n\ncols(\n  A = col_double(),\n  B = col_double(),\n  C = col_double()\n)\n\n\nObserve que as colunas “A”, “B” e “C” são do formato double.\nHá também uma mensagem de resumo ao importar um arquivo. Observe que ele informa o delimitador utilzado, mas também a especificação das colunas, neste caso, tipo double (dbl) para as colunas A, B e C conforme confirmamos com a função spec().\n\nℹ Using “‘,’” as decimal and “‘.’” as grouping mark. Use read_delim() for more control. Rows: 2 Columns: 3── Column specification ────────────────────────────────────────────────────────────────── Delimiter: “;” dbl (3): A, B, C ℹ Use spec() to retrieve the full column specification for this data. ℹ Specify the column types or set show_col_types = FALSE to quiet this message. # READXL\n\n\n\n\n\n\n\nDica\n\n\n\nSe quisermos omitir as especificações das colunas da mensagem de saída, usamos o parametro show_col_types = FALSE\n\n\n\n1.2.4.1 col_types\nSe utilizarmos o parametro col_types = podemos definir, por exemplo, a coluna “B” como inteiro (integer). Veja:\n\narq <- read_csv2(\"file2.csv\", col_types = \"did\") \nspec(arq)\n\ncols(\n  A = col_double(),\n  B = col_integer(),\n  C = col_double()\n)\n\n\nHá uma letra definida para cada tipo de coluna que quisermos especificar, veja a lista abaixo:\n• col_logical() - “l”\n• col_integer() - “i”\n• col_double() - “d”\n• col_number() - “n”\n• col_character() - “c”\n• col_factor(levels, ordered = FALSE) - “f”\n• col_datetime(format = ““) -”T”\n• col_date(format = ““) -”D”\n• col_time(format = ““) -”t”\n• col_skip() - “-”, “_”\n• col_guess() - “?”\nPor isso, usamos string “did” para definir um double, um inteiro e outro double para as colunas que importamos.\nPodemos também passar a especificação das colunas como uma lista mesclando as funções e os caracteres correspondentes na lista acima.\nPor exemplo:\n\narq <- read_csv2(\"file2.csv\", \n          col_types = list(A = col_double(), B = \"i\", C= \"d\")\n          )\nspec(arq)\n\ncols(\n  A = col_double(),\n  B = col_integer(),\n  C = col_double()\n)\n\n\n\n\n\n\n\n\nDica\n\n\n\nUse “.default =” na lista de especificações para definir o tipo padrão para as colunas, caso as mesmas não sejam explicitamente definidas.\n\n\n\n\n1.2.4.2 col_select\nPara selecionarmos apenas algumas colunas para importar do arquivo, utilzamos o parametro col_select = passanto um vetor com o nomes das colunas.\nPor exemplo, para importar apenas as colunas “A” e “C”, podemos fazer:\n\nread_csv(\"file.csv\", col_select = c(\"A\", \"C\"))\n\n\n\n  \n\n\n\n\n\n1.2.4.3 guess_max\nPara definirmos o número máximo de linhas do arquivo para advinhar o tipo da coluna (guess), utilizamos o parametro guess_max =. O padrão são as primeiras 1000 linhas.\n\nread_csv(\"file.csv\",guess_max = 2)"
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html#readxl",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html#readxl",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "1.3 READXL",
    "text": "1.3 READXL\nPara lermos arquivos do Microsoft Excel, podemos usar o pacote readxl.\n\n1.3.1 Ler arquivos do Excel\nApesar do pacote readxl ser instalado quando instalamos o pacote tidyverse, ele não é carregado quando carregamos o tidyverse. É por isso, que tivemos o código “library (readxl) na seção Introdução\n\n1.3.1.1 read_excel\nUse para ler um arquivo do Excel (.xls ou .xlsx) baseado na extensão do arquivo.\nSe preferir, pode utilizar as funções read_xls() e read_xlsx() para ler um arquivo com .xls ou .xlsx independente da extensão do arquivo.\n\nread_excel(\"excel_file.xlsx\")\n\n\n\n  \n\n\n\n\n\n\n1.3.2 Ler planilhas\nSabemos que um arquivo Excel (workbook), pode conter uma ou mais planilhas (worksheets). Para definirmos as planilhas que precisamos importar, podemos utilizar o parametros sheet = da função read_excel(). Podemos passar uma string com o nome a planilha (ex: “S1”) ou um índice númerico pela ordem de criação da planilha (ex: 1). Se nada for especificado, padrão é trazer a primeira planilha.\n\nread_excel(\"excel_file.xlsx\", sheet = \"S1\")\n\n\n\n  \n\n\n\nPara obter os nomes das planilhas presentes no arquivo, utilizamos a função excel_sheets()\n\nexcel_sheets(\"excel_file.xlsx\")\n\n[1] \"S1\" \"S2\" \"S3\"\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara lermos múltiplas planilhas podemos obter os nomes das planilhas usando a função excel_sheets(), pois definimos os nomes do vetor iguais aos nomes das planilhas e finalmente utilizamos a função purrr::map_dfr() para importar os arquivos no data frame.\n\n\n\narq <- \"excel_file.xlsx\"\narq |> \n  excel_sheets() |> \n  set_names() |> \n  map_dfr(read_excel, path = arq)\n\n\n\n  \n\n\n\n\n\n1.3.3 Especificação de colunas\nPara especificar os tipos das colunas no data frame após a importação do arquivo, usamos o parametro col_types =, similar ao que fizemos para arquivos tabulados na seção Especificação de colunas com readr.\nOs tipos de colunas podemos ser:\n“skip”, “guess”, “logical”, “numeric”, “date”, “text” ou “list”.\n\n\n\n\n\n\nDica\n\n\n\nUse uma coluna de lista (list-column) descrita no pacote tidyr para trabalhar com colunas com vários tipos.\n\n\n\n\n1.3.4 Outros pacotes\nAlém do pacote readxl, há outros pacotes muito úteis para criar arquivos do MS Excel, tais como:\n\nopenxlsx\nwritexl\n\nPara trabalhar com dados do Excel de forma não tabular, veja o pacote:\n\ntidyxl\n\n\n\n1.3.5 Especificação de celulas\nUse os argumentos range = para a função read_excel() ou googlesheets4::read_sheet() no caso de planilhas do Google para ler um subconjunto de células de uma planilha.\nPor exemplo, se quiser ler apenas o range de células de “A1” até “B3” da planilha “S2” do arquivo excel de exemplo, por fazer:\n\nread_excel(\"excel_file.xlsx\", range = \"S2!A1:B3\")\n\n\n\n  \n\n\n\nO parametro range = , possui alguns argumentos que ajudam a melhor definir o range a ser importado. Veja ?`cell-specification` para maiores detalhes de como cell_cols(), cell_rows(), cell_limits() e anchored(). Por exemplo, usando cell_cols, podemos definir que iremos importar apenas as celulas que das colunas “B” até “D”:\n\nread_excel(\"excel_file.xlsx\", sheet = \"S1\", \n          range = cell_cols(\"B:D\"))"
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html#googlesheets4",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html#googlesheets4",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "1.4 GOOGLESHEETS4",
    "text": "1.4 GOOGLESHEETS4\n\n1.4.1 Ler planilhas\n\n1.4.1.1 read_sheet\nUse para ler planilhas do Google a partir de uma URL, um IDde planilha ou um objeto do tipo “dribble” que é retornado pelo pacote googledrive. Esta função é um “apelido” para a função range_read() que é mais utilizada no contexto do pacote googlesheets4.\nDiversos argumtos vistos para as funções read_* são aplicadas aqui também, como col_types = , sheet =, range = , guess_max = . Veja mais detalhes na seção do readr descrita anteriormente.\nNo exemplo a seguir iremos ler uma planilha do Google de exemplo. Para isso, recebemos o seguinte URL. Veja que a partes em negrito corresponde ao ID do arquivo e o ID da planilha respectivamente:\nhttps://docs.google.com/spreadsheets/d/1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8/edit#gid=0\nUsamos então a função read_sheet():\n\ngooglesheets4::read_sheet(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\", sheet = \"Sheet1\")\n\n\n\n  \n\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nA primeira vez que executar este comendo, haverá um processo de autenticação da sua conta do Google e seeão do R. Reponda “Yes” para a pergunta “Is it OK to cache OAuth access credentials in the folder ~/.cache/gargle between R sessions?”\n1: Yes\n2: No\nDepois o navegador será aberto solicitando o acesso aos arquivo do Google. Selecoine o checkbox e click em “Continue”.\n\n\n\n\n\n1.4.2 Metadados das planilhas\n\n1.4.2.1 gs4_gets\nUse para obter os metadados do arquivo:\n\ngs4_get(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\")\n\nSpreadsheet name: tidyverse_exemplo\n              ID: 1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\n          Locale: en_US\n       Time zone: America/Sao_Paulo\n     # of sheets: 63\n\n(Sheet name): (Nominal extent in rows x columns)\n      Sheet1: 1000 x 26\n          df: 4 x 2\n      Sheet2: 4 x 2\n      Sheet3: 4 x 2\n      Sheet4: 4 x 2\n      Sheet5: 4 x 2\n      Sheet6: 4 x 2\n      Sheet7: 4 x 2\n      Sheet8: 4 x 2\n      Sheet9: 4 x 2\n     Sheet10: 4 x 2\n     Sheet11: 4 x 2\n     Sheet12: 4 x 2\n     Sheet13: 4 x 2\n     Sheet14: 4 x 2\n     Sheet15: 4 x 2\n     Sheet16: 4 x 2\n     Sheet17: 4 x 2\n     Sheet18: 4 x 2\n     Sheet19: 4 x 2\n     Sheet20: 4 x 2\n     Sheet21: 4 x 2\n     Sheet22: 4 x 2\n     Sheet23: 4 x 2\n     Sheet24: 4 x 2\n     Sheet25: 4 x 2\n     Sheet26: 4 x 2\n     Sheet27: 4 x 2\n     Sheet28: 4 x 2\n     Sheet29: 4 x 2\n     Sheet30: 4 x 2\n     Sheet31: 4 x 2\n     Sheet32: 4 x 2\n     Sheet33: 4 x 2\n     Sheet34: 4 x 2\n     Sheet35: 4 x 2\n     Sheet36: 4 x 2\n     Sheet37: 4 x 2\n     Sheet38: 4 x 2\n     Sheet39: 4 x 2\n     Sheet40: 4 x 2\n     Sheet41: 4 x 2\n     Sheet42: 4 x 2\n     Sheet43: 4 x 2\n     Sheet44: 4 x 2\n     Sheet45: 4 x 2\n     Sheet46: 4 x 2\n     Sheet47: 4 x 2\n     Sheet48: 4 x 2\n     Sheet49: 4 x 2\n     Sheet50: 4 x 2\n     Sheet51: 4 x 2\n     Sheet52: 4 x 2\n     Sheet53: 4 x 2\n     Sheet54: 4 x 2\n     Sheet55: 4 x 2\n     Sheet56: 4 x 2\n     Sheet57: 4 x 2\n     Sheet58: 4 x 2\n     Sheet59: 4 x 2\n     Sheet60: 4 x 2\n     Sheet61: 4 x 2\n     Sheet62: 4 x 2\n\n\n\n\n1.4.2.2 gs4_find\nUse para localizar suas planilhas do Google no drive. Ela retorna um objeto dibble, que é um “tibble” com uma linha por arquivo. E informa o ID dos arquivos.\n\nmy_dribble <- gs4_find(pattern = \"tidyverse_exemplo\")\nmy_dribble\n\n\n\n  \n\n\n\nsheet_properties\nUse para obter uma tabela (tibble) com as propriedades de cada planilha.\n\nsheet_properties(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\")\n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nVocê pode usar a função sheet_names() para obter os nomes da planilha dentro do arquivo.\n\n\n\n\n\n1.4.3 Gravar planilhar\nO pacote googlesheets4 tem várias maneiras de gravar dados em uma planilha.\n\n1.4.3.1 write_sheet\nUse esta função para salvar um data frame em uma planilha no arquivo do Google Sheets. Se a planilha não existir, ele cria uma planilha co mum nome aleatório através da função gs4_create().\n\ndf <- tribble(~x, ~y,\n              1, \"A\",\n              2, \"B\",\n              3, \"C\")\nwrite_sheet(df, \"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\")\nread_sheet(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\", sheet = \"df\")\n\n\n\n  \n\n\n\n\n\n1.4.3.2 gs4_create\nUse para criar uma nova planilha do Google. Você pode fornecer o nome, mas caso não o faça o Google irá atribuir um nome aleatorio ao seu arquivo.\n\nminha_planilha <- gs4_create(name = \"meu_novo_arquivo_google_sheet\", sheets = \"Sheet1\")\nsheet_properties(minha_planilha)\n\n\n\n  \n\n\n\n\n\n\n1.4.4 Especificação de colunas\nPara especificar os tipos das colunas no data frame após a importação da planilha do Google, usamos o parametro col_types = como argumento da função read_sheet/range_read(), similar ao que fizemos para arquivos tabulados na seção Especificação de colunas com readr.\nOs tipos de colunas aceitos são:\n• skip - “_” ou “-”\n• guess - “?”\n• logical - “l”\n• integer - “i”\n• double - “d”\n• numeric - “n”\n• date - “D”\n• datetime - “T”\n• character - “c”\n• list-column - “L”\n• cell - “C” Retorna uma lista bruta dos dados das células.\n\n\n1.4.5 Especificação de celulas - Google Sheets\nVer seção Especificação de celulas\n\n\n1.4.6 Operadores de arquivos\nO pacote googlesheets4 oferece várias forma de manipular os aspectos da planilha como congelar linhas, definir largura das colunas, etc. Acesse googlesheets4.tidyverse.org para mais informações.\nPara operções de arquivos (ex: renomear, compartilhar, mover para outra pasta, etc), veja o pacote googledrive no link: googledrive.tidyverse.org."
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html",
    "title": "2  Organização de Dados com TIDYR",
    "section": "",
    "text": "A seguir temos vários exemplos de organização de dados utilizando o pacote TIDYR do R. Para saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=tidyr.\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\n\n\nlibrary (tidyverse)\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência do tidyr disponível no site do RStudio.\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara a maioria dos exemplos utilizaremos as bases de dados mtcars, storms e starwars provenientes do pacote datasets e dplyr e também algumas tabelas (Table1, 2, 3, 4a, 4b e 5) que vem com o pacote tidyr.\n\nMTCARS: Dados de consumo de combustível, performance e design de 32 automóveis ( 1974 Motor Trend US magazine)\n\nmtcars |> \n  head () \n\n\n\n  \n\n\n\n\nSTORMS: Dados de furacões entre 1975-2020 medidos a cada 6 horas durante cada tempestade ( NOAA Atlantic hurricane database ),\n\nstorms |> \n  head () \n\n\n\n  \n\n\n\n\nSTARWARS: Dados dos personagens de STAR WARS\n\nstarwars |> \n  select(1:8) |> \n  head()\n\n\n\n  \n\n\n\nTABELAS EXEMPLOS - Table1, 2, 3, 4a, 4b e 5\n\nTable1Table2Table3Table4aTable4bTable5\n\n\n\ntable1\n\n\n\n  \n\n\n\n\n\n\ntable2\n\n\n\n  \n\n\n\n\n\n\ntable3\n\n\n\n  \n\n\n\n\n\n\ntable4a\n\n\n\n  \n\n\n\n\n\n\ntable4b\n\n\n\n  \n\n\n\n\n\n\ntable5\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nO termo data-frame descrito ao longo deste texto, é utilizado de forma livre para objetos do tipo data.frame, tibble, entre outros. Pense como se fosse uma tabela de um banco de dados e/ou uma planilha do MS Excel, contendo linhas e colunas. Apesar de não ser rigorosamente igual à uma tabela, muitas vezes usaremos estes termos de forma intercambiável para facilitar o entendimento de iniciantes.\n\n\n\n\n\nConforme visto anteriorment, dados organizados (tidy) são estruturados onde:\nCada variável está em sua própria coluna e cada observação está em sua própria linha.\n\nAs variáveis (ou colunas) são acessadas como vetores.\nOs observações (ou linhas) são preservadas em operações vetorizadas, ou seja, quando utilizamos funções que recebem vetores na entrada e retornam vetores na sua saída."
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#tibbles",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#tibbles",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.2 Tibbles",
    "text": "2.2 Tibbles\nPodemos considerar que “Tibbles” são objetos similares aos “Data Frames”, porém com algumas melhorias/vantagens. Estes objetos são fornecidos pelo packago tibble. Eles herdam a classe data frame, mas possuem alguns comportamentos melhorados, como:\n\nExtrai parte de um tibble usando colchetes ] e um vetor com duplo colchetes ]] ou $\nSem encontros parciais quando extraindo partes das colunas\nMostram uma resumo mais amigável na tela quando pedimos suas informações. Use options(tibble.print_max = n, tibble.print_min = m, tibble.width = Inf) para controlar a saída padrão.\nAs funções View() ou glimpse() permitem visualizar todo o conjunto de dados.\n\nPor exemplo, se tivermos um tibble (ex starwars) e quisermos acessar a coluna “name”, e obter um vetor, podemos usar:\n\nstarwars[[\"name\"]] #Por nome com [[  ]]\nstarwars$name      #Por nome com $\nstarwars[[1]]      #Por numero da coluna com [[  ]]\n\nJá se tivermos um tibble (ex starwars) e quisermos acessar a coluna “name”, e obter um tibble, podemos usar:\n\nstarwars[ , 1]            #Por numero com [   ]\nselect (starwars, 3)      #Por numero usando select()\nselect (starwars, name)   #Por nome usando select()\n\n\n2.2.1 Criando tibble\nPodemos utilziar as funções tibble() ou tribble() para criar a mesma tabela. A diferença é apenas na forma em que os parêmetros são utilizados.\n\n2.2.1.1 tibble\nUse para criar um tibble por colunas.\n\ntibble(x = 1:3, y = c(\"a\", \"b\", \"c\"))\n\n\n\n  \n\n\n\n\n\n2.2.1.2 tribble\nUse para criar um tibble por linhas.\n\ntribble(~x, ~y, \n        1, \"a\",\n        2, \"b\",\n        3, \"c\",\n        4, \"d\")\n\n\n\n  \n\n\n\n\n\n2.2.1.3 as_tibble\nUse para converter um data frame para um tibble.\nPor exemplo, para converter o data frame MTCARS para um tibble, fazemos:\n\nas_tibble(mtcars)\n\n\n\n  \n\n\n\n\n\n2.2.1.4 enframe\nUse para converter um vetor para um tibble. Use deframe() parta fazer o inverso.\n\n\n2.2.1.5 is_tibble\nUse para saber se um objeto é um tibble ou não.\n\nis_tibble(mtcars)\n\n[1] FALSE"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#reformatando-dados",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#reformatando-dados",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.3 Reformatando Dados",
    "text": "2.3 Reformatando Dados\nMuitas vezes, os dados que recebemos não estão organizados (tidy) da maneira como vimos na seção [Dados Organizados e Canalização]. Para casos onde temos, por exemplo, as variáveis em linhas e/ou observações em colunas, etc, precisamos fazer uma ação conhecida como “pivotagem”. Pivotar dados, no contexto do tidyr, significa ajustar linhas em colunas e/ou colunas em linhas, de forma a obtermos nossos dados da maneira organizada (tidy).\nVeja, por exemplo, nossa tabela 1 (table1). Ela está em um formato organizado, pois possui cada variável em uma coluna e cada observações em sua linha, com os valores nas células.\n\ntable1\n\n\n\n  \n\n\n\n\n2.3.0.1 pivot_longer\nUse para “pivotar” os dados das colunas para as linhas, alongando a tabela, juntando várias colunas em duas, sendo uma a colunas que receberá os nomes das colunas e outra que recebera os valores das colunas.\nPor exemplo, vejamos nossa tabela 4 (table4).\n\ntable4a\n\n\n\n  \n\n\n\nObserve que temos uma variável (potencialmente “Ano”) que está na colunas 2 e 3 da tabela. Temos também outra variável (potencialmente “Numero_de_Casos” que está nas células da tabela.\nPara organizar esta tabela em nosso formato “tidy”, devemos pegar estas duas colunas e usar a função pivot_longer definindo os nomes para as respectivas variáveis (ex: ano e num_caso).\n\npivot_longer(table4a, cols = 2:3, names_to =\"ano\",\nvalues_to = \"num_casos\") \n\n\n\n  \n\n\n\n\n\n2.3.0.2 pivot_wider\nUse para “pivotar” os dados das linhas para as colunas, expandindo a tabela gerando novas colunas.\nVejamos o caso da tabela 2 (table2).\n\ntable2\n\n\n\n  \n\n\n\nNeste exemplo, vemos que as variáveis casos (cases) e população (population) estão nas linhas e não nas colunas. Para deixarmos os dados organizados (tidy), devemos “expandir” a tabela, fazendo com que os dados de duas colunas sejam expandidos em vaŕias colunas. Os nomes das novas colunas virão de uma colunas e os valores da outra coluna. Veja:\n\ntable2 |> \n  pivot_wider(names_from = type, values_from = count)"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#expandindo-tabelas",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#expandindo-tabelas",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.4 Expandindo Tabelas",
    "text": "2.4 Expandindo Tabelas\nEm algumas situações, precisamos criar novas combinações das variáveis ou identificar valores ausentes implícitos, ou seja, combinações de variáveis não presentes nos dados.\nPara isto, temos as funções expand() e complete().\n\n2.4.0.1 expand\nUse para criar um novo tibble com todas as possibilidades de combinações dos valores das variáveis passadas para a função expand(), ignorando as demais variáveis.\nPor exemplo, se quisermos obter todas as combinações possíveis entre o número de cilindros (cyl), marchas (gear) e numero de carburadores (carb) da tabela mtcars, e ignorar todas as demais variáveis da tabela, podemos usar:\n\nmtcars |> \n  expand(cyl, gear, carb) \n\n\n\n  \n\n\n\nObserve que não há na tabela original (mtcars) um veículo de 4 cilindros e 8 carburadores, porém esta combinação foi possível usando a função expand().\n\n\n2.4.0.2 complete\nUse para criar um novo tibble com todas as possibilidades de combinações dos valores das variáveis passadas para a função expand(), colocando NA nas demais variáveis.\nPor exemplo, se quisermos obter todas as combinações possíveis entre o número de cilindros (cyl), marchas (gear) e numero de carburadores (carb) da tabela mtcars, e colocar NA para as demais variáveis em que a combinação não exista, podemos usar:\n\nmtcars |> \n  complete(cyl, gear, carb)"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#combinando-e-dividindo-celulas",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#combinando-e-dividindo-celulas",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.5 Combinando e Dividindo Celulas",
    "text": "2.5 Combinando e Dividindo Celulas\nUse as funções a seguir para dividir ou combinar células da tabela em valores individuais isolados.\n\n2.5.0.1 unite\nUse para combinar celulas de diversas colunas em uma única coluna.\nVejamos com é a tabela 5 (table5) em seu formato original:\n\ntable5 \n\n\n\n  \n\n\n\nAgora queremos unir as colunas “century” e “year” em uma única coluna:\n\ntable5 |> \n  unite(century, year, col = \"ano_completo\", sep = \"\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nVeja que as colunas que deram origem à coluna combinada não são retornadas na saída da função.\n\n\n\n\n2.5.0.2 separate\nUse para dividir cada célula de uma coluna em várias colunas.\nPor exemplo, na tabela 3 (table3), temos uma coluna “rate” que possui daos dos casos e população separados por uma barr (“/”). Neste caso, podemos utilzar a função separate para dividí-la e criar duas novas colunas com seus dados separados.\n\ntable3 |> \n  separate(rate, sep = \"/\", \n           into = c(\"casos\", \"pop\")) \n\n\n\n  \n\n\n\n\n\n2.5.0.3 separate_rows\nUse para dividir cada célula de uma coluna em várias linhas.\nÉ similar a função separate, porém o conteúdo de cada célula irá para uma linha ao invés de uma colunas.\n\ntable3 |> \n  separate_rows(rate, sep = \"/\")"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#lidando-com-valores-ausentes",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#lidando-com-valores-ausentes",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.6 Lidando com Valores Ausentes",
    "text": "2.6 Lidando com Valores Ausentes\nMuitas vezes precisamos ignorar ou substituir valores ausentes (NA). Para isso, podemos usar as funções drop_na(), fill() ou replace_na()\n\n2.6.0.1 drop_na\nIgnora linhas que possuem valores ausentes (NA) nas colunas.\nPor exemplo, na tabela starwars, temos 5 personagens que não possuim cor de cabelo (hair color):\n\nstarwars |> \n  select(name, hair_color) |> \n  filter(is.na(hair_color))\n\n\n\n  \n\n\n\nSe pedirmos para listar todos os personagens e utilizarmos a função drop_na(), estes 5 personagens não serão listados:\n\nstarwars |> \n  select(name, hair_color) |> \n  drop_na()\n\n\n\n  \n\n\n\n\n\n2.6.0.2 fill\nUse para substituir o valores ausente (NA) da coluna pelo último valor disponível em linhas anteriores ou posteriores.\nPor exemplo:\nComo vimos no exemplo da função drop_na, temos 5 personagens de starwars que não possuem cor de cabelo preenchido.\nDigamos que decidimos substituir estes NAs pelo cor de cabelo do personagem anterior disponível. Para isso, faremos:\n\nstarwars |> \n  select (name, hair_color) |> \n  fill(hair_color)\n\n\n\n  \n\n\n\nVeja que o personagem C-3PO que tinha a cor de cabelo não preenchida, agora está como loiro (blond), pois o personagem anteriormente preenchido, era o Luke Skywalker, que tinha a cor de cabelo loiro (blond). Já o personagem R5-D4, teve sua cor de cabelo preenchida de marron (brown), pois o personagem anterior Beru Whitesun lars, tinha o cabelo marron (brown).\n\n\n2.6.0.3 replace_na\nUse para substituir os valores de NA por um valor específico.\nPor exemplo, vamos substituir a cor de cabelo dos personagens que tem NA na coluna “hair_color” pela cor azul (blue).\n\nstarwars |> \n  select(name, hair_color) |> \n  replace_na(list(hair_color = \"blue\"))\n\n\n\n  \n\n\n\n\n\n\n\n\n\nAviso\n\n\n\nVeja que a função replace_na, recebe uma lista de valores (list()) se os dados passados no primeiro parâmetro é um data frame."
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#dados-aninhados",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#dados-aninhados",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.7 Dados Aninhados",
    "text": "2.7 Dados Aninhados\n\n2.7.1 Introdução\nUm data frame aninhado (nested) é aquela que possui tabelas completas em colunas do tipo lista (colunas de lista) dentro de outro data frame maior e organizado. Uma coluna de lista, podem ser também listas de vetores ou listas de vários tipos de dados.\nAlguns uso de um data frame de dados aninhados são:\n\nPreservar o relacionamento entre observações e sub-grupos de dados.\nPreservar o tipo da variável aninhada (factors e datetime não viram caracteres por exemplo).\nManipular várias sub-tabelas de uma vez com funcções do pacote purrr como map(), map2() ou pmap() ou com a rowwise() do pacote dplyr.\n\n\n\n2.7.2 Criando dados Aninhados\n\n2.7.2.1 nest\nUse para mover grupos de células para uma coluna de lista de um data frame. Pode ser usada sozinha ou em conjunto com a grupo_by().\nExemplo 1: nest() com groupg_by()\nDigamos que gostaríamos ter uma linha para cada furacão de nosso data frame (storms) e em uma coluna de lista, uma tabela dos dados do respectivo furação. Para isso, podemos utilizar a função nest() em conjunto com a função group_by(). Veja abaixo:\n\nn_storms <- storms  |> \n  group_by(name) |> \n  nest()\nhead(n_storms, 15)\n\n\n\n  \n\n\n\nObserve que na coluna “data”, temos um objeto <tibble> para grupo criado pela função group_by. A função nest() aninhou todas as demais variáveis nestas pequenas tabelas para cada um deles e armazenou na coluna do tipo lista.\nPara acessar a tibble gerada para o primeiro grupo (furacão “Amy” na primeira linha acima), podemos fazer:\n\nn_storms$data[[1]] \n\n\n\n  \n\n\n\nPara acessar todas as observações as variáveis “month” e “status” especificamente, podemos usar:\n\nn_storms$data[[1]][, c(\"month\", \"status\")] |> \n  head() \n\n\n\n  \n\n\n\nExemplo 2: nest() especificando colunas\nDigamos que precisamos especfificar as colunas que gostaríamos de aninhar em cada linha da coluna de lista. Apenas para simplificar o exemplo, iremos selecionar com a função selct() apenas as colunas “name”, “year”, “lat” e “long”. Depois iremos aninhar as colunas “year” até a coluna “long” em um coluna de lista chamada “data”. Veja a seguir:\n\nn_storms <- storms  |> \n  select(name, year, lat, long) |> \n  nest(data = c(year:long))\nhead(n_storms)\n\n\n\n  \n\n\n\nAgora temos as colunas “year”, “lat” e “long” aninhadas na coluna de lista chamada “data” para cada observação da coluna “name”.\nAssim como vimos anteriormente, podemos acessar as tibbles da coluna dat usando [[ ]]. Por exemplo:\n\nn_storms$data[[1]]\n\n\n\n  \n\n\n\n\n\n\n2.7.3 Criando Tibbles com Colunas de Listas\nPara criar um objeto tibble com colunas de lista (list-column), você pode utilizar as mesmas funções tibble(), trible() e enframe(), passando uma objeto lista para a coluna.\n\n2.7.3.1 tibble\nUse para criar uma tibble com uma coluna de lista salvando uma lista na coluna.\n\ntibble(max=c(3,4,5), seq=list(1:3, 1:4, 1:5))\n\n\n\n  \n\n\n\n\n\n2.7.3.2 tribble\nUse para criar uma tibble com uma coluna de lista por linhas.\n\ntribble(~max, ~seq, \n       3, 1:3,\n       4, 1:4,\n       5, 1:5)\n\n\n\n  \n\n\n\n\n\n2.7.3.3 enframe\nUse para converter listas em um tibble dentro de uma coluna de lista.\n\nlista <- list('3'=1:3, '4'=1:4, '5'=1:5)\nenframe(lista, 'max', 'seq')\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserve que nossa lista possui “nomes” nos vetores (3, 4 e 5), se isso não for o caso, ele irá nomear as colunas com a sequencia lógica dos vetores (1, 2 e 3).\n\n\n\n\n2.7.3.4 Outras Funções Retornam Coluna de Lista\nAlgumas funções, como por exemplo, mutate(), transmute() e summarise() do pacote dplyr tem como saída uma colunas de lista caso retornem uma lista.\nPor exemplo, se criarmos uma lista com os quartis da variável consumo (mpg) da tatela mtcars agrupada por cilindros (cyl) e utilzarmos a função summarise(), teremos uma coluna de lista contendo os quartis para cada grupo de cilindro.\n\nmtcars  |> \ngroup_by(cyl)  |> \nsummarise(q = list(quantile(mpg)))\n\n\n\n  \n\n\n\n\n\n\n2.7.4 Reformatando dados Aninhados\n\n2.7.4.1 unest\nUse para desaninhar os dados. Esta função, faz o inverso da função nest.\nPor exemplo, para desaninhar os dados da coluna data criada na tabela n_storms, fazemos:\n\nn_storms |> \n  unnest(data)\n\n\n\n  \n\n\n\n\n\n2.7.4.2 unest_longer\nUse para desaninhar um coluna de lista, tornando cada elemento da lista em uma linha.\nPor exemplo, na tabela starwars, temos uma coluna de lista chamada “films”, nesta coluna temos uma lista de filmes que cada personagem participou. Se quisermos desaninhar esta coluna e colocar cada filme em uma linha, faremos:\n\nstarwars |> \nselect(name, films) |> \nunnest_longer(films)\n\n\n\n  \n\n\n\n\n\n2.7.4.3 unest_wider\nUse para desaninhar um coluna de lista, tornando cada elemento da lista em uma coluna.\nPor exemplo, na tabela starwars, temos uma coluna de lista chamada “films”, nesta coluna temos uma lista de filmes que cada personagem participou. Se quisermos desaninhar esta coluna e colocar cada filme em uma coluna, faremos:\n\nstarwars |> \n  select(name, films) |> \n  unnest_wider(films, names_sep = '_')\n\n\n\n  \n\n\n\n\n\n2.7.4.4 hoist\nUse para selecionar componentes específicos de uma lista e desaninhá-lo em uma nova coluna. É similar ao unnest_wider(), mas desaninha colunas específicas usando a sintaxe do purrr:pluck().\nPor exemplo, vamos desaninhar apenas o primeiro e segundo filmes em que o psernagem de starwars particiou e manter os demais anihados:\n\nstarwars %>%\nselect(name, films) %>%\nhoist(films, \"1o_filme\" = 1, \"2o_filme\" = 2)\n\n\n\n  \n\n\n\n\n\n\n2.7.5 Transfromando dados Aninhados\nUma função vetorizada recebe um vetor, transforma cada elemento em paralelo e retorna um vetor de mesmo tamanho que o vetor de entrada. Estas funções sozinhas não trabalham com listas, e consequentemente, não trabalham com colunas de listas.\nA função dplyr::rownames() agrupa cada linha da tabela em um grupo diferente e dentro de cada grupo os elementos da coluna de lista aparecem diretamente (acessados por colchetes duplo) e não mais como uma lista e tamanho 1.\nPortanto, quando usamos a rownames(), as funções vetorizadas do pacote dplyr poderão ser aplicadas em uma coluna de lista de uma forma vetorizada.\n\n2.7.5.1 Exemplo 1:\nVamos aplicar a função mutate() para criar uma nova coluna de lista contendo as dimensões do tibble presente na coluna “data”:\n\n\nn_storms  |> \n  rowwise() |> \n  mutate (\"dim\" = list(dim(data)))\n\n\n\n  \n\n\n\n\n\n2.7.5.2 \nNeste exemplo, utilzamos a função dim() que retorna as dimensões de um objeto. Como na coluna “data”, temos um objeto tibble para cada linha, a função dim irá retornar dois valores (qtd de linha e qtd de colunas).\nIsto só funcionou porque agrupamento através da função rowwise() a tabela anterior.\n\n\n2.7.5.3 Exemplo 2:\nVamos aplicar a função mutate() para criar um coluna “normal” contendo o número de linhas da tibble presente na coluna “data”:\n\nn_storms  |> \n  rowwise() |> \n  mutate (\"num_linhas\" = nrow(data))\n\n\n\n  \n\n\n\n\n\n2.7.5.4 Exemplo 3:\nVamos aplicar a função mutate() para criar um coluna de lista contendo uma outra lista com a união entre as colunas de listas “vehicles” e “starships” presentes na tabela starwars:\n\nstarwars |> \n  rowwise() |> \n  mutate (transporte = list(append(vehicles, starships))) |> \n  select(name, transporte) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nSe quisermos pegar os transportes criados e colocá-los em linhas, podemos usar a função unest.\n\n\n\nstarwars |> \n  rowwise() |> \n  mutate (transporte = list(append(vehicles, starships))) |> \n  select(name, transporte) |> \n  unnest(transporte)\n\n\n\n  \n\n\n\n\n\n2.7.5.5 Exemplo 4:\nVamos aplicar a função mutate() para criar um coluna de lista contendo uma o tamanho das listas “vehicles” e “starships” presentes na tabela starwars, e depois iremos desaninhar esta lista, obtendo assim quantos transportes cada personagem possui:\n\nstarwars |> \n  rowwise() |> \n  mutate (transporte = list(length(c(vehicles, starships)))) |> \n  select(name, transporte) |> \n  unnest(transporte)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nVeja o pacote purrr para outras funções que manipulam listas em Programação Funcional.\n\n\nObserve pelos exemplos anteriores que quando temos uma função que retorna uma lista, devemos usar a função list() para criar uma coluna de lista. Se a função retorna um valor (ex um inteiro), a coluna criada será um coluna “normal”, neste caso um coluna de inteiros."
  }
]