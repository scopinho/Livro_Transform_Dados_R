[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Transformação e Manipulação de Dados com a linguagem R",
    "section": "",
    "text": "Este livro contém uma série de informações sobre transformação e manipulação de dados utilizando a linguagem R, mais especificamente o pacote tidyverse.\nEstas são etapas muito importantes para quem trabalha com dados, como por exemplo uma área de negócio de uma organização, buscando tomar decisões com base em seus dados, ou até mesmo no ciclo de vida de um projeto de ciência de dados.\nA comunidade R tem produzido ao longo dos anos uma série Folhas de Referências (cheatsheets) que fazem parte também da ferramenta de desenvolvimento RStudio.\nEstas Folhas de Referências, são anotações de 2 páginas que visam resumir as principais informações sobre determinado tema ou pacote do R. São uma espécie de “cola” para nos lembrarmos dos comandos e informações mais relevantes.\nEste livro se baseia nestas folhas de referências, que apesar de extremamente úteis, podem ser de difícil interpretação para usuários iniciantes.\nAleḿ disso, outro motivador para este livro, foi a escassez de documentação sobre o tema em lingua Portuguesa, que apesar dos grandes esforços da comunidade brasileira e voluntários, ainda sofre com falta de acesso para quem não domina o idioma inglês.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar o conteúdo deste livro, é importante que você já possua uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Não iremos abortar comandos básicos da linguagem e nem mesmo instalação da ferramenta de desenvolvimento.\nPara mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\nou\nhttps://livro.curso-r.com/\n\n\nOs temas abordados neste livro são:\n\nImportação de Dados: Trata sobre importação de dados tabulados (.csv, .tsv, .txt), planilhas do Excel e Google Sheets, através do pacote tidyverse (readr, readxl and googlesheets4). Ver folha de referência: data-import cheatsheet.\nOrganização de Dados: Sobre organização de dados com o pacote tidyr. Mover colunas e linhas de forma a estruturar seus dados em tabelas organizadas. Ver folha de referência: tidyr cheatsheet.\nTransformação de dados : Apresenta a transformação de dados com o pacote dplyr. Aplicação de filtros, sumarização, criação de colunas calculadas e muitas outras funções de transformação. Ver folha de referência: data transformation cheatsheet\nManipulação de strings: Fala sobre manipulação de strings (textos) com o pacote stringr. Apresenta também um bom conteúdo sobre expressões regulares (regex). Ver folha de referência: stringr cheatsheet\nDatas e horas: Sobre a formatação e cálculos de variáveis com datas e horas com o pacote lubridate. Ver folha da referência: lubridate cheatsheet.\nVisualização de Dados: Traz uma introdução à criação de gráficos através do pacote ggplot2. Ver folha da referência: data visualization cheatsheet.\n\n\n\n\n\n\n\n\n\nEste livro é uma pequena contribuição à comunidade de software livre. Ele é (e sempre será) livre, e está licenciado sob a Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License.\nSe você quiser contribuir, por favor, considere em reportar algum erro ou sugestão em github.com/scopinho/Livro_Transform_Dados_R."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introdução",
    "section": "",
    "text": "Para saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=tidyverse\nPara os exemplos, iremos carregar inicialmente os seguintes pacotes:\n\ntidyverse e gt\n\nO pacote gt será utilizado apenas para eventualmente a formatação de tabelas, de modo a deixar a saída de alguns comandos mais clara.\n\nlibrary (tidyverse)\nlibrary (gt)\n\n\nFolhas de Referências\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência dos pacotes (cheatsheets) disponível no site do RStudio.\nA seguir, um exemplo de uma “Folha de Referência” do pacote DPLYR:\n\n\n\n\n\n\n\nNota\n\n\n\nAo final de cada seção de código, você poderá encontrar a chamada à função gt(). Isto é apenas para a formatação da tabela de saída e não é necessário para que você entenda os comandos precedentes. Em alguns casos, onde o volume de dados de saída pode ser extenso, usamos também a função head() para mostrar apenas as linhas iniciais. Quando o exemplo possui muitas colunas de saída, eventualmente utilizamos a função select() para selecionar apenas algumas colunas. A função print() também pode estar presente afim de apresentar o resultado de alguma linha de código relevante para o entendimento."
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "",
    "text": "A seguir temos vários exemplos de importação de dados utilizando o pacote TIDYVERSE do R. O pacote tidyverse possui vários pacotes de importação de dados, aqui iremos cobrir três deles (readr, readxl e googlesheets4). Para saber mais sobre estes pacotes, acesse:\nhttps://cran.r-project.org/package=tidyverse.\nhttps://cran.r-project.org/package=readr.\nhttps://cran.r-project.org/package=readxl.\nhttps://cran.r-project.org/package=googlesheets4.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nCaso você precise trabalhar com outras formatos de arquivos que não sejam os vistos neste documento, pode buscar maiores informações sobre os pacotes a seguir:\n\n\n\nPacote\nFormato\n\n\n\n\nhaven\nArquivos SPSS, Stata e SAS\n\n\nDBI\nBancos de Dados\n\n\njsonlite\nJSON\n\n\nxml2\nXML\n\n\nhttr\nWeb APIs\n\n\nrvest\nHTML (Web scraping)\n\n\nreadr::read_lines()\ndados texto\n\n\npdftools\nPDF\n\n\n\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\nreadxl\ngooglesheets4\ngt\nopenxlsx\n\n\nlibrary (tidyverse)\nlibrary (readxl)\nlibrary (googlesheets4)\nlibrary (gt)\nlibrary (openxlsx)\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência de importação de dados com tidyverse disponível no site do RStudio.\n\n\n\nPara a maioria dos exemplos utilizaremos os seguintes arquivos de dados:\nAlguns desses arquivos são baseados nas tabelas mtcars, storms e starwars provenientes do pacote datasets e dplyr e também algumas tabelas (Table1, 2, 3, 4a, 4b e 5) que vem com o pacote tidyr.\n\nARQUIVOS TABULADOS: (TXT, CSV, TSV e FWF):\nIremos criar os arquivos tabulados para que possamos usá-los posteriormente. Para isso, execute o código abaixo:\n\nwrite_file(\"A|B|C\\n1|2|3\\n4|5|NA\", file = \"file.txt\")\nwrite_file(\"A,B,C\\n1,2,3\\n4,5,NA\", file = \"file.csv\")\nwrite_file(\"A;B;C\\n1,5;2;3\\n4,5;5;NA\", file = \"file2.csv\")\nwrite_file(\"A\\tB\\tC\\n1\\t2\\t3\\n4\\t5\\tNA\\n\", file = \"file.tsv\")\n\n\nEXCEL_FILE.XLSX:\nA seguir, você tem um link para o arquivo Excel utilizado nos exemplos.\nArquivo Exemplo - MS Excel\nÉ um arquivo com três planilhas (S1, S2 e S3) e em cada uma delas um pequeno conjunto de dados.\n\nE a primeira planilha (S1) possui algo como:\n\n\nGOOGLE_SHEET:\nA seguir, você tem o link para a planilha do google que será utilizado mais adiante.\nPlanilha exemplo - Google Sheets"
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html#readr",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html#readr",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "1.2 READR",
    "text": "1.2 READR\nO pacote readr possui diversas funções para ler dados tabulados (ex: .csv, .tsv, .txt, etc). Estas funções começam com read_*().\nread_* (file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale, n_max = Inf, skip = 0, na = c(““,”NA”), guess_max = min(1000, n_max), show_col_types = TRUE)\nOs parametros acima, são comuns à estas funções. Veja a seguir algumas delas. Digite ?read_delim para obter maiores detalhes de como utilzá-las.\n\n1.2.1 Ler dados tabulados com readr\n\n1.2.1.1 read_delim\nUse para ler um arquivo tabulado com qualquer delimitador. Se nenhum delimitador é especificado, a função tentará advinhar automaticamente.\nPor exemplo, para ler um arquivo .TXT tabulado com o caractere “|” como delimitador, fazemos:\n\nread_delim(\"file.txt\", delim = \"|\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara armazenar a leitura do arquivo em um objeto no R, podemos usar o operador <-.\n\n\n\nmeu_arquivo_csv <-read_delim(\"file.txt\", delim = \"|\")\nmeu_arquivo_csv\n\n\n\n  \n\n\n\n\n\n1.2.1.2 read_cvs\nUse para ler um arquivo tabulado separado por vírgula. Esta função entende que casas decimais que usam o ponto (ex 1.00) como separador de casas decimais.\n\nread_csv(\"file.csv\") \n\n\n\n  \n\n\n\n\n\n1.2.1.3 read_cvs2\nUse para ler um arquivo tabulado separado por ponto-e-vírgula. Esta função entende que casas decimais que usam a vírgula (ex: 1,00) como separador de casas decimais.\n\nread_csv2(\"file2.csv\") \n\n\n\n  \n\n\n\n\n\n1.2.1.4 read_tsv\nUse para ler um arquivo tabulado separado por tab.\n\nread_tsv(\"file.tsv\") \n\n\n\n  \n\n\n\n\n\n1.2.1.5 read_fwf\nUse para ler um arquivo tabulado com tamanhos fixos de colunas.\n\n\n\n\n\n\nNota\n\n\n\nVeja que a largura das colunas deve ser passada como um vetor para a parametro col_positions = usando a função fwf_width().\n\n\n\nread_fwf(\"file.tsv\", fwf_widths(c(2,2,NA)))\n\n\n\n  \n\n\n\n\n\n\n1.2.2 Parâmetros Úteis\nAlguns parametros das funções read_*() são muito úteis durante o processo de leitura pois permitem controlar melhor o que iremos obter como resultado da leitura.\n\n1.2.2.1 Sem cabeçalho\nUse o parâmetro COL_NAMES para não trazer a primeira linha como nome das colunas.\n\nread_csv2(\"file2.csv\", col_names = FALSE) \n\n\n\n  \n\n\n\n\n\n1.2.2.2 Definir cabeçalho\nUse o parâmetro COL_NAMES para definir manualmente os nomes das colunas.\n\nread_csv(\"file.csv\", col_names = c(\"X\", \"Y\", \"Z\")) \n\n\n\n  \n\n\n\n\n\n1.2.2.3 Ler vários arquivos\nUse o parametro ID para ler multiplos arquivos e armazená-los em uma mesma tabela.\n\nwrite_file(\"A,B,C\\n1,2,3\\n4,5,NA\", file = \"f1.csv\")\nwrite_file(\"A,B,C\\n6,7,8\\n9,10,11\", file = \"f2.csv\")\nread_csv(c(\"f1.csv\", \"f2.csv\"), id = \"arq_origem\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nObserve que as colunas dos diversos arquivos devem corresponder, ou seja, ter o mesmo nome de colunas.\n\n\n\n\n1.2.2.4 Pular linhas\nUse o prâmetro SKIP para pular as primeiras n linhas.\n\nread_csv(\"file.csv\", skip = 1) \n\n\n\n  \n\n\n\n\n\n1.2.2.5 Ler um número máximo de linhas\nUse o prâmetro N_MAX para ler um número máximo de linhas.\n\nread_csv(\"file.csv\", n_max = 1) \n\n\n\n  \n\n\n\n\n\n1.2.2.6 Ler valores como NA\nUse o prâmetro NA para definir um ou mais valores como NA.\n\nread_csv(\"file.csv\", na = c(\"1\")) \n\n\n\n  \n\n\n\n\n\n1.2.2.7 Especificar caractere decimal\nUse o prâmetro LOCALE para definir o caractere de casa decimais.\n\nread_delim(\"file2.csv\", locale = locale(decimal_mark = \",\")) \n\n\n\n  \n\n\n\n\n\n\n1.2.3 Salvar dados com readr\nSimilar às funções descritas na seção “Ler dados tabulados com readr” usadas para ler os aqruivos de texto tabulados, temos o conjunto de funções write_*() para gravar os arquivos correspondentes. Estas funções seguem o seguinte padrão:\nwrite_*(x, file, na = “NA”, append, col_names, quote, escape, eol, num_threads, progress)\nAs principais funções são:\n\n1.2.3.1 write_delim\nUse para gravar um arquivo delimitado por algum caractere específico. O parametro delim= permite definir este caractere. O caracteres padrão é o espaço (” “).\nPor exemplo, se quisermos gravar uma tabela (tibble) em um arquivo .txt delimitado por ponto-e-vírgula”;“, podemos usar:\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, \"C\")\nwrite_delim(conteudo, file = \"arquivo_exemplo1.txt\", delim=\";\")\n\n\n\n1.2.3.2 write_csv\nUse para gravar uma tabela em uma arquivo delimitado por “vírgula”.\n\n\n\n\n\n\nDica\n\n\n\nPodemos usar o arqumento na = para definirmos qual valor será usando para os valore ausentes, por padrão é utilizado “NA”. No exemplo a seguir, iremos trocar por “NULL”.\n\n\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, NA,\n                   4, \"D\")\nwrite_csv(conteudo, file = \"arquivo_exemplo2.csv\", na = \"NULL\")\n\n\n\n1.2.3.3 write_csv2\nUse para gravar uma tabela em um arquivo delimitado por “ponto-e-vírgula”.\n\n\n\n\n\n\nDica\n\n\n\nPode usar o parametro “col_names =” para incluir ou não os nomes das colunas no arquivo de saída. No exemplo a seguir, não iremos incluir os nomes das colunas:\n\n\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, \"C\")\nwrite_csv2(conteudo, file = \"arquivo_exemplo3.csv\", col_names = FALSE)\n\n\n\n1.2.3.4 write_tsv\nUse para gravar uma tabela em um arquivo delimitado por “TAB”:\n\nconteudo <- tribble(~col_A, ~col_B,\n                   1, \"A\",\n                   2, \"B\", \n                   3, \"C\")\nwrite_tsv(conteudo, file = \"arquivo_exemplo4.tsv\")\n\n\n\n\n1.2.4 Especificação de colunas com readr\nAo importar um arquivo com readr, podemos definir qual o tipo de coluna que determinado dado será importado. Por padrão, o readr irá gerar a especificação de cada coluna quando o arquivo form lido e gerará um resumo na saída.\nPodemos usar o argumento spec() para extrair as especificações das colunas de um arquivo importato para um data frame.\nPor exemplo:\n\narq <- read_csv2(\"file2.csv\") \nspec(arq)\n\ncols(\n  A = col_double(),\n  B = col_double(),\n  C = col_double()\n)\n\n\nObserve que as colunas “A”, “B” e “C” são do formato double.\nHá também uma mensagem de resumo ao importar um arquivo. Observe que ele informa o delimitador utilzado, mas também a especificação das colunas, neste caso, tipo double (dbl) para as colunas A, B e C conforme confirmamos com a função spec().\n\nℹ Using “‘,’” as decimal and “‘.’” as grouping mark. Use read_delim() for more control. Rows: 2 Columns: 3── Column specification ────────────────────────────────────────────────────────────────── Delimiter: “;” dbl (3): A, B, C ℹ Use spec() to retrieve the full column specification for this data. ℹ Specify the column types or set show_col_types = FALSE to quiet this message. # READXL\n\n\n\n\n\n\n\nDica\n\n\n\nSe quisermos omitir as especificações das colunas da mensagem de saída, usamos o parametro show_col_types = FALSE\n\n\n\n1.2.4.1 col_types\nSe utilizarmos o parametro col_types = podemos definir, por exemplo, a coluna “B” como inteiro (integer). Veja:\n\narq <- read_csv2(\"file2.csv\", col_types = \"did\") \nspec(arq)\n\ncols(\n  A = col_double(),\n  B = col_integer(),\n  C = col_double()\n)\n\n\nHá uma letra definida para cada tipo de coluna que quisermos especificar, veja a lista abaixo:\n• col_logical() - “l”\n• col_integer() - “i”\n• col_double() - “d”\n• col_number() - “n”\n• col_character() - “c”\n• col_factor(levels, ordered = FALSE) - “f”\n• col_datetime(format = ““) -”T”\n• col_date(format = ““) -”D”\n• col_time(format = ““) -”t”\n• col_skip() - “-”, “_”\n• col_guess() - “?”\nPor isso, usamos string “did” para definir um double, um inteiro e outro double para as colunas que importamos.\nPodemos também passar a especificação das colunas como uma lista mesclando as funções e os caracteres correspondentes na lista acima.\nPor exemplo:\n\narq <- read_csv2(\"file2.csv\", \n          col_types = list(A = col_double(), B = \"i\", C= \"d\")\n          )\nspec(arq)\n\ncols(\n  A = col_double(),\n  B = col_integer(),\n  C = col_double()\n)\n\n\n\n\n\n\n\n\nDica\n\n\n\nUse “.default =” na lista de especificações para definir o tipo padrão para as colunas, caso as mesmas não sejam explicitamente definidas.\n\n\n\n\n1.2.4.2 col_select\nPara selecionarmos apenas algumas colunas para importar do arquivo, utilzamos o parametro col_select = passanto um vetor com o nomes das colunas.\nPor exemplo, para importar apenas as colunas “A” e “C”, podemos fazer:\n\nread_csv(\"file.csv\", col_select = c(\"A\", \"C\"))\n\n\n\n  \n\n\n\n\n\n1.2.4.3 guess_max\nPara definirmos o número máximo de linhas do arquivo para advinhar o tipo da coluna (guess), utilizamos o parametro guess_max =. O padrão são as primeiras 1000 linhas.\n\nread_csv(\"file.csv\",guess_max = 2)"
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html#readxl",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html#readxl",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "1.3 READXL",
    "text": "1.3 READXL\nPara lermos arquivos do Microsoft Excel, podemos usar o pacote readxl.\n\n1.3.1 Ler arquivos do Excel\nApesar do pacote readxl ser instalado quando instalamos o pacote tidyverse, ele não é carregado quando carregamos o tidyverse. É por isso, que tivemos o código “library (readxl) na seção Introdução\n\n1.3.1.1 read_excel\nUse para ler um arquivo do Excel (.xls ou .xlsx) baseado na extensão do arquivo.\nSe preferir, pode utilizar as funções read_xls() e read_xlsx() para ler um arquivo com .xls ou .xlsx independente da extensão do arquivo.\n\nread_excel(\"excel_file.xlsx\")\n\n\n\n  \n\n\n\n\n\n\n1.3.2 Ler planilhas\nSabemos que um arquivo Excel (workbook), pode conter uma ou mais planilhas (worksheets). Para definirmos as planilhas que precisamos importar, podemos utilizar o parametros sheet = da função read_excel(). Podemos passar uma string com o nome a planilha (ex: “S1”) ou um índice númerico pela ordem de criação da planilha (ex: 1). Se nada for especificado, padrão é trazer a primeira planilha.\n\nread_excel(\"excel_file.xlsx\", sheet = \"S1\")\n\n\n\n  \n\n\n\nPara obter os nomes das planilhas presentes no arquivo, utilizamos a função excel_sheets()\n\nexcel_sheets(\"excel_file.xlsx\")\n\n[1] \"S1\" \"S2\" \"S3\"\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara lermos múltiplas planilhas podemos obter os nomes das planilhas usando a função excel_sheets(), pois definimos os nomes do vetor iguais aos nomes das planilhas e finalmente utilizamos a função purrr::map_dfr() para importar os arquivos no data frame.\n\n\n\narq <- \"excel_file.xlsx\"\narq |> \n  excel_sheets() |> \n  set_names() |> \n  map_dfr(read_excel, path = arq)\n\n\n\n  \n\n\n\n\n\n1.3.3 Especificação de colunas\nPara especificar os tipos das colunas no data frame após a importação do arquivo, usamos o parametro col_types =, similar ao que fizemos para arquivos tabulados na seção Especificação de colunas com readr.\nOs tipos de colunas podemos ser:\n“skip”, “guess”, “logical”, “numeric”, “date”, “text” ou “list”.\n\n\n\n\n\n\nDica\n\n\n\nUse uma coluna de lista (list-column) descrita no pacote tidyr para trabalhar com colunas com vários tipos.\n\n\n\n\n1.3.4 Outros pacotes\nAlém do pacote readxl, há outros pacotes muito úteis para criar arquivos do MS Excel, tais como:\n\nopenxlsx\nwritexl\n\nPara trabalhar com dados do Excel de forma não tabular, veja o pacote:\n\ntidyxl\n\n\n\n1.3.5 Especificação de celulas\nUse os argumentos range = para a função read_excel() ou googlesheets4::read_sheet() no caso de planilhas do Google para ler um subconjunto de células de uma planilha.\nPor exemplo, se quiser ler apenas o range de células de “A1” até “B3” da planilha “S2” do arquivo excel de exemplo, por fazer:\n\nread_excel(\"excel_file.xlsx\", range = \"S2!A1:B3\")\n\n\n\n  \n\n\n\nO parametro range = , possui alguns argumentos que ajudam a melhor definir o range a ser importado. Veja ?`cell-specification` para maiores detalhes de como cell_cols(), cell_rows(), cell_limits() e anchored(). Por exemplo, usando cell_cols, podemos definir que iremos importar apenas as celulas que das colunas “B” até “D”:\n\nread_excel(\"excel_file.xlsx\", sheet = \"S1\", \n          range = cell_cols(\"B:D\"))"
  },
  {
    "objectID": "Importacao/Importacao_de_dados_com_tidyverse.html#googlesheets4",
    "href": "Importacao/Importacao_de_dados_com_tidyverse.html#googlesheets4",
    "title": "1  Importação de Dados com TIDYVERSE",
    "section": "1.4 GOOGLESHEETS4",
    "text": "1.4 GOOGLESHEETS4\n\n1.4.1 Ler planilhas\n\n1.4.1.1 read_sheet\nUse para ler planilhas do Google a partir de uma URL, um IDde planilha ou um objeto do tipo “dribble” que é retornado pelo pacote googledrive. Esta função é um “apelido” para a função range_read() que é mais utilizada no contexto do pacote googlesheets4.\nDiversos argumtos vistos para as funções read_* são aplicadas aqui também, como col_types = , sheet =, range = , guess_max = . Veja mais detalhes na seção do readr descrita anteriormente.\nNo exemplo a seguir iremos ler uma planilha do Google de exemplo. Para isso, recebemos o seguinte URL. Veja que a partes em negrito corresponde ao ID do arquivo e o ID da planilha respectivamente:\nhttps://docs.google.com/spreadsheets/d/1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8/edit#gid=0\nUsamos então a função read_sheet():\n\ngooglesheets4::read_sheet(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\", sheet = \"Sheet1\")\n\n\n\n  \n\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nA primeira vez que executar este comendo, haverá um processo de autenticação da sua conta do Google e seeão do R. Reponda “Yes” para a pergunta “Is it OK to cache OAuth access credentials in the folder ~/.cache/gargle between R sessions?”\n1: Yes\n2: No\nDepois o navegador será aberto solicitando o acesso aos arquivo do Google. Selecoine o checkbox e click em “Continue”.\n\n\n\n\n\n1.4.2 Metadados das planilhas\n\n1.4.2.1 gs4_gets\nUse para obter os metadados do arquivo:\n\ngs4_get(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\")\n\nSpreadsheet name: tidyverse_exemplo\n              ID: 1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\n          Locale: en_US\n       Time zone: America/Sao_Paulo\n     # of sheets: 45\n\n(Sheet name): (Nominal extent in rows x columns)\n      Sheet1: 1000 x 26\n          df: 4 x 2\n      Sheet2: 4 x 2\n      Sheet3: 4 x 2\n      Sheet4: 4 x 2\n      Sheet5: 4 x 2\n      Sheet6: 4 x 2\n      Sheet7: 4 x 2\n      Sheet8: 4 x 2\n      Sheet9: 4 x 2\n     Sheet10: 4 x 2\n     Sheet11: 4 x 2\n     Sheet12: 4 x 2\n     Sheet13: 4 x 2\n     Sheet14: 4 x 2\n     Sheet15: 4 x 2\n     Sheet16: 4 x 2\n     Sheet17: 4 x 2\n     Sheet18: 4 x 2\n     Sheet19: 4 x 2\n     Sheet20: 4 x 2\n     Sheet21: 4 x 2\n     Sheet22: 4 x 2\n     Sheet23: 4 x 2\n     Sheet24: 4 x 2\n     Sheet25: 4 x 2\n     Sheet26: 4 x 2\n     Sheet27: 4 x 2\n     Sheet28: 4 x 2\n     Sheet29: 4 x 2\n     Sheet30: 4 x 2\n     Sheet31: 4 x 2\n     Sheet32: 4 x 2\n     Sheet33: 4 x 2\n     Sheet34: 4 x 2\n     Sheet35: 4 x 2\n     Sheet36: 4 x 2\n     Sheet37: 4 x 2\n     Sheet38: 4 x 2\n     Sheet39: 4 x 2\n     Sheet40: 4 x 2\n     Sheet41: 4 x 2\n     Sheet42: 4 x 2\n     Sheet43: 4 x 2\n     Sheet44: 4 x 2\n\n\n\n\n1.4.2.2 gs4_find\nUse para localizar suas planilhas do Google no drive. Ela retorna um objeto dibble, que é um “tibble” com uma linha por arquivo. E informa o ID dos arquivos.\n\nmy_dribble <- gs4_find(pattern = \"tidyverse_exemplo\")\nmy_dribble\n\n\n\n  \n\n\n\nsheet_properties\nUse para obter uma tabela (tibble) com as propriedades de cada planilha.\n\nsheet_properties(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\")\n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nVocê pode usar a função sheet_names() para obter os nomes da planilha dentro do arquivo.\n\n\n\n\n\n1.4.3 Gravar planilhar\nO pacote googlesheets4 tem várias maneiras de gravar dados em uma planilha.\n\n1.4.3.1 write_sheet\nUse esta função para salvar um data frame em uma planilha no arquivo do Google Sheets. Se a planilha não existir, ele cria uma planilha co mum nome aleatório através da função gs4_create().\n\ndf <- tribble(~x, ~y,\n              1, \"A\",\n              2, \"B\",\n              3, \"C\")\nwrite_sheet(df, \"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\")\nread_sheet(\"1_aRR_9UcMytZqjID0BkJ7PW29M1kt1_x2HxhBZOlFN8\", sheet = \"df\")\n\n\n\n  \n\n\n\n\n\n1.4.3.2 gs4_create\nUse para criar uma nova planilha do Google. Você pode fornecer o nome, mas caso não o faça o Google irá atribuir um nome aleatorio ao seu arquivo.\n\nminha_planilha <- gs4_create(name = \"meu_novo_arquivo_google_sheet\", sheets = \"Sheet1\")\nsheet_properties(minha_planilha)\n\n\n\n  \n\n\n\n\n\n\n1.4.4 Especificação de colunas\nPara especificar os tipos das colunas no data frame após a importação da planilha do Google, usamos o parametro col_types = como argumento da função read_sheet/range_read(), similar ao que fizemos para arquivos tabulados na seção Especificação de colunas com readr.\nOs tipos de colunas aceitos são:\n• skip - “_” ou “-”\n• guess - “?”\n• logical - “l”\n• integer - “i”\n• double - “d”\n• numeric - “n”\n• date - “D”\n• datetime - “T”\n• character - “c”\n• list-column - “L”\n• cell - “C” Retorna uma lista bruta dos dados das células.\n\n\n1.4.5 Especificação de celulas - Google Sheets\nVer seção Especificação de celulas\n\n\n1.4.6 Operadores de arquivos\nO pacote googlesheets4 oferece várias forma de manipular os aspectos da planilha como congelar linhas, definir largura das colunas, etc. Acesse googlesheets4.tidyverse.org para mais informações.\nPara operções de arquivos (ex: renomear, compartilhar, mover para outra pasta, etc), veja o pacote googledrive no link: googledrive.tidyverse.org."
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html",
    "title": "2  Organização de Dados com TIDYR",
    "section": "",
    "text": "A seguir temos vários exemplos de organização de dados utilizando o pacote TIDYR do R. Para saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=tidyr.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\ngt\n\n\nlibrary (tidyverse)\nlibrary (gt)\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência do tidyr disponível no site do RStudio.\n\n\n\nPara a maioria dos exemplos utilizaremos as bases de dados mtcars, storms e starwars provenientes do pacote datasets e dplyr e também algumas tabelas (Table1, 2, 3, 4a, 4b e 5) que vem com o pacote tidyr.\n\nMTCARS: Dados de consumo de combustível, performance e design de 32 automóveis ( 1974 Motor Trend US magazine)\n\nmtcars |> \n  head () \n\n\n\n  \n\n\n\n\nSTORMS: Dados de furacões entre 1975-2020 medidos a cada 6 horas durante cada tempestade ( NOAA Atlantic hurricane database ),\n\nstorms |> \n  head () \n\n\n\n  \n\n\n\n\nSTARWARS: Dados dos personagens de STAR WARS\n\nstarwars |> \n  select(1:8) |> \n  head()\n\n\n\n  \n\n\n\nTABELAS EXEMPLOS - Table1, 2, 3, 4a, 4b e 5\n\nTable1Table2Table3Table4aTable4bTable5\n\n\n\ntable1\n\n\n\n  \n\n\n\n\n\n\ntable2\n\n\n\n  \n\n\n\n\n\n\ntable3\n\n\n\n  \n\n\n\n\n\n\ntable4a\n\n\n\n  \n\n\n\n\n\n\ntable4b\n\n\n\n  \n\n\n\n\n\ntable5\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nO termo data-frame descrito ao longo deste texto, é utilizado de forma livre para objetos do tipo data.frame, tibble, entre outros. Pense como se fosse uma tabela de um banco de dados e/ou uma planilha do MS Excel, contendo linhas e colunas. Apesar de não ser rigorosamente igual à uma tabela, muitas vezes usaremos estes termos de forma intercambiável para facilitar o entendimento de iniciantes.\n\n\n\n\n\nDados organizados (tidy) são estruturados onde:\nCada variável está em sua própria coluna e cada observação está em sua própria linha.\n\nAs variáveis (ou colunas) são acessadas como vetores.\nOs observações (ou linhas) são preservadas em operações vetorizadas, ou seja, quando utilizamos funções que recebem vetores na entrada e retornam vetores na sua saída."
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#tibbles",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#tibbles",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.2 Tibbles",
    "text": "2.2 Tibbles\nPodemos considerar que “Tibbles” são objetos similares aos “Data Frames”, porém com algumas melhorias/vantagens. Estes objetos são fornecidos pelo packago tibble. Eles herdam a classe data frame, mas possuem alguns comportamentos melhorados, como:\n\nExtrai parte de um tibble usando colchetes ] e um vetor com duplo colchetes ]] ou $\nSem encontros parciais quando extraindo partes das colunas\nMostram uma resumo mais amigável na tela quando pedimos suas informações. Use options(tibble.print_max = n, tibble.print_min = m, tibble.width = Inf) para controlar a saída padrão.\nAs funções View() ou glimpse() permitem visualizar todo o conjunto de dados.\n\nPor exemplo, se tivermos um tibble (ex starwars) e quisermos acessar a coluna “name”, e obter um vetor, podemos usar:\n\nstarwars[[\"name\"]] #Por nome com [[  ]]\nstarwars$name      #Por nome com $\nstarwars[[1]]      #Por numero da coluna com [[  ]]\n\nJá se tivermos um tibble (ex starwars) e quisermos acessar a coluna “name”, e obter um tibble, podemos usar:\n\nstarwars[ , 1]            #Por numero com [   ]\nselect (starwars, 3)      #Por numero usando select()\nselect (starwars, name)   #Por nome usando select()\n\n\n2.2.1 Criando tibble\nPodemos utilziar as funções tibble() ou tribble() para criar a mesma tabela. A diferença é apenas na forma em que os parêmetros são utilizados.\n\n2.2.1.1 tibble\nUse para criar um tibble por colunas.\n\ntibble(x = 1:3, y = c(\"a\", \"b\", \"c\"))\n\n\n\n  \n\n\n\n\n\n2.2.1.2 tribble\nUse para criar um tibble por linhas.\n\ntribble(~x, ~y, \n        1, \"a\",\n        2, \"b\",\n        3, \"c\",\n        4, \"d\")\n\n\n\n  \n\n\n\n\n\n2.2.1.3 as_tibble\nUse para converter um data frame para um tibble.\nPor exemplo, para converter o data frame MTCARS para um tibble, fazemos:\n\nas_tibble(mtcars)\n\n\n\n  \n\n\n\n\n\n2.2.1.4 enframe\nUse para converter um vetor para um tibble. Use deframe() parta fazer o inverso.\n\n\n2.2.1.5 is_tibble\nUse para saber se um objeto é um tibble ou não.\n\nis_tibble(mtcars)\n\n[1] FALSE"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#reformatando-dados",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#reformatando-dados",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.3 Reformatando Dados",
    "text": "2.3 Reformatando Dados\nMuitas vezes, os dados que recebemos não estão organizados (tidy) da maneira como vimos na seção Dados Organizados e Canalização. Para casos onde temos, por exemplo, as variáveis em linhas e/ou observações em colunas, etc, precisamos fazer uma ação conhecida como “pivotagem”. Pivotar dados, no contexto do tidyr, significa ajustar linhas em colunas e/ou colunas em linhas, de forma a obtermos nossos dados da maneira organizada (tidy).\nVeja, por exemplo, nossa tabela 1 (table1). Ela está em um formato organizado, pois possui cada variável em uma coluna e cada observações em sua linha, com os valores nas células.\n\ntable1\n\n\n\n  \n\n\n\n\n2.3.0.1 pivot_longer\nUse para “pivotar” os dados das colunas para as linhas, alongando a tabela, juntando várias colunas em duas, sendo uma a colunas que receberá os nomes das colunas e outra que recebera os valores das colunas.\nPor exemplo, vejamos nossa tabela 4 (table4).\n\ntable4a\n\n\n\n  \n\n\n\nObserve que temos uma variável (potencialmente “Ano”) que está na colunas 2 e 3 da tabela. Temos também outra variável (potencialmente “Numero_de_Casos” que está nas células da tabela.\nPara organizar esta tabela em nosso formato “tidy”, devemos pegar estas duas colunas e usar a função pivot_longer definindo os nomes para as respectivas variáveis (ex: ano e num_caso).\n\npivot_longer(table4a, cols = 2:3, names_to =\"ano\",\nvalues_to = \"num_casos\") \n\n\n\n  \n\n\n\n\n\n2.3.0.2 pivot_wider\nUse para “pivotar” os dados das linhas para as colunas, expandindo a tabela gerando novas colunas.\nVejamos o caso da tabela 2 (table2).\n\ntable2\n\n\n\n  \n\n\n\nNeste exemplo, vemos que as variáveis casos (cases) e população (population) estão nas linhas e não nas colunas. Para deixarmos os dados organizados (tidy), devemos “expandir” a tabela, fazendo com que os dados de duas colunas sejam expandidos em vaŕias colunas. Os nomes das novas colunas virão de uma colunas e os valores da outra coluna. Veja:\n\ntable2 |> \n  pivot_wider(names_from = type, values_from = count)"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#expandindo-tabelas",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#expandindo-tabelas",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.4 Expandindo Tabelas",
    "text": "2.4 Expandindo Tabelas\nEm algumas situações, precisamos criar novas combinações das variáveis ou identificar valores ausentes implícitos, ou seja, combinações de variáveis não presentes nos dados.\nPara isto, temos as funções expand() e complete().\n\n2.4.0.1 expand\nUse para criar um novo tibble com todas as possibilidades de combinações dos valores das variáveis passadas para a função expand(), ignorando as demais variáveis.\nPor exemplo, se quisermos obter todas as combinações possíveis entre o número de cilindros (cyl), marchas (gear) e numero de carburadores (carb) da tabela mtcars, e ignorar todas as demais variáveis da tabela, podemos usar:\n\nmtcars |> \n  expand(cyl, gear, carb) \n\n\n\n  \n\n\n\nObserve que não há na tabela original (mtcars) um veículo de 4 cilindros e 8 carburadores, porém esta combinação foi possível usando a função expand().\n\n\n2.4.0.2 complete\nUse para criar um novo tibble com todas as possibilidades de combinações dos valores das variáveis passadas para a função expand(), colocando NA nas demais variáveis.\nPor exemplo, se quisermos obter todas as combinações possíveis entre o número de cilindros (cyl), marchas (gear) e numero de carburadores (carb) da tabela mtcars, e colocar NA para as demais variáveis em que a combinação não exista, podemos usar:\n\nmtcars |> \n  complete(cyl, gear, carb)"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#combinando-e-dividindo-celulas",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#combinando-e-dividindo-celulas",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.5 Combinando e Dividindo Celulas",
    "text": "2.5 Combinando e Dividindo Celulas\nUse as funções a seguir para dividir ou combinar células da tabela em valores individuais isolados.\n\n2.5.0.1 unite\nUse para combinar celulas de diversas colunas em uma única coluna.\nVejamos com é a tabela 5 (table5) em seu formato original:\n\ntable5 \n\n\n\n  \n\n\n\nAgora queremos unir as colunas “century” e “year” em uma única coluna:\n\ntable5 |> \n  unite(century, year, col = \"ano_completo\", sep = \"\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nVeja que as colunas que deram origem à coluna combinada não são retornadas na saída da função.\n\n\n\n\n2.5.0.2 separate\nUse para dividir cada célula de uma coluna em várias colunas.\nPor exemplo, na tabela 3 (table3), temos uma coluna “rate” que possui daos dos casos e população separados por uma barr (“/”). Neste caso, podemos utilzar a função separate para dividí-la e criar duas novas colunas com seus dados separados.\n\ntable3 |> \n  separate(rate, sep = \"/\", \n           into = c(\"casos\", \"pop\")) \n\n\n\n  \n\n\n\n\n\n2.5.0.3 separate_rows\nUse para dividir cada célula de uma coluna em várias linhas.\nÉ similar a função separate, porém o conteúdo de cada célula irá para uma linha ao invés de uma colunas.\n\ntable3 |> \n  separate_rows(rate, sep = \"/\")"
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#lidando-com-valores-ausentes",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#lidando-com-valores-ausentes",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.6 Lidando com Valores Ausentes",
    "text": "2.6 Lidando com Valores Ausentes\nMuitas vezes precisamos ignorar ou substituir valores ausentes (NA). Para isso, podemos usar as funções drop_na(), fill() ou replace_na()\n\n2.6.0.1 drop_na\nIgnora linhas que possuem valores ausentes (NA) nas colunas.\nPor exemplo, na tabela starwars, temos 5 personagens que não possuim cor de cabelo (hair color):\n\nstarwars |> \n  select(name, hair_color) |> \n  filter(is.na(hair_color))\n\n\n\n  \n\n\n\nSe pedirmos para listar todos os personagens e utilizarmos a função drop_na(), estes 5 personagens não serão listados:\n\nstarwars |> \n  select(name, hair_color) |> \n  drop_na()\n\n\n\n  \n\n\n\n\n\n2.6.0.2 fill\nUse para substituir o valores ausente (NA) da coluna pelo último valor disponível em linhas anteriores ou posteriores.\nPor exemplo:\nComo vimos no exemplo da função drop_na, temos 5 personagens de starwars que não possuem cor de cabelo preenchido.\nDigamos que decidimos substituir estes NAs pelo cor de cabelo do personagem anterior disponível. Para isso, faremos:\n\nstarwars |> \n  select (name, hair_color) |> \n  fill(hair_color)\n\n\n\n  \n\n\n\nVeja que o personagem C-3PO que tinha a cor de cabelo não preenchida, agora está como loiro (blond), pois o personagem anteriormente preenchido, era o Luke Skywalker, que tinha a cor de cabelo loiro (blond). Já o personagem R5-D4, teve sua cor de cabelo preenchida de marron (brown), pois o personagem anterior Beru Whitesun lars, tinha o cabelo marron (brown).\n\n\n2.6.0.3 replace_na\nUse para substituir os valores de NA por um valor específico.\nPor exemplo, vamos substituir a cor de cabelo dos personagens que tem NA na coluna “hair_color” pela cor azul (blue).\n\nstarwars |> \n  select(name, hair_color) |> \n  replace_na(list(hair_color = \"blue\"))\n\n\n\n  \n\n\n\n\n\n\n\n\n\nAviso\n\n\n\nVeja que a função replace_na, recebe uma lista de valores (list()) se os dados passados no primeiro parâmetro é um data frame."
  },
  {
    "objectID": "Organizacao/Organizacao_de_dados_com_tidyr.html#dados-aninhados",
    "href": "Organizacao/Organizacao_de_dados_com_tidyr.html#dados-aninhados",
    "title": "2  Organização de Dados com TIDYR",
    "section": "2.7 Dados Aninhados",
    "text": "2.7 Dados Aninhados\n\n2.7.1 Introdução\nUm data frame aninhado (nested) é aquela que possui tabelas completas em colunas do tipo lista (colunas de lista) dentro de outro data frame maior e organizado. Uma coluna de lista, podem ser também listas de vetores ou listas de vários tipos de dados.\nAlguns uso de um data frame de dados aninhados são:\n\nPreservar o relacionamento entre observações e sub-grupos de dados.\nPreservar o tipo da variável aninhada (factors e datetime não viram caracteres por exemplo).\nManipular várias sub-tabelas de uma vez com funcções do pacote purrr como map(), map2() ou pmap() ou com a rowwise() do pacote dplyr.\n\n\n\n2.7.2 Criando dados Aninhados\n\n2.7.2.1 nest\nUse para mover grupos de células para uma coluna de lista de um data frame. Pode ser usada sozinha ou em conjunto com a grupo_by().\nExemplo 1: nest() com groupg_by()\nDigamos que gostaríamos ter uma linha para cada furacão de nosso data frame (storms) e em uma coluna de lista, uma tabela dos dados do respectivo furação. Para isso, podemos utilizar a função nest() em conjunto com a função group_by(). Veja abaixo:\n\nn_storms <- storms  |> \n  group_by(name) |> \n  nest()\nhead(n_storms, 15)\n\n\n\n  \n\n\n\nObserve que na coluna “data”, temos um objeto <tibble> para grupo criado pela função group_by. A função nest() aninhou todas as demais variáveis nestas pequenas tabelas para cada um deles e armazenou na coluna do tipo lista.\nPara acessar a tibble gerada para o primeiro grupo (furacão “Amy” na primeira linha acima), podemos fazer:\n\nn_storms$data[[1]] \n\n\n\n  \n\n\n\nPara acessar todas as observações as variáveis “month” e “status” especificamente, podemos usar:\n\nn_storms$data[[1]][, c(\"month\", \"status\")] |> \n  head() \n\n\n\n  \n\n\n\nExemplo 2: nest() especificando colunas\nDigamos que precisamos especfificar as colunas que gostaríamos de aninhar em cada linha da coluna de lista. Apenas para simplificar o exemplo, iremos selecionar com a função selct() apenas as colunas “name”, “year”, “lat” e “long”. Depois iremos aninhar as colunas “year” até a coluna “long” em um coluna de lista chamada “data”. Veja a seguir:\n\nn_storms <- storms  |> \n  select(name, year, lat, long) |> \n  nest(data = c(year:long))\nhead(n_storms)\n\n\n\n  \n\n\n\nAgora temos as colunas “year”, “lat” e “long” aninhadas na coluna de lista chamada “data” para cada observação da coluna “name”.\nAssim como vimos anteriormente, podemos acessar as tibbles da coluna dat usando [[ ]]. Por exemplo:\n\nn_storms$data[[1]]\n\n\n\n  \n\n\n\n\n\n\n2.7.3 Criando Tibbles com Colunas de Listas\nPara criar um objeto tibble com colunas de lista (list-column), você pode utilizar as mesmas funções tibble(), trible() e enframe(), passando uma objeto lista para a coluna.\n\n2.7.3.1 tibble\nUse para criar uma tibble com uma coluna de lista salvando uma lista na coluna.\n\ntibble(max=c(3,4,5), seq=list(1:3, 1:4, 1:5))\n\n\n\n  \n\n\n\n\n\n2.7.3.2 tribble\nUse para criar uma tibble com uma coluna de lista por linhas.\n\ntribble(~max, ~seq, \n       3, 1:3,\n       4, 1:4,\n       5, 1:5)\n\n\n\n  \n\n\n\n\n\n2.7.3.3 enframe\nUse para converter listas em um tibble dentro de uma coluna de lista.\n\nlista <- list('3'=1:3, '4'=1:4, '5'=1:5)\nenframe(lista, 'max', 'seq')\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserve que nossa lista possui “nomes” nos vetores (3, 4 e 5), se isso não for o caso, ele irá nomear as colunas com a sequencia lógica dos vetores (1, 2 e 3).\n\n\n\n\n2.7.3.4 Outras Funções Retornam Coluna de Lista\nAlgumas funções, como por exemplo, mutate(), transmute() e summarise() do pacote dplyr tem como saída uma colunas de lista caso retornem uma lista.\nPor exemplo, se criarmos uma lista com os quartis da variável consumo (mpg) da tatela mtcars agrupada por cilindros (cyl) e utilzarmos a função summarise(), teremos uma coluna de lista contendo os quartis para cada grupo de cilindro.\n\nmtcars  |> \ngroup_by(cyl)  |> \nsummarise(q = list(quantile(mpg)))\n\n\n\n  \n\n\n\n\n\n\n2.7.4 Reformatando dados Aninhados\n\n2.7.4.1 unest\nUse para desaninhar os dados. Esta função, faz o inverso da função nest.\nPor exemplo, para desaninhar os dados da coluna data criada na tabela n_storms, fazemos:\n\nn_storms |> \n  unnest(data)\n\n\n\n  \n\n\n\n\n\n2.7.4.2 unest_longer\nUse para desaninhar um coluna de lista, tornando cada elemento da lista em uma linha.\nPor exemplo, na tabela starwars, temos uma coluna de lista chamada “films”, nesta coluna temos uma lista de filmes que cada personagem participou. Se quisermos desaninhar esta coluna e colocar cada filme em uma linha, faremos:\n\nstarwars |> \nselect(name, films) |> \nunnest_longer(films)\n\n\n\n  \n\n\n\n\n\n2.7.4.3 unest_wider\nUse para desaninhar um coluna de lista, tornando cada elemento da lista em uma coluna.\nPor exemplo, na tabela starwars, temos uma coluna de lista chamada “films”, nesta coluna temos uma lista de filmes que cada personagem participou. Se quisermos desaninhar esta coluna e colocar cada filme em uma coluna, faremos:\n\nstarwars |> \n  select(name, films) |> \n  unnest_wider(films, names_sep = '_')\n\n\n\n  \n\n\n\n\n\n2.7.4.4 hoist\nUse para selecionar componentes específicos de uma lista e desaninhá-lo em uma nova coluna. É similar ao unnest_wider(), mas desaninha colunas específicas usando a sintaxe do purrr:pluck().\nPor exemplo, vamos desaninhar apenas o primeiro e segundo filmes em que o psernagem de starwars particiou e manter os demais anihados:\n\nstarwars %>%\nselect(name, films) %>%\nhoist(films, \"1o_filme\" = 1, \"2o_filme\" = 2)\n\n\n\n  \n\n\n\n\n\n\n2.7.5 Transfromando dados Aninhados\nUma função vetorizada recebe um vetor, transforma cada elemento em paralelo e retorna um vetor de mesmo tamanho que o vetor de entrada. Estas funções sozinhas não trabalham com listas, e consequentemente, não trabalham com colunas de listas.\nA função dplyr::rownames() agrupa cada linha da tabela em um grupo diferente e dentro de cada grupo os elementos da coluna de lista aparecem diretamente (acessados por colchetes duplo) e não mais como uma lista e tamanho 1.\nPortanto, quando usamos a rownames(), as funções vetorizadas do pacote dplyr poderão ser aplicadas em uma coluna de lista de uma forma vetorizada.\n\n2.7.5.1 Exemplo 1:\nVamos aplicar a função mutate() para criar uma nova coluna de lista contendo as dimensões do tibble presente na coluna “data”:\n\n\nn_storms  |> \n  rowwise() |> \n  mutate (\"dim\" = list(dim(data)))\n\n\n\n  \n\n\n\n\n\n2.7.5.2 \nNeste exemplo, utilzamos a função dim() que retorna as dimensões de um objeto. Como na coluna “data”, temos um objeto tibble para cada linha, a função dim irá retornar dois valores (qtd de linha e qtd de colunas).\nIsto só funcionou porque agrupamento através da função rowwise() a tabela anterior.\n\n\n2.7.5.3 Exemplo 2:\nVamos aplicar a função mutate() para criar um coluna “normal” contendo o número de linhas da tibble presente na coluna “data”:\n\nn_storms  |> \n  rowwise() |> \n  mutate (\"num_linhas\" = nrow(data))\n\n\n\n  \n\n\n\n\n\n2.7.5.4 Exemplo 3:\nVamos aplicar a função mutate() para criar um coluna de lista contendo uma outra lista com a união entre as colunas de listas “vehicles” e “starships” presentes na tabela starwars:\n\nstarwars |> \n  rowwise() |> \n  mutate (transporte = list(append(vehicles, starships))) |> \n  select(name, transporte) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nSe quisermos pegar os transportes criados e colocá-los em linhas, podemos usar a função unest.\n\n\n\nstarwars |> \n  rowwise() |> \n  mutate (transporte = list(append(vehicles, starships))) |> \n  select(name, transporte) |> \n  unnest(transporte)\n\n\n\n  \n\n\n\n\n\n2.7.5.5 Exemplo 4:\nVamos aplicar a função mutate() para criar um coluna de lista contendo uma o tamanho das listas “vehicles” e “starships” presentes na tabela starwars, e depois iremos desaninhar esta lista, obtendo assim quantos transportes cada personagem possui:\n\nstarwars |> \n  rowwise() |> \n  mutate (transporte = list(length(c(vehicles, starships)))) |> \n  select(name, transporte) |> \n  unnest(transporte)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nVeja o pacote purrr para outras funções que manipulam listas.\n\n\nObserve pelos exemplos anteriores que quando temos uma função que retorna uma lista, devemos usar a função list() para criar uma coluna de lista. Se a função retorna um valor (ex um inteiro), a coluna criada será um coluna “normal”, neste caso um coluna de inteiros."
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "",
    "text": "A seguir temos vários exemplos de transformação de dados utilizando o pacote DYPLR do R. Para saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=dplyr.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nPara os exemplos à seguir, iremos usar os seguintes pacotes:\n\ntidyverse\ngt\n\n\nlibrary(tidyverse)\nlibrary (gt)\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência do dyplr disponível no site do RStudio.\nPara a maioria dos exemplos utilizaremos as bases de dados mtcars e starwars provenientes do pacote datasets e dplyr.\n\n\n\n\n\n\nNota\n\n\n\nEm geral, ao final de cada comando, você poderá ver uma chamada à função gt(). Isto é apenas para a formatação da tabela de saída e não é necessário para que você entenda os comandos precedentes. Em alguns casos, onde o volume de dados de saída pode ser extenso, usamos também a função head() para mostrar apenas as linhas iniciais. Quando o exemplo possui muitas colunas de saída, eventualmente utilizamos a função select() para selecionar apenas algumas colunas.\n\n\n\nMTCARS: Dados de consumo de combustível, performance e design de 32 automóveis ( 1974 Motor Trend US magazine)\n\nmtcars |> \n  head () \n\n\n\n  \n\n\n\n\nSTARWARS: Dados dos personagens de STAR WARS\n\nstarwars |> \n  select(1:8) |> \n  head() \n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nO termo data-frame descrito ao longo deste texto, é utilizado de forma livre para objetos do tipo data.frame, tibble, entre outros. Pense como se fosse uma tabela de um banco de dados e/ou uma planilha do MS Excel, contendo linhas e colunas. Apesar de não ser rigorosamente igual à uma tabela, muitas vezes usaremos estes termos de forma intercambiável para facilitar o entendimento de iniciantes.\n\n\n\n\n\nDados organizados (tidy) são estruturados onde:\nCada variável está em sua própria coluna e cada observação está em sua própria linha.\n\nCanalização (Piping) é uma forma de sequenciar as funções, facilitando a leitura de várias funções em conjunto. O símbolo |> ou %>% podem ser utilizados para esta finalidade.\nExemplo: x |> f(y), é o mesmo que f(x,y)"
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#resumindo-observações",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#resumindo-observações",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.2 Resumindo Observações",
    "text": "3.2 Resumindo Observações\nFunções de resumo recebem vetores como entrada e retornam um único valor.\n\n3.2.0.1 summarise\n\nsummarise (mtcars, media=mean(mpg)) \n\n\n\n  \n\n\n\nCria um novo data-frame. Ele gera uma linha para cada combinação de grupos de variáveis. Se não houver grupos, a saída será uma única linha resumindo todas as observações da entrada.\nNo exemplo acima, não especificamos nenhum grupo (mais na seção Agrupando Observações), por isso, ele retorna apenas uma linha resumindo todas as observações de mtcars. Como também especificamos a função de mean(), o valor retornado será a média da coluna mpg para todas as observações do data frame em uma única variável (coluna) chamada média.\nOutra format de se escrever o comando acima, utilizando a canalização (“pinping”) descrita acima, seria:\n\nmtcars |> \n  summarise(média = mean(mpg))\n\nVer a seção de Funções de Resumo para mais detalhes.\n\n\n3.2.0.2 count\nConta valores únicos de uma ou mais variáveis.\n\nmtcars |> \n  count (cyl) \n\n\n\n  \n\n\n\nNo exemplo acima, contamos os valores únicos da variável cyl e mostramos na variável n. Um equivalente seria utilizar o summarise com o grupo criado na variável cyl: mtcars |> group_by(cyl) |> summarise(n = n()).\nMais sobre a função group_by na seção Agrupando Observações."
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#agrupando-observações",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#agrupando-observações",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.3 Agrupando Observações",
    "text": "3.3 Agrupando Observações\n\n3.3.0.1 group_by\nUse group_by (.data, …, .add = FALSE, .drop = TRUE) para criar uma cópia da tabela agrupada por colunas. As funções do dplyr irão manipular cada grupo separadamente e combinar os resultados.\n\n\n\n\n\n\nImportante\n\n\n\nSe compararmos o resultado de uma tabela antes e depois do agrupamento (group_by), apenas uma informação sobre o grupo será visível.\nIsto significa que o agrupamento só afetará o resultado de saída se utilizado em conjunto com funções que entendam esta mudança de contexto, como as funções do dyplr.\n\n\nPor exemplo, ANTES de agruparmos pela variável cyl (group_by(cyl)) temos:\n\nmtcars |> \n  as_tibble()\n\n\n\n  \n\n\n\nDEPOIS do group_by:\n\nmtcars |> \n  group_by(cyl) \n\n\n\n  \n\n\n\nVeja que, exceto pela informação :\n’# Groups: cyl [3]\nTodo o restante da saída é o mesmo. Por isso, é importante que utilizemos o contexto do grupo, junto com outra função.\nExemplo: Se quiser criar uma tabela com a função summarise() com apenas o grupo de cilindradas, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise() \n\n\n\n  \n\n\n\nSupondo que quiséssemos agora, saber o número de carros, agrupados pela variável cyl, podemos utilizar a função summarise, após o agrupamento, criando uma coluna através da função n().\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(num_automoveis = n()) \n\n\n\n  \n\n\n\nEm outro exemplo, podemos extrair o consumo médio (miles/gallon) dos veículos agrupado pelo número de cilindros destes veículos.\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(consumo_medio = mean(mpg)) \n\n\n\n  \n\n\n\nO agrupamento pode ser feito por mais de uma variável também. Por exemplo, se quisermos obter o consumo médio (miles/gallon) dos veículos agrupado pelo número de cilindros destes veículos e também por número de marchas, podemos ter:\n\n\n\n\n\n\nNota\n\n\n\nA saída da função summarise, dependendo do caso, irá ser agrupada também automaticamente, se quiser que isto não aconteça, utiliza a opção .groups=“drop”.\n\n\n\nmtcars |> \n  group_by(cyl, gear) |> \n  summarise(consumo_médio = mean(mpg), .groups = \"drop\") \n\n\n\n  \n\n\n\nA função un_group() remove os grupos definidos em uma tabela. É uma boa prática, remover os grupos após efetuar uma sumarização, por exemplo, afim de evitar resultados indesejáveis em sumarizações futuras. Por exemplo:\n\nmtcars |> \n  group_by(cyl, gear) |> \n  summarise(numero_marchas = n()) |> \n  ungroup() \n\n\n\n  \n\n\n\nNo caso acima, se não tivessemos utilizado o desagrupamento (un_group), o resultado ainda teria os grupos demarcados.\n\n\n3.3.0.2 rowwise\nUse rowwise(.data, …) para agrupar dados em linhas individuais. Funções do dyplr irão computar os resultados para cada linha.\nNo exemplo abaixo, a tabela de dados startwars, possui uma variável (films) que é o tipo lista, ou seja, a coluna contém uma lista de filmes para cada personagem (observação).\nSupondo que quiséssemos saber em quantos filmes cada personagem aparece:\n\nstarwars |> \n  select(name, films) |>\n  rowwise() |>\n  mutate(quantos_filmes = length(films)) |> \n  head () \n\n\n\n  \n\n\n\nEm geral, utilizamos a função rowwise quando não temos uma função vetorizada, isto é, que não retorna um vetor e precisamos aplicá-la em cada linha da tabela.\n\n\n\n\n\n\nNota\n\n\n\nAqui utilizamos também a função head () que retorna apenas as primeiras linhas de uma tablea e não todo seu conteúdo.\n\n\nVeja a seção de Funções Vetorizadaspara maiores informações."
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#manipulando-observações",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#manipulando-observações",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.4 Manipulando Observações",
    "text": "3.4 Manipulando Observações\n\n3.4.1 Extração de Observações\nO dplyr possui uma série de funções que nos ajudam a extrair observações (linhas) de uma tabela, dentre estas, temos:\n\n3.4.1.1 filter\nExtrai linhas de uma tablea que satisfazem o critério lógico.\nfilter(.data, …, .preserve = FALSE)\nExemplo: Para extrair apenas os veículos que possuem consumo (miles/galon) acima de 20, podemos usar:\n\nfilter(mtcars, mpg > 20) \n\n\n\n  \n\n\n\nPodemos utilizar operadores lógicos para ajustar os critérios do filtro, como por exemplo, os operadores abaixo:\n==, >, >=, &, |, !, xor(), is.na(), between(), near(), entre outros\nPor exemplo, para filtrar os veículos com consumo acima de 20 E com apenas 3 marchas, temos:\n\nmtcars |> \n  filter(mpg > 20 & gear == 3) \n\n\n\n  \n\n\n\n\n\n3.4.1.2 distinct\nRemove linhas com valores duplicados, retornando apenas os valores únicos da variável (coluna).\ndistinct(.data, …, .keep_all = FALSE) .\nPor exemplo, se precisarmos saber quais os valores da variável gear (marcha), podemos utilizar:\n\nmtcars |> \n  distinct(gear) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nSe utilizar o código acima, verá que o R possui um “nome” para as linhas. É importante ressaltar que este nome NÃO é uma variável da tabela, ou seja, não temos uma coluna com o “nome” do veículo, é por isso que você vê nomes de veículos, mesmo pedindo os valores únicos das marchas. Para maiores informações sobre isso, veja a seção Nome de Linhas.\n\n\n\n\n3.4.1.3 slice\nSeleciona linhas pelas suas respectivas posições nda tabela.\nslice(.data, …, .preserve = FALSE)\nPor exemplo, para selecionarmos apenas da linha 10 até a linha 15 da tabela usamos:\n\n mtcars |> \n   slice(10:15) \n\n\n\n  \n\n\n\nVeja que em alguns casos, podemos utilizar um equivalente filtro para obter o mesmo resultado:\n\nmtcars |> \n  filter(between(row_number(), 10, 15)) \n\n\n\n  \n\n\n\n\n\n3.4.1.4 slice_sample\nPara randomicamente selecionar linhas da tabela. Use n para selecionar o número de linhas ou prop para selecionar um percentual das linhas.\nslice_sample(.data, …, n, prop, weight_by = NULL, replace = FALSE) .\nPara selecionar 5 linhas randomicas da tabela usamos:\n\nmtcars |> \n  slice_sample(n = 5, replace = TRUE) \n\n\n\n  \n\n\n\nPara selecionar 25% do total de linhas da tabela de forma dandomica usamos:\n\nmtcars |> \n  slice_sample(prop = 0.25, replace = TRUE) \n\n\n\n  \n\n\n\n\n\n3.4.1.5 slice_min\nSeleciona linhas com valores minímo (slice_min) ou máximo (slice_max) de uma variável.\nslice_min(.data, order_by, …, n, prop, with_ties = TRUE) and slice_max() .\nPor exemplo, com base no menor valor da variável de consumo do veículo (mpg), retorne 25% da tabela.\n\nmtcars |> \n  slice_min(mpg, prop = 0.25) \n\n\n\n  \n\n\n\nOutro exemplo, poderia ser que você precise retornar os 5 veículos de maior consumo:\n\nmtcars |> \n  slice_max(mpg, n = 5) \n\n\n\n  \n\n\n\n\n\n3.4.1.6 slice_head\nSeleciona as primeiras (slice_head) or últimas (slide_tail) linhas de uma tabela.\nslice_head(.data, …, n, prop) and slice_tail() .\nPor exemplo, vamos selecionar as 5 primeiras linhas de mtcars:\n\n\n\n\n\n\nNota\n\n\n\nApenas para exemplificar, no código abaixo, deixamos a função gt “mostrar” os nomes das linhas em sua saída. Para maiores informações sobre isso, veja a seção Nome de Linhas.\n\n\n\nmtcars |> \n  slice_head(n = 5) |> \n  gt(rownames_to_stub = TRUE)\n\n\n\n\n\n  \n  \n    \n      \n      mpg\n      cyl\n      disp\n      hp\n      drat\n      wt\n      qsec\n      vs\n      am\n      gear\n      carb\n    \n  \n  \n    Mazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n    Mazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n    Datsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n    Hornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n    Hornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n  \n  \n  \n\n\n\n\n\n\n\n3.4.2 Arranjar Observações\n\n3.4.2.1 arrange\nA função arrange ordena linhas por valores de uma coluna(s) (menor para maior), use com a função desc() para ordenar de maior para menor.\narrange(.data, …, .by_group = FALSE) arrange(mtcars, mpg) ou arrange(mtcars, desc(mpg))\nNo exemplo abaixo, vamos ordenar a variável mpg, de forma a mostrar primeiro os veículos com menor consumo de combustível até o de maior consumo:\n\nmtcars |> \n  arrange(mpg) |> \n  gt(rownames_to_stub = TRUE)\n\n\n\n\n\n  \n  \n    \n      \n      mpg\n      cyl\n      disp\n      hp\n      drat\n      wt\n      qsec\n      vs\n      am\n      gear\n      carb\n    \n  \n  \n    Cadillac Fleetwood\n10.4\n8\n472.0\n205\n2.93\n5.250\n17.98\n0\n0\n3\n4\n    Lincoln Continental\n10.4\n8\n460.0\n215\n3.00\n5.424\n17.82\n0\n0\n3\n4\n    Camaro Z28\n13.3\n8\n350.0\n245\n3.73\n3.840\n15.41\n0\n0\n3\n4\n    Duster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n    Chrysler Imperial\n14.7\n8\n440.0\n230\n3.23\n5.345\n17.42\n0\n0\n3\n4\n    Maserati Bora\n15.0\n8\n301.0\n335\n3.54\n3.570\n14.60\n0\n1\n5\n8\n    Merc 450SLC\n15.2\n8\n275.8\n180\n3.07\n3.780\n18.00\n0\n0\n3\n3\n    AMC Javelin\n15.2\n8\n304.0\n150\n3.15\n3.435\n17.30\n0\n0\n3\n2\n    Dodge Challenger\n15.5\n8\n318.0\n150\n2.76\n3.520\n16.87\n0\n0\n3\n2\n    Ford Pantera L\n15.8\n8\n351.0\n264\n4.22\n3.170\n14.50\n0\n1\n5\n4\n    Merc 450SE\n16.4\n8\n275.8\n180\n3.07\n4.070\n17.40\n0\n0\n3\n3\n    Merc 450SL\n17.3\n8\n275.8\n180\n3.07\n3.730\n17.60\n0\n0\n3\n3\n    Merc 280C\n17.8\n6\n167.6\n123\n3.92\n3.440\n18.90\n1\n0\n4\n4\n    Valiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n    Hornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n    Merc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n    Pontiac Firebird\n19.2\n8\n400.0\n175\n3.08\n3.845\n17.05\n0\n0\n3\n2\n    Ferrari Dino\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n    Mazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n    Mazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n    Hornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n    Volvo 142E\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2\n    Toyota Corona\n21.5\n4\n120.1\n97\n3.70\n2.465\n20.01\n1\n0\n3\n1\n    Datsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n    Merc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n    Merc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n    Porsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.70\n0\n1\n5\n2\n    Fiat X1-9\n27.3\n4\n79.0\n66\n4.08\n1.935\n18.90\n1\n1\n4\n1\n    Honda Civic\n30.4\n4\n75.7\n52\n4.93\n1.615\n18.52\n1\n1\n4\n2\n    Lotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n    Fiat 128\n32.4\n4\n78.7\n66\n4.08\n2.200\n19.47\n1\n1\n4\n1\n    Toyota Corolla\n33.9\n4\n71.1\n65\n4.22\n1.835\n19.90\n1\n1\n4\n1\n  \n  \n  \n\n\n\n\n\n\n\n3.4.3 Adicionar Observações\nAlgumas vezes precisamos adicionar observações (linhas) em uma tabela já existente, neste caso podemos utilizar a função add_row().\n\n3.4.3.1 add_row\nadd_row(cars, speed = 1, dist = 1).\nNeste caso, iremos adicionar uma nova linha na tables cars (não mtcars), que possui apenas duas variáveis (speed e dist).\n\ncars |> \n  add_row(speed = 1, dist = 1) |> \n  tail()"
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#manipulando-variáveis",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#manipulando-variáveis",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.5 Manipulando Variáveis",
    "text": "3.5 Manipulando Variáveis\n\n3.5.1 Extração de Variáveis\nO dplyr possui uma série de funções que nos ajudam a obter um conjunto de variáveis (colunas) como um novo vetor ou nova tabela:\n\n3.5.1.1 pull\nExtrai valores da coluna como um vetor, por nome ou índice.\npull(.data, var = -1, name = NULL, …)\n\nmtcars |> \n  pull (wt) \n\n [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070\n[13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840\n[25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780\n\n\nNo exemplo acima, a coluna peso (wt), é extraída da tabela e um obeto do tipo vetor é retornado na saída.\nPodemos extrair um vator de uma colunas também utilizando o número da coluna. Se utilizarmos valores negativos, podemos extrair um vetor das colunas contando a partir do lado direto.\nPor exemplo, se quisermos extratir um vetor da penúltima coluna de uma tabela, podemos usar:\n\nmtcars |> \n  pull (-2)\n\n [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4\n\n\n\n\n3.5.1.2 select\nExtrai valores de uma ou mais variáveis (colunas) e retorna uma nova tabela, por nome ou índice.\nselect(.data, …)\nPor exemplo, podemos obter uma nova tabela contendo apenas as variáveis mpg e wt usando:\n\nmtcars |> \n  select (mpg, wt) \n\n\n\n  \n\n\n\nA função select possui um série de opções que tornam a seleção das counas mais fáceis. A seguir temos algumas delas. Consulte a ajuda do select usando “?select” para obter a lista completa.\n\n: para selecionar um range consecutivo de colunas\n! para pegar o complemento de uma conjunto de colunas\n& e | para selecionar a intersecção ou união (E OU) de um conjunto de colunas\nc() para combinar seleções\n\nAlém disso, possui também algumas funções que ajudam na seleção como:\n\neveything(), last_col(), starts_with(), ends_with(), contains(), matches(), num_range()\n\nPor exemplo, se quisermos selecionar toda a base mtcars, exceto as colunas wt e mpg, podemos usar:\n\nmtcars |> \n  select(!c(mpg, wt)) \n\n\n\n  \n\n\n\nSe quisermos selecionar apenas as 4 primeiras colunas e também a coluna wt, podemos usar:\n\nmtcars |> \n  select ((1:4) | wt) \n\n\n\n  \n\n\n\n\n\n3.5.1.3 relocate\nMove colunas para uma nova posição e retonar uma tabela com esta nova order de colunas.\nrelocate(.data, …, .before = NULL, .after = NULL)\n\nmtcars |> \n  relocate (mpg, cyl, .after = last_col()) \n\n\n\n  \n\n\n\nNo exemplo acima, escolhermos mover as colunas mpg e cyl para depois (à direita) da última coluna (last_col()).\n\n\n\n3.5.2 Manipular Várias Variáveis de Uma Vez\nEm algumas situações, desejamos manipular várias variáveis (colunas) de uma só vez ou invés de cada coluna de cada vez. Para estes casos ,podemos usar as funções across e c_across.\n\n3.5.2.1 across\nResume ou alterar múltiplas colunas da mesma maneira. across(.cols, .funs, …, .names = NULL)\n\nmtcars |> \n  summarise(across(everything(), mean)) \n\n\n\n  \n\n\n\nNo exemplo acima, varremos todas (everything) as colunas da tabela e resumimos aplicando a função de média (mean) nestas colunas.\nNo exemplo a seguir, iremos “varrer” as colunas 5 até 7 e arredondar seus valores com apenas um digito usando a função round().\n\nmtcars |> \n  mutate(across(5:7, ~ round(.x, digits = 1) )) \n\n\n\n  \n\n\n\n\n\n3.5.2.2 c_across\nComputa através das colunas os dados linha a linha. Em geral, esta função é utilizado em conjunto com a função rowwise().\nc_across(.cols)\n\nmtcars |> \n  rowwise() |> \n  transmute (total = sum(c_across(4:6)))\n\n\n\n  \n\n\n\nNo exemplo acima, “varremos” linha a linha da tabela e depois fazemos a soma da coluna 4 até a coluna 6.\n\n\n\n3.5.3 Criando novas variáveis\nO dyplr possui a habilidade de criar novas variáveis (colunas) ou alterar variáveis já existentes. Estes comandos, aplicam funções que são de um tipo especial chamadas “funções vetorizadas. Elas recebem vetores como entradas e retornam vetores do mesmo tamanho como. Para maiores detalhes veja a seção Funções Vetorizadas.\n\n3.5.3.1 mutate\nAltera ou cria uma nova variável.\nmutate(.data, …, .keep = “all”, .before = NULL, .after = NULL).\nPor exemplo, se quisermos utilizar a variável mpg (milhas por galão) e criar uma nova variável chamada gpm (galões por milha), usamos:\n\nmtcars |> \n  mutate (gpm = 1 / mpg) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nÉ importante observar que a função mutate() considera o agrupamento da tabela, caso houver. Em casos de funções de agregação e ranqueamento (ex. média, ranque, etc), os valores de mutate serão considerados a partir do agrupamento.\n\n\nPor exemplo, para criar uma coluna que mostra a diferença entre o consumo do veículo e o consumo médio de todos os veículos, podemos usar:\n\nmtcars |> \n  mutate (diferenca = mpg - mean(mpg)) \n\n\n\n  \n\n\n\nMas se quisermos saber a diferença de consumo com a média dos veículos que possuem o mesmo número de cilindros, podemos fazer:\n\nmtcars |> \n  group_by(cyl) |> \n  mutate (diferenca = mpg - mean(mpg)) \n\n\n\n  \n\n\n\n*Veja também add_column(), add_count(), e add_tally().\n\n\n3.5.3.2 transmutate\nA função transmutate funciona de forma similar a função mutate, porém ela cria/altera uma ou mais colunas e ignora todas as demais em suas saída.\n\n\n3.5.3.3 rename\nRenomeia variáveis (colunas).\nHá também a função rename_with() para chamar uma função para renomear a coluna.\nA função rename(.data, …)\n\ncars |> \n  rename (distancia = dist) |> \n  head ()"
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#funções-vetorizadas",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#funções-vetorizadas",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.6 Funções Vetorizadas",
    "text": "3.6 Funções Vetorizadas\nAs funções mutate() e transmute() aplicam funções vetorizadas em colunas para criar novas colunas.\n\n\n\n\n\n\nNota\n\n\n\nFunções vetorizadas, são chamadas também de funções de janela (window functions) e recebem vetores como argumento de entrada e retornar vetores de mesmo tamanho como saída.\n\n\nA seguir temos algumas funções vetorizadas que auxiliam na manipulação de dados e, em geral, são utilizadas com mutate() ou filter().\n\n3.6.1 Deslocamento\nO dplyr possui funções para ajuste de deslocamento (offset). Estas funções são muito úteis para “encontrar” valores antes ou depois em relação aos valores atuais.\n\n3.6.1.1 lag\nDesloca elementos em n posições positivas. Usado para “encontrar o valor anterior em n posições”.\nSupondo que precisarmos criar uma coluna contendo o consumo do veiculo que aparece na linha anterior da tabela, podemos fazer:\n\nmtcars |> \n  mutate (mpg_anterior = lag(mpg)) \n\n\n\n  \n\n\n\nCaso os dados não estejam ordenados,\n\n\n3.6.1.2 lead\nDesloca elementos em n posições negativas. Usado para “encontrar o valor posterior em n posições”.\nSupondo que precisarmos criar uma coluna contendo o consumo do veiculo que aparece duas linhas posteriores da tabela, podemos fazer:\n\nmtcars |> \n  mutate (duas_linhas_posteriores = lead(mpg, n = 2))\n\n\n\n  \n\n\n\n\n\n\n3.6.2 Agregação Acumulada\nO dplyr possui funções de agregações acumuladas. São versões vetorizadas de all, any e mean, enquanto outras são de soma e produtos acumulados e extremos (min/max).\n\n\n\n\n\n\nDica\n\n\n\nAs funções cumall() e cumany() são muito úteis quando usadas com filter(), pois avaliam uma expressão retornando um vetor lógico a partir do valor avaliado pela expressão:\n\n\n\n3.6.2.1 cumall\nRetorna todas as observações (linhas) até que o primeiro caso da expressão a ser avaliada seja falso.\nNo exemplo a seguir, iremos retornar todos os veículos até que encontre um veículo onde sua potência (hp) seja maior ou igual à 110. Quando encontrar esta linha, todas as demais à partir dela na tabela serão ignoradas, mesmo que atendam a expressão. Ou seja, mesmo que houver um veículo com potencia 110 na última linha, nexte exemplo ela será ignorada.\n\nmtcars |> \n  filter(cumall(hp <= 110)) \n\n\n\n  \n\n\n\nSe quisermos ’varrer” a tabela até encontrarmos um veículo que tenha a potência (hp) menor que 90 e ignorar todas as linhas depois dela, podemos usar:\n\nmtcars |> \n  filter(cumall(!hp <= 90)) \n\n\n\n  \n\n\n\n\n\n3.6.2.2 cumany\nRetorna todas as observações (linhas) após o primeiro caso da expressão a ser avaliada seja verdadeiro.\nPor exemplo: Se quisermos “varrer” a tabela em busca do veículo com potência menor que 70 e obter esta e todas as demais linhas após, usamos:\n\nmtcars |> \n  filter (cumany(hp <70))\n\n\n\n  \n\n\n\n\n\n3.6.2.3 cummean\nA função cummean() é similar a função cumall ou cumany, porém retorna um vetor numérico contento as médias do vetor de entrada.\nPor exemplo, se quisermos criar uma coluna com o valor da média de potência conforme “varremos” a tabela, ou seja, conforme a potência de cada veículo é listada, usamos:\n\nmtcars |> \n  mutate (media_acumulada = cummean(hp)) \n\n\n\n  \n\n\n\n\n\n3.6.2.4 cummax\nUse para saber o valor máximo acumulado até aquela linha.\nPor exemplo, se agruparmos os veículos de mtcars de acordo com a coluna de número de cilindros (cyl), podemos saber qual o maior valor acumulado da coluna potência (hp) por grupo de veículos conforme “varremos” a tabela:\n\nmtcars |> \n  group_by(cyl) |> \n  mutate (cummax = cummax(hp)) \n\n\n\n  \n\n\n\n\n\n3.6.2.5 cummin\nUse para saber o valor mínimo acumulado até aquela linha.\nPor exemplo, se agruparmos os veículos de mtcars de acordo com a coluna de número de cilindros (cyl), podemos saber qual o menor valor acumulado da coluna potência (hp) por grupo de veículos conforme “varremos” a tabela:\n\nmtcars |> \n  group_by(cyl) |> \n  mutate (cummin = cummin (hp)) \n\n\n\n  \n\n\n\n\n\n3.6.2.6 cumprod\nSimilar a cummin() ou cummax(). Use para saber o valor multiplicado acumulado até aquela linha.\nPor exemplo, para acumularmos a multiplicação dos pesos (wt) de cada veículo até a linha, usamos:\n\nmtcars |> \n  mutate (cumprod = cumprod (wt)) \n\n\n\n  \n\n\n\n\n\n3.6.2.7 cumsum\nSimilar a cummin() ou cummax(). Use para saber o valor da soma acumulada até aquela linha.\nPor exemplo, para acumularmos a soma dos pesos (wt) de cada veículo até a linha, usamos:\n\nmtcars |> \n  mutate (cumsum = cumsum(wt))\n\n\n\n  \n\n\n\n\n\n\n3.6.3 Ranqueamento\n\n3.6.3.1 row_number\nUse para adicionar o número da linha. Como as demais funções do dplyr, ela respeita os grupos da tabela quando houver.\nPor exemplo, para enumerar as linhas dos veículos agrupados por número de cilindros, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  mutate (num_linha = row_number())\n\n\n\n  \n\n\n\n\n\n3.6.3.2 rank\nUse para criar um ranqueamento de uma variável.\nPor exemplo, para fazer um ranqueamento dos veículos mais leves entre grupos de mesma cilindragem, podemos usar:\n\nmtcars |> \n  group_by (cyl) |> \n  mutate (rank = rank(wt)) \n\n\n\n  \n\n\n\nObserve que para veículos de 8 cilindros, a segunda e última linha possuem o mesmo peso e portanto tiveram o mesmo ranqueamento (5.5).\n\n\n3.6.3.3 dense_rank\nUse para ajustar o ranqueamento sem pular lacunas em casos de empate.\nVejo abaixo como ele se compara ao ranqueamento da função rank().\n\nmtcars |> \n  group_by (cyl) |> \n  mutate (rank = rank(wt), dense_rank = dense_rank(wt)) \n\n\n\n  \n\n\n\nObserve que na segunda e última linha de 8 cilindros, empatam em 5.5 na função rank() e a posição 6 é pulada, sendo o próximo do ranqueamento o número 7. Já na função dense_rank(), o empate fica na posição 5 e o próximo na posição 6.\n\n\n3.6.3.4 percent_rank\nUse para retornar um número entre 0 e 1 (percentual) do ranqueamento mínimo.\nVeja abaixo como ela se compara com as funções rank e dense_rank:\n\nmtcars |> \n  group_by (cyl) |> \n  mutate (rank = rank(wt), dense_rank = dense_rank(wt), percent_rank = percent_rank(wt)) \n\n\n\n  \n\n\n\n\n\n3.6.3.5 cume_dist\nUse para saber a distribuição acumulada de acordo com o ranqueamento atribuído.\nPor exemplo, se agruparmos por número de cilindros (cyl), criarmos uma coluna de ranqueamento (rank) e outra coluna com a distribuição, podemos saber como o ranqueamento acumulado está distribuído.\n\nmtcars |> \n  group_by(cyl) |> \n  mutate (rank = rank(wt), cume_dist = cume_dist(wt)) |> \n  arrange (cume_dist)\n\n\n\n  \n\n\n\n\n\n3.6.3.6 ntile\nUse para retornar um quantil (percentil, quartil, etc) de um vetor.\nPor exemplo, para segregarmos os veículos em quartis (quatro partes) (0-0.25-.50-.75-1), podemos usar:\n\nmtcars |> \n  mutate (quartil = ntile(wt, 4))\n\n\n\n  \n\n\n\n\n\n\n3.6.4 Matemática\n\n3.6.4.1 operações e logs:\nSão símbolos para funções matemáticas mais comuns como:\n+, - , *, /, ^, %/%, %% - Usados para as oper. aritiméticas\nlog(), log2(), log10() - Usados para logaritmos\n\n\n3.6.4.2 between\nUse para retornar os valores do vetor entre dois valores. É o equivalente a escrever: x >= valor_esquerda & x <= valor_direita.\nPor exemplo, se quisermos obter os veículos com o peso entre 3 a 4 mil libras, podemos usar a função between() juntamente com a função filter().\n\nmtcars |>\n  filter (between(wt, 3, 4)) \n\n\n\n  \n\n\n\n\n\n3.6.4.3 near\nUse para verificar se dois vetores de ponto fultuante são iguais:\nO exemplo abaixo, duplica a coluna de peso (wt –> wt2) dos veículos e altera o primeiro valor de 2.620 para 2.600, salvando em um novo data frame (mtcars_novo) que será usado em seguida;\n\nmtcars_novo <- mtcars |> \n  mutate(wt2 = wt) |> \n  mutate (wt2 = ifelse(row_number() == 1, 2.600, wt2))\n\nSe usarmos o igual ( == ) para validar ambas colunas, devido às diferenças nas casa decimais, teríamos FALSO:\n\nmtcars_novo$wt == mtcars_novo$wt2\n\n [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nSe usarmos a função near, por esta ter um parâmetro de tolerância que iremos definiar como acima de 0.020 (0.021 por exemplo), teríamos VERDADEIRO para todos os items do vetor:\n\nnear (mtcars_novo$wt, mtcars_novo$wt2, tol = 0.021)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE\n\n\n\n\n\n3.6.5 Miscelânea\n\n3.6.5.1 if_else\nUse para fazer um “SE” (IF) vetorizado, ou seja, elemento por elemento.\nPor exemplo, se quisermos saber quais veículos percorrem 1/4 de milha em menos de 20 segundos, podemos usar a coluna qsec com a função if_else para criar uma nova coluna marcando como “MAIX VELOZ” os veículos que percorrem com menos de 20 segundos e “MENOS VELOZ” os que não atendem a este critério:\n\nmtcars |> \n  mutate (categoria_arranque = \n            ifelse(qsec < 20, \"MAIS VELOZ\", \"MENOS VELOZ\")) \n\n\n\n  \n\n\n\n\n\n3.6.5.2 case_when\nUse quando quiser fazer um if_else com mais de dois casos, ou seja, ao invés de aninhá-los(nested if).\nUsando o mesmo exemplo da função if_else , porém gostaríamos de criar um terceira classificação chamada de “SUPER VELOZ” para os veículos com tempo abaixo de 16 segundos, teríamos:\n\nmtcars |> \n  mutate (categoria_arranque = case_when(\n    qsec < 17 ~ \"SUPER VELOZ\",\n    qsec < 20 ~ \"MAIS VELOZ\", \n    TRUE ~ \"MENOS VELOZ\")) \n\n\n\n  \n\n\n\nA função case_when, também permite que você utilize diferentes colunas, e operações lógicas também.\nPor exemplo, se quisermos colocar a categoria “INVÁLIDO” para os veículos com 8 cilindros (cyl) OU consumo acima de 30 galões/milha (mpg), usamos:\n\nmtcars |> \n  mutate (categoria_arranque = \n            case_when(\n              cyl == 8 | mpg > 30 ~ \"INVALIDO\",\n              qsec < 17 ~ \"SUPER VELOZ\",\n              qsec < 20 ~ \"MAIS VELOZ\",\n              TRUE ~ \"MENOS VELOZ\")) \n\n\n\n  \n\n\n\n\n\n3.6.5.3 coalesce\nUse para sobrescrever os valores de NA em um vetor.\nO exemplo abaixo, sobrescreve com zeros os valores faltantes (missing) do vetor x:\n\nx <- sample(c(1:5, NA, NA, NA))\ncoalesce(x, 0L)\n\n[1] 3 0 1 0 5 0 4 2\n\n\n\n\n\n\n\n\nDica\n\n\n\nUse na_if() para sobrescrever um valor específico com NA e tidyr::replace_na() para sobrescrever os NAs com um valor.\n\n\n\n\n3.6.5.4 na_if\nUse para sobrescrever um valor específico com NA.\nPor exemplo, se quisermos colocar NAs na coluna de consumo (mpg) para os veículos com 8 cilindros (cyl), podemos usar a na_if() juntamente com a mutate():\n\nmtcars |> \n  mutate(mpg = na_if(cyl, 8)) \n\n\n\n  \n\n\n\n\n\n3.6.5.5 pmax - max\nUse max() para retornar o máximo valor de um vetor ou pmax() para retornar o valor máximo entre elementos de vetores em paralelo.\nPor exemplo, se tiver um vetor dois vetores (x e y) com 5 elementos cada, a função max() irá retornar o maior vetor contido no vetor escolhido:\n\nx <- c(1, 2, 3, 4, 5)\ny <- c(1, 2, 10, 1, 20)\nmax(x)\n\n[1] 5\n\nmax(y)\n\n[1] 20\n\n\nJá se usarmos o pmax(), ele irá comparar cada elemento de x com seu respectivo elemento de y e retornar o máximo valor.\n\nx <- c(1, 2, 3, 4, 5)\ny <- c(1, 1, 10, 1, 20)\npmax(x, y)\n\n[1]  1  2 10  4 20\n\n\n\n\n3.6.5.6 pmin - min\nÉ idêntico às funções pmax - max (), porém ao invés de retornar o valor máximo ou o máximo do elemento em paralelo, estas funções retornam seus respectivos valores mínimos."
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#funções-de-resumo",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#funções-de-resumo",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.7 Funções de Resumo",
    "text": "3.7 Funções de Resumo\nsummarise() aplica funções de resumo em colunas para criar uma nova tabela. Funções de resumo recebem vetores como entrada e retornam um valor único na saída.\n\n\n\n\n\n\nCuidado\n\n\n\nEstas funções retornam informações sobre o grupo ou variável corrente, portanto só funcionam dentro de um contexto específico como summarise() ou mutate().\n\n\n\n3.7.1 Contagem\n\n3.7.1.1 n\nUse para retornar o tamanhio do grupo corrente.\nPor exemplo, para contar quantos veículos temos em cada grupo de cilindors, podemos usar a summarise() com o n() depois de agrupar pela coluna de cilindors (cyl).\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(numero_veículos = n()) \n\n\n\n  \n\n\n\n\n\n3.7.1.2 \n\n\n3.7.1.3 n_distinct\nUse para contar os valores unicos em um vetor.\nPor exemplo, para saber QUANTAS categorias de cilindros temos na tabela mtcars, podemos usar:\n\nmtcars |> \n  summarise (cat_cilindros = n_distinct(cyl)) \n\n\n\n  \n\n\n\nSe quisessemos saber QUAIS categoris de cilindros temos, podemos fazer usando a distinct:\nmtcars |> unique (cyl) ### Posição\n\nmtcars |>\n  distinct(cyl) \n\n\n\n  \n\n\n\n\n\n3.7.1.4 sum\nUse para retornar a soma de todos os valores presentes em seu argumento.\nPor exemplo, para sabermos a soma dos pesos (wt) dos veículos agrupados pelo número de cilindros (cyl), podemos usar a função sum, juntamente com o summarise() e group_by().\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(soma_pesos = sum(wt)) \n\n\n\n  \n\n\n\nVeja que se houver NA na variável (coluna), a função sum irá retornar NA. Para ignorar os NAs e fazer a soma, use o argumento na.rm = TRUE.\n\n\n\n3.7.2 Posição\n\n3.7.2.1 mean\nUse para obter a média dos elementos do vetor. Por exemplo, se quisermos saber a média de peso de todos os veículos, podemos usar:\n\nmtcars |> \n  summarise (media_peso =mean(wt)) \n\n\n\n  \n\n\n\n\n\n3.7.2.2 median\nUse para obter a mediana dos elementos de um vetor. è similar à função mean, porém retorna a mediana ou invés da média.\n\n\n\n3.7.3 Ordem\n\n3.7.3.1 first\nUse para obter o primeiro elemento de um vetor.\nPor exemplo, se quisermos obter o peso do primeiro veículo de cada grupo de cilindros, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(primeiro_veiculo_do_grupo = first(wt)) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nUsando o parametro order_by = , podemos passar um vetor para determinar uma ordem.\n\n\nPor exemplo, se criarmos um agrupamento pelo numero de cilindros e criarmos um ranqueamento pelo consumo do veículo, podemos obter o peso do veículo de menor consumo usando:\n\nmtcars |> \n  group_by(cyl) |> \n  mutate (rank_peso = rank(mpg)) |> \n  summarise(primeiro_veiculo_ordenado_pelo_cosumo = \n      first(wt, order_by = rank_peso)) \n\n\n\n  \n\n\n\n\n\n3.7.3.2 last\nUse para obter o último elemento. É similar a função first, porém ao invés de retornar o primeiro elemento, irá retornar o último.\n\n\n3.7.3.3 nth\nUse para obter o n-ésimo elemento. É similar a função first, porém ao invés de retornar o primeiro elemento, irá retornar o n-ésimo elemento.\nPor exemplo, se quisermos obter o peso do segundo veículo de cada grupo de cilindros, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(segundo_veiculo_do_grupo = nth(wt,2)) \n\n\n\n  \n\n\n\nUse valor negativo para contar a partir do último elemento.\nPor exemplo, se quisermos obter o peso do penúltimo veículo de cada grupo de cilindros, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(penultimo_veiculo_do_grupo = nth(wt,-2)) \n\n\n\n  \n\n\n\n\n\n\n3.7.4 Ranqueamento\n\n3.7.4.1 quantile\nUse para obter os quantils de um vetor. Por padrão retorna os quartis (0, 0.25, .5, .75 e 1) de um vetor.\nPor exemplo, se quisermos saber os quartis dos pesos dos grupos de cilindors dos veículos, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(q = quantile(mpg)) |> \n  ungroup() \n\n\n\n  \n\n\n\nUsando o parâmeto probs = , podemos definir quanquer quantil.\nPor exemplo, se quisermos obter apenas o segundo (média) quartil e o último (valor máximo) do cosumo de grupo de cilindors dos veículos, podemos usar:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(q = quantile(mpg, probs = c(.5, 1))) |> \n  ungroup()\n\n\n\n  \n\n\n\n\n\n3.7.4.2 min\nUse para obter o valor mínimo. Similar a quantile.\n\n\n3.7.4.3 max\nUse para obter o valor máximo. Similar a quantile.\n\n\n\n3.7.5 Dispersão\nO dyplr possuem algumas funções para avaliar o espalhamento dos dados (dispersão) em torno da média central. Estas funções vem do campo da estatística.\n\n3.7.5.1 var\nUse para calcular a variância dos dados.\nPor exemplo, par calcular a variância total dos pesos (wt) dos veículos de tabela mtcars agrupada pelo número de cilindros (cyl), podemos usa-la junto com a função summarise:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(varianca = var(wt))\n\n\n\n  \n\n\n\nNo exemplo acima, observamos que os veículos com 6cilindros possuem seus pesos mais próximos da média que os veículos com 4 ou 8 cilindros.\n\n\n3.7.5.2 sd\nUse para calcular o desvio padrão. É similar a função var, porém retorna o desvio padrão ao invés da variância.\nUsando o mesmo exemplo da função var, o código ficaria:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(desvio_padrao = sd(wt)) \n\n\n\n  \n\n\n\n\n\n3.7.5.3 IQR\nUse para calcular a distância inter-quartil. É similar a função var, porém retorna o range entre os quartis ao invés da variância.\nUsando o mesmo exemplo da função var, o código ficaria:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(distancia_interquartil = IQR(wt)) \n\n\n\n  \n\n\n\n\n\n3.7.5.4 mad\nUse para calcular a desvio absoluto da mediana. É similar a função var, porém o desvio absoluto da mediana ao invés da variância.\nUsando o mesmo exemplo da função var, o código ficaria:\n\nmtcars |> \n  group_by(cyl) |> \n  summarise(Desv_absolto_mediana = mad(wt))"
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#combinando-tabelas",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#combinando-tabelas",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.8 Combinando Tabelas",
    "text": "3.8 Combinando Tabelas\n\n3.8.1 Juntando Variáveis\nQuando você tem uma ou mais variáveis de um dataframe com o mesmo número de observações de outra(s) variável(eis), você pode uní-las diretamente atraveś da função bind_cols(), porém se o número de observações forem diferentes, é necessário utilizar funções de união transformadoras (mutating joins). Ver a seção Relacionando Dados para maiores detalhes sobre as uniões transformadoras.\n\n3.8.1.1 bind_cols\nUse para unir variáveis de mesmo número de observações.\nPor exemplo, no pacotes datasets, temos um dataframe (tabela), chamado state.names, que possui o nomes de todos os estados dos EUA. Há também o state.abb, que possui uma lista das abreviações dos estados americanos. Se quiser unir ambas variáveis, podemos usar:\n\nbind_cols(state.abb, state.name) \n\n\n\n  \n\n\n\n\n\n\n3.8.2 Relacionando Dados\nQuando temos dois dataframes (tabelas) e queremos adicionar colunas de um à outro, usamos funções chamadas de uniões transformadoras (“mutating joins”). Estas funções transformam um tabela, adicionando coluna(s) de outra tabela de acordo com as linhas baseado em chaves (“keys”) definidas ao usar a função.\nPreprarando as tabelas de Exemplo:\nPara os exemplos a seguir, utilizaremos o dataframe state.x77, que possui 8 variáveis dos estados americanos com expectativa de vida, renda per capita, população, etc. Chamaremos esta tabela de X.\nChamaremos de Y, uma tabela states.abb e state.name, que possui as abreviações e nomes dos estados americanos respectivamente. Iremos unir estas variáveis com a função bind_cols, já que elas possuem o mesmo número de observações.\nPorém para exemplificar casos onde a tabela Y, não possui extamente o mesmo número de observações da tabela X, iremos excluir as abreviações que começam com as letras C, M, I e V. Com isto, nossa table Y final, irá contar apenas 37 observações, enquanto a tabela X irá conter todos os 50 estados americados.\nObserve que ambas as tabelas (X e Y) contém ao menos uma coluna em comum (coluna “Estado”). Esta coluna será utilizada como chave (key) para fazermos as uniões.\nPara criar as tabelas X e Y, usaremos:\n\nX <- state.x77 |> \n  as_tibble() |> \n  bind_cols(state.name) |> \n  rename(\"Estado\" = \"...9\")\nX\n\n\n\n  \n\n\n\n\nY <- bind_cols(state.abb, state.name) |> \n  as_tibble() |> \n  rename(\"Abreviacao\" = \"...1\", \"Estado\" = \"...2\") |> \n  filter(!str_detect(Abreviacao, \"^[CMIV]\"))  \nY\n\n\n\n  \n\n\n\n\n3.8.2.1 left_join\nUse para unir valores iguais de X em Y.\nPor exemplo, usando as tabelas X e Y preparadas no início da seção Relacionando Dados, podemos unir a variável população (population) que está na tabela X na tabela Y.\n\n\n\n\n\n\nImportante\n\n\n\nA coluna que será usada como chave (key) na união e as variáveis que você quer unir devem ser selecionadas (função select()). Se não houver uma seleção explícita, todas as colunas da tabela X serão unídas.\n\n\n\nleft_join(Y, select(X, Estado, Population)) \n\n\n\n  \n\n\n\nVeja que no exemplo acima, foram retornadas apenas 37 observações. Isto porque definimos como tabela “base” a tabela Y. Se fizermos o inverso, ou seja, left_join (X, Y), a saída irá conter todos os 50 registros de X e os que ele encontrar na tabela Y. Os que não forem encontrados de acordo com a chave escolhida (neste caso a coluna Estado), será preenchido com N/A. Veja exemplo abaixo:\n\nleft_join(X, Y, by = \"Estado\") \n\n\n\n  \n\n\n\nAs colunas unidas da tabela Y, são adicionadas ao lado direito da tabela X.\n\n\n\n\n\n\nNota\n\n\n\nSe não for definido o parâmetro “by =”, a função irá automaticamente selecionar todas as colunas com o mesmo nome para definir uma chave. Veja mais detalhes na seção Combinando colunas para uniões.\n\n\n\n\n3.8.2.2 right_join\nUse para unir valores iguais de Y em X. Veja que right_join(Y, X) , é o mesmo que escrever left_join(X, Y). Veja a função left_join para mais informações.\n\n\n3.8.2.3 inner_join\nUse para unir todos os dados de X em Y e retornar somente as linhas em comum.\nPor exemplo, se quisermos obter todas as linhas da tabela X (com 50 registros) unindo-as com as linhas correspondentes em Y (com 37 registros), fazemos:\n\ninner_join(X, Y) \n\n\n\n  \n\n\n\n\n\n3.8.2.4 full_join\nUse para unir os dados de X e Y, mantendo todas as linhas e todas as variáveis.\nPara este exemplo, iremos incluir uma linha (add_row) na tabela Y, que não possui um valores correspondente em X.\n\nY <- add_row(Y, Abreviacao = \"XX\", Estado = \"Estado inexistente\")\nfull_join(X, Y) \n\n\n\n  \n\n\n\nVeja que no exemplo acima, temos agora 51 registros, já que uma linha adicional foi criada com o novo registro de Y que não existia em X.\n\n\n3.8.2.5 Combinando colunas para uniões\nSe não for definido o parâmetro “by =”, a função irá automaticamente selecionar todas as colunas com o mesmo nome para definir uma chave.\nSe usarmos by = vetor, por exemplo, by = c(“Estado”), estamos definindo a chave de maneira explícita. Podemos definir uma chave contendo mais que uma colunas usando c(“coluna1”, “coluna2”), com isto, a união será feita encontrando os valores comuns em ambas as colunas das duas tabelas.\nSe quisermos definir uma chave que não possui o mesmo nome nas duas tabelas, podemos ainda usar o parametro by = c(“coluna de X” = “aa”, “coluna de Y” = “bb”).\nPara exemplificar este caso, vamos renomear a coluna “Estado” da tabela Y para “State” e salvarmos numa tabela Z. Depois iremos usar o parametro by = para definir esta coluna como chave e então podermos efetuar uma união (ex, left_join()).\n\nZ <- rename(Y, State = Estado)\nleft_join (Z, X, by = c(\"State\" = \"Estado\"))  \n\n\n\n  \n\n\nZ\n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nCaso tenhamos colunas com o mesmo nome que não seja a chave, as uniões irão colocar automaticamento um sufixo (.x e .y). Se quiser alterar este sufixo, use o parametro suffix = (ex: suffix c(“Tabela_1”, “Tabela_2”)).\n\n\n\n\n\n3.8.3 Juntando Observações\nQuando tivermos linhas em tabelas diferentes para serem unidas, podemos fazê-lo usndo a função bind_rows(). Em alguns casos, desejamos filtrar linhas de uma tabela, baseada em linhas em comum de outra tabela, para estes casos, iremos usar as uniões de filtro (filtering joins).\n\n\n\n\n\n\nNota\n\n\n\nAs tabelas usadas nos exemplos a seguir são as mesmas utilizadas na seção Relacionando Dados.\n\n\n\n3.8.3.1 bind_rows\nUse para unir observações (linhas) que possuem o mesmo número de colunas.\nPor exemplo, usando as tabelas X e Y preparadas no início da seção Relacionando Dados, podemos criar uma tabela Z, com mais 3 observações e uní-la na tabela Y.\nTabela Z\n\nZ <- tibble(\n  Abreviacao = c(\"01\", \"02\", \"03\"), \n  Estado = c(\"Estado01\", \"Estado02\", \"Estado03\"))\nZ\n\n\n\n  \n\n\n\nAgora, podemos unir as tabela Y com a tabela Z usando bind_rows():\n\nbind_rows(Y, Z)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nObserve que, se tivermos alguma coluna que não é comum entre as tabelas, esta coluna será criada automaticamente. Por exemplo:\n\n\n\nZ <- mutate (Z, Coluna_Extra = c(\"Valor01\", \"Valor02\", \"Valor03\"))\nbind_rows(Y, Z) \n\n\n\n  \n\n\n\n\n\n3.8.3.2 semi_join\nUse para retornar todas as linhas da tabela X que são comuns na tabela Y.\nPor exemplo, para filtrar a tabela Y com apenas os valores presentes na tabela X, usamos:\n\nsemi_join(Y, X) \n\n\n\n  \n\n\n\n\n\n3.8.3.3 anti_join\nUse para retornar todas as linhas da tabela X que são NÃO comuns na tabela Y.\nPor exemplo, para filtrar a tabela Y com apenas os valores NÃO presentes na tabela X, usamos:\n\nanti_join(Y, X)\n\n\n\n  \n\n\n\n\n\n3.8.3.4 nest_join\nUse para retornar todas as linhas e colunas de X em uma nova coluna contendo todos os valores encontrados em Y.\nPor exemplo, para criar uma colunas na tabela Y, contendo os registros encontrados na tabela X que são comuns entre elas, ou seja, que possuem a coluna Estado com valores comuns entre elas:\n\nnest_join(Y, X, by = \"Estado\", name = \"Dados de X\") \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPodemos usar a função tidyr::unnest() para desaninhar a coluna.\n\n\n\n\n3.8.3.5 Operações de Definição\nO pacote generics, possui também algumas funções que ajudam a identificar uniões (union), intersecções (intersect) e diferenças entre dois vetores. Esta funções podem ser úteis para obter estão operações em dois data-frames.\n\n\n3.8.3.6 intersect\nUse para obter a intersecção de dois conjuntos de dados.\nPor exemplo, se quisermos saber quais linhas estão presentes no vetor v (1,2,3,4,5) e w(2,4) , podemos fazer:\n\nv <- c(1:5)\nw <- c(2,4)\n\nintersect(v,w) \n\n[1] 2 4\n\n\n\n\n3.8.3.7 setdiff\nUse para saber quais elementos de v NÃO estão presentes em w.\n\nv <- c(1:5)\nw <- c(2,4)\n\nsetdiff(v,w)\n\n[1] 1 3 5\n\n\n\n\n3.8.3.8 union\nUse para fazer a união de dois conjuntos de dados.\n\nv <- c(1:5)\nw <- c(2,4,\"a\",\"b\")\nunion (v,w)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"a\" \"b\""
  },
  {
    "objectID": "Transformacao/Transformacao_de_dados_com_dplyr.html#nome-de-linhas",
    "href": "Transformacao/Transformacao_de_dados_com_dplyr.html#nome-de-linhas",
    "title": "3  Transformação de Dados com DPLYR",
    "section": "3.9 Nome de Linhas",
    "text": "3.9 Nome de Linhas\nDados organizados (tidy) não usam nomes de linhas (que contém uma variável fora das colunas). Para trabalhar com este nomes, mova para uma coluna.\nPor exemplo, quando usamos a função head() para obter as primeiras linhas da tabela mtcars, obtemos a seguinte resposta:\n\nmtcars |> \n  head()\n\n\n\n  \n\n\n\nObserve que na lista acima, o nome de cada veículo aparece na saída.\nPorém, se pedirmos para mostrar os nomes as variáveis da table usando a função names(), não há nenhuma coluna que comporta o nome dos veículos.\nIsto acontece porque o nomes dos veículos está associado ao nomes das linhas e não a coluna.\n\n3.9.0.1 rownames_to_column\nSe quisermos mover os nomes das linha para uma coluna, usamos a função rownames_to_column do pacote tibble:\n\ntibble::rownames_to_column(mtcars, var = \"Nomes_Veiculos\") \n\n\n\n  \n\n\n\n\n\n3.9.0.2 column_to_rownames\nUse para nomear as linhas de acordo com uma variável já existente. Digamos que esta função faz o oposto da rownames_to_column, pois ao invés de pegar os nomes das linhas e colocar em uma variável, ela pega uma variável e a transforma em nomes para as linha."
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "",
    "text": "A seguir temos vários exemplos de manipulação de strings (cadeia de caracteres) utilizando o pacote STRINGR do R. Para saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=stringr.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\ngt\nhtmlwidgets\n\n\nlibrary (tidyverse)\nlibrary (gt)\nlibrary (htmlwidgets)\n\n\n\n\n\n\n\nNota\n\n\n\nString: O termo string, ou cadeia de caracteres, é uma sequência de caracteres interpretadas como uma constante literal ou até mesmo uma variável.\n\n\nPor exemplo:\n\nminha_string <- \"Isto é uma string\"\nminha_string\n\n[1] \"Isto é uma string\"\n\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência do stringr disponível no site do RStudio.\nPara a maioria dos exemplos utilizaremos as bases de dados fruit (frutas) que será criado a seguir.\n\nFRUIT: Tabela com nome de frutas (em inglês).\n\nfruit <- tibble(name = c(\"Apple\", \"Apricot\", \"Avocado\", \"Banana\", \"Blackberry\", \"Blueberry\", \"Cherry\", \"Coconut\", \"Custard-Apple\", \"Dragonfruit\", \"Fig\", \"Gooseberry\", \"Grapes\", \"Guava\", \"Jackfruit\", \"Java Plum\", \"Kiwifruit\", \"Lime\", \"Mango\", \"MuskMelon\", \"Olives\", \"Orange\", \"Papaya\", \"Peach\", \"Pear\", \"Pineapple\", \"Pomegranate\", \"Strawberry\", \"Tamarind\", \"Watermelon\"))\nfruit \n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nAo final de algum comando, você verá a chamada à função gt(). Isto é apenas para a formatação da tabela de saída e não é necessário para que você entenda os comandos precedentes. Em alguns casos, onde o volume de dados de saída pode ser extenso, usamos também a função head() para mostrar apenas as linhas iniciais. Quando o exemplo possui muitas colunas de saída, eventualmente utilizamos a função select() para selecionar apenas algumas colunas.\nEm alguns casos usaremos funções de manipulação de dados do pacote dplyr, como mutate () ou count().\n\n\n\n\n\n\n\n\nNota\n\n\n\nO termo data-frame descrito ao longo deste texto, é utilizado de forma livre para objetos do tipo data.frame, tibble, entre outros. Pense como se fosse uma tabela de um banco de dados e/ou uma planilha do MS Excel, contendo linhas e colunas. Apesar de não ser rigorosamente igual à uma tabela, muitas vezes usaremos estes termos de forma intercambiável para facilitar o entendimento de iniciantes."
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#detectando-combinações",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#detectando-combinações",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.2 Detectando Combinações",
    "text": "4.2 Detectando Combinações\nO pacote stringr possui uma série de funções para identificar a ocorrência ou não de padrões de caracteres (patterns).\nNa maioria das vezes o mecanismo de interpretação padrão é o de “Expressão Regular” (regex). Isto significa que podemos construir um padrão de caracteres não somente com letras ou números, mas criando expressões que significam uma combinação mais flexivel no padrão de busca. Para maiores informações veja: Expressões Regulares.\n\n4.2.0.1 str_detect\nUse para detectar a presença de um padrão em uma string.\nPor exemplo, para detectar quais frutas tem a letra “a”, podemos usar:\n\nstr_detect(fruit$name, \"a\") \n\n [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[13]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nNo exemplo acima, temos TRUE para todas as linhas que contém a letra “a” e FALSE para aquelas que não tem a letra “a”.\n\n\n\n\n\n\nImportante\n\n\n\nObserve que o R é sensível à letras maiúsculas e minúsculas. Como definimos a letra “a” (minúscula) como nosso padrão de busca, ele não retorna TRUE para palavras como “Apple” que possui a letra “A” maiúscula.\n\n\nSe quisermos criar uma coluna ao lado para facilitar a visualização, podemos usar a função mutate():\n\nfruit |> \n  mutate (Padrao_Encontrado = str_detect(fruit$name, \"a\")) \n\n\n\n  \n\n\n\n\n\n4.2.0.2 str_starts\nUse para determinar se há o padrão definido no início da string.\nPor exemplo, se quisermos identificar quais frutas que começam com o padrão “Bl”, usamos:\n\nfruit |> \n  mutate (Padrao_Encontrado_Inicio = str_starts(fruit$name, \"Bl\")) \n\n\n\n  \n\n\n\nVeja que apenas as frutas “Blackberry” e “Bluberry” retornaram verdadeiro (TRUE).\nÉ comum utilizar a função filter() para filtrar apenas as linhas que retornam verdadeiro (TRUE) nas funções de detecção de padrão com o str_detect, str_starts, etc. Veja o exemplo abaixo:\n\nfruit |> \n  filter (str_starts(name, \"Bl\")) \n\n\n\n  \n\n\n\n\n\n4.2.0.3 str_which\nUse para retornar em qual linha o pdrão foi encontrado.\nPor exemplo, supondo que o padrão sejam as letras “Bl” (B maiúscula e l minúscula), usamos:\n\nstr_which(fruit$name, \"Bl\")\n\n[1] 5 6\n\n\nNeste exemplo, identificamos que os únicos registros que atendem ao padrão “Bl” estão nas linhas 5 e 6 da tabela.\n\n\n4.2.0.4 str_locate\nUse para localizar a posição do padrão na string.\nPor exemplo, se criarmos uma coluna contendo onde, em cada nome de fruta, o padrão de busca “er” é encontrado, usamos:\n\n\nfruit |> \n  mutate (Localização_na_string = str_locate(name, \"er\")) \n\n\n\n  \n\n\n\nA função str_locale retorna NA caso o padrão não seja encontrado na string.\n\n\n\n\n\n\nDica\n\n\n\nAo encontrar o padrão, a str_locale para imediatamente a busca na string. Caso precise encontrar todas as posições que o padrão existir na mesma string, utiliza a str_locale_all().\n\n\n\n\n4.2.0.5 str_count\nUse para identificar o número de vez que o padrão foi encontrado na string.\nPor exemplo, se buscarmos pelo padrão “na”, identificamos que a fruta banana, possui o padrão três vezes, enquanto a fruta pomegranade apenas uma vez.\n\nfruit |> \n  mutate (Vezes_padrao_encontrado = str_count(name, \"na\"))"
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#partes-da-string",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#partes-da-string",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.3 Partes da String",
    "text": "4.3 Partes da String\nO pacote stringr possui uma série de funções que permitem obter partes de uma string baseado em um padrão de busca. Assim como nas funções de detecção, o interpretador padrão é o regex. Para maiores informações veja: Expressões Regulares.\n\n4.3.0.1 str_sub\nUse para extrair ou substituir partes de uma string a partir de um vetor de caracteres.\nPor exemplo, para extrair do segundo até o quarto caractere dos nomes das frutas, usamos:\n\nfruit |> \n  mutate (Segundo_ao_Quarto_Caractere = str_sub(name, 2, 4)) \n\n\n\n  \n\n\n\nSe precisarmos variar o início ou fim da extração de parte da string, podemos passar valores negativos para os parametros start = e/ou end =, fazendo com que a contagem acontece de trás para frente.\n\n\n4.3.0.2 str_subset\nUse para retornar as strings que contém o padrão. É equivalente a fazer str_detect(x, pattern), porém ao invés de retornar verdadeiro ou falso, retorna a string.\n\nstr_subset(fruit$name, \"Bl\")\n\n[1] \"Blackberry\" \"Blueberry\" \n\n\n\n\n4.3.0.3 str_extract\nUse para obter o padrão encontrado na string.\nPor exemplo, queremos obter parte da string que atenda ao padrão “erry”. Neste caso, a função irá retornar NA para as strings que não contém o padrão e o padrão para aquelas que o contém.\n\nfruit |> \n  mutate (Str_Extract = str_extract(name, \"erry\")) \n\n\n\n  \n\n\n\n\n\n4.3.0.4 str_match\nUse para obter os grupos identificados pelo padrão de busca. Ela retorna uma matriz, onde a primeira coluna retorna a combinação (match) toda e as demais colunas será uma para cada grupo identificado.\nPor exemplo, se buscarmos por dois grupos, sendo o primeiro (Ba) e o segundo grupo (na), teremos o seguinte resultado:\n\nstr_match(fruit$name, \"(Ba)(na)\") |> \n  as_tibble(.name_repair = \"unique\")\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nOs detalhes sobre grupos nos padrões de busca faz parte das expressões regulares (regex) e estão mais detalhadas na seção: Expressões Regulares"
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#gerenciando-tamanho",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#gerenciando-tamanho",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.4 Gerenciando Tamanho",
    "text": "4.4 Gerenciando Tamanho\n\n4.4.0.1 str_length\nUse para obter o tamanho da string.\nPor exemplo, para obtermos o tamanho das strings correspondentes aos nomes das frutas e adicioná-las em uma coluna chamada “Tamanho”, podemos fazer:\n\nfruit |> \n  mutate(Tamanho = str_length(name)) \n\n\n\n  \n\n\n\n\n\n4.4.0.2 str_pad\nUse para adicionar espaços em branco ao lado (esquerdo, direito, ambos) da string.\nPor exemplo, para adicionar espaços em branco para ajustar em 20 caracteres os nomes das frutas, usamos:\n\nfruit |> mutate(Tamanho = str_pad(name, 20, \"left\")) |> as.matrix()\n\n      name            Tamanho               \n [1,] \"Apple\"         \"               Apple\"\n [2,] \"Apricot\"       \"             Apricot\"\n [3,] \"Avocado\"       \"             Avocado\"\n [4,] \"Banana\"        \"              Banana\"\n [5,] \"Blackberry\"    \"          Blackberry\"\n [6,] \"Blueberry\"     \"           Blueberry\"\n [7,] \"Cherry\"        \"              Cherry\"\n [8,] \"Coconut\"       \"             Coconut\"\n [9,] \"Custard-Apple\" \"       Custard-Apple\"\n[10,] \"Dragonfruit\"   \"         Dragonfruit\"\n[11,] \"Fig\"           \"                 Fig\"\n[12,] \"Gooseberry\"    \"          Gooseberry\"\n[13,] \"Grapes\"        \"              Grapes\"\n[14,] \"Guava\"         \"               Guava\"\n[15,] \"Jackfruit\"     \"           Jackfruit\"\n[16,] \"Java Plum\"     \"           Java Plum\"\n[17,] \"Kiwifruit\"     \"           Kiwifruit\"\n[18,] \"Lime\"          \"                Lime\"\n[19,] \"Mango\"         \"               Mango\"\n[20,] \"MuskMelon\"     \"           MuskMelon\"\n[21,] \"Olives\"        \"              Olives\"\n[22,] \"Orange\"        \"              Orange\"\n[23,] \"Papaya\"        \"              Papaya\"\n[24,] \"Peach\"         \"               Peach\"\n[25,] \"Pear\"          \"                Pear\"\n[26,] \"Pineapple\"     \"           Pineapple\"\n[27,] \"Pomegranate\"   \"         Pomegranate\"\n[28,] \"Strawberry\"    \"          Strawberry\"\n[29,] \"Tamarind\"      \"            Tamarind\"\n[30,] \"Watermelon\"    \"          Watermelon\"\n\n\n\n\n4.4.0.3 str_trunc\nUse para truncar a string em um número fixo de caracteres.\nPor exemplo, para truncar os nomes das frutas em até 8 caracteres, usamos:\n\nfruit |> mutate(Tamanho = str_trunc(name, 8, \"right\")) |> as.matrix()\n\n      name            Tamanho   \n [1,] \"Apple\"         \"Apple\"   \n [2,] \"Apricot\"       \"Apricot\" \n [3,] \"Avocado\"       \"Avocado\" \n [4,] \"Banana\"        \"Banana\"  \n [5,] \"Blackberry\"    \"Black...\"\n [6,] \"Blueberry\"     \"Blueb...\"\n [7,] \"Cherry\"        \"Cherry\"  \n [8,] \"Coconut\"       \"Coconut\" \n [9,] \"Custard-Apple\" \"Custa...\"\n[10,] \"Dragonfruit\"   \"Drago...\"\n[11,] \"Fig\"           \"Fig\"     \n[12,] \"Gooseberry\"    \"Goose...\"\n[13,] \"Grapes\"        \"Grapes\"  \n[14,] \"Guava\"         \"Guava\"   \n[15,] \"Jackfruit\"     \"Jackf...\"\n[16,] \"Java Plum\"     \"Java ...\"\n[17,] \"Kiwifruit\"     \"Kiwif...\"\n[18,] \"Lime\"          \"Lime\"    \n[19,] \"Mango\"         \"Mango\"   \n[20,] \"MuskMelon\"     \"MuskM...\"\n[21,] \"Olives\"        \"Olives\"  \n[22,] \"Orange\"        \"Orange\"  \n[23,] \"Papaya\"        \"Papaya\"  \n[24,] \"Peach\"         \"Peach\"   \n[25,] \"Pear\"          \"Pear\"    \n[26,] \"Pineapple\"     \"Pinea...\"\n[27,] \"Pomegranate\"   \"Pomeg...\"\n[28,] \"Strawberry\"    \"Straw...\"\n[29,] \"Tamarind\"      \"Tamarind\"\n[30,] \"Watermelon\"    \"Water...\"\n\n\n\n\n\n\n\n\nDica\n\n\n\nObserve que a função adiciona “…” para identificar as strings que tinham mais que o limite definido”. Utilize o parametro ellipsis = “…” para alterar para outros caracteres.\n\n\n\n\n4.4.0.4 str_trim\nUse para remover os espaços em brancos do início em final da string.\n\nstring <- \"  Aqui temos espaços em branco no início e no final   \"\nstr_trim(string)\n\n[1] \"Aqui temos espaços em branco no início e no final\"\n\n\n\n\n4.4.0.5 str_squish\nUse para remover espaços em branco no início e final da string e também espaços em brancos repetidos no meio da string.\n\nstring <- \"  Aqui temos espaços em       branco no início, no final e repetidos no meio   \"\nstr_squish(string)\n\n[1] \"Aqui temos espaços em branco no início, no final e repetidos no meio\""
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#modificando-string",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#modificando-string",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.5 Modificando String",
    "text": "4.5 Modificando String\n\n4.5.0.1 str_sub\nUse para extrair ou substituir partes de uma string a partir de um vetor de caracteres.\nPor exemplo, para substituir do segundo até o quarto caractere dos nomes das frutas, usamos:\n\nminha_string <- \"Esta é minha string\"; minha_string\n\n[1] \"Esta é minha string\"\n\nstr_sub(minha_string, 2, 4) <- \"XXX\"; minha_string\n\n[1] \"EXXX é minha string\"\n\n\n\n\n\n\n\n\nDica\n\n\n\nObserve que a função str_sub não é vetorizada, ou seja, não recebe ou retorna um vetor como parêmetro.\nDesta forma, se quisermos aplicá-la em conjunto com a função mutate(). Uma alternativa para este tipo de situação, é utilziar a função map() do pacote purrr.\n\n\nPor exemplo, vamos criar uma função chamada “substitui_string”. Esta função irá utilizar a função str_sub() de acordo com os parametros recebidos de str_troca, inicio e fim. Utilizando a função purrr::map() iremos iterar através dos nomes das frutas e utilizar a função substitui_string() para trocar por “XX” os caracteres -2 a -3 de todos os nomes em uma coluna ao lado.\n\nsubstitui_string <- function(str_origin, str_troca, inicio, fim){\n  str_sub(str_origin, inicio, fim) <- str_troca\n  return (str_origin)\n}\n\nfruit |> \n  mutate (Segundo_ao_Quarto_Caracteres = purrr::map_chr (name, substitui_string, str_troca = \"XX\", inicio = -3, fim = -2))\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserve que valores negativos para os parametros start = e/ou end =, fazem com que a contagem aconteça de trás para frente.\n\n\n\n\n4.5.0.2 str_replace\nUse para substituir partes de uma string por outra string de acordo com o padrão de busca (ex: regex) definido.\n\n\n\n\n\n\nDica\n\n\n\nPara saber mais sobre o método de expressão regular (regex) veja: Expressões Regulares e para os outros métodos de interpretação, veja Outras Interpretações.\n\n\nPor exemplo, vamos definir inicialmente que nosso padrão de busca são as letras “er”. Agora vamos substituir este padrão pela string ” XX ” colocando em uma coluna ao lado usando a função mutate().\n\nfruit |> \n  mutate (nomes_substituidos = str_replace(name, \"er\", \" XX \")) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nNote que diferente da função str_sub(), a função str_replace() é vetorizada, com isto não precisamos utilizar o purrr:map para retornar um vetor.\n\n\n\n\n4.5.0.3 str_replace_all\nUse para substituir partes de uma string por outra string de acordo com o padrão de busca (ex: regex) definido em TODAS as vezes que o padrão for encontrado.\nPor exemplo, vamos definir inicialmente que nosso padrão de busca são as letras “na”. Agora vamos substituir este padrão pela string ” XX ” colocando em uma coluna ao lado usando a função mutate().\n\nfruit |> \n  mutate (nomes_substituidos = str_replace_all(name, \"an\", \" XX \"))\n\n\n\n  \n\n\n\nNote que se tivessemo utilizado a função str_replace ao invés da str_replace_all, a palavra “Banana” retornaria “Ba XX na”, pois ela substituiria apenas a primeira vez que o padrão fosse encontrado.\n\n\n4.5.0.4 str_to_lower\nUse para colocar a string em letras minúsculas.\n\nfruit |> \n  mutate (tolowe = str_to_lower(name)) \n\n\n\n  \n\n\n\n\n\n4.5.0.5 str_to_upper\nUse para colocar a string em letras maiúsculas.\n\nfruit |> \n  mutate (toupper = str_to_upper(name)) \n\n\n\n  \n\n\n\n\n\n4.5.0.6 str_to_title\nUse para colocar a string com a primeira letra maiúscula e as demais em letras minúsculas de cada palavra.\n\nfruit |> \n  mutate (totitle= str_to_title(name))"
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#juntando-e-dividindo",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#juntando-e-dividindo",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.6 Juntando e Dividindo",
    "text": "4.6 Juntando e Dividindo\n\n4.6.0.1 str_c\nUse para juntar várias strings em uma única string.\nPara exemplificar, vamos criar uma segunda coluna em nossa tabela de frutas.\n\n# Nova coluna com uma string qualquer \ncol_nova <- bind_cols(c(letters, LETTERS), seq(1:52), seq(1:52), c(letters, LETTERS))\ncol_nova <- col_nova |> \n  unite(nova_string, names(col_nova)) |> \n  slice (n = 1:30) \nfrutas <- bind_cols (fruit, col_nova)\n\n#Concatenando ambas colunas\n  frutas |> \n  mutate ( str_c = str_c(name, nova_string)) \n\n\n\n  \n\n\n\n\n\n\n\n\n\nDica\n\n\n\nUse o parametro sep = para definir um caractere de separação quando juntar as strings se desejar.\n\n\n\n\n4.6.0.2 str_flatten\nUse para “achatar” o vetor de string. O parametro collapse = “” pode ser alterado para incluir um caractere específico enquanto ocorre o processo.\nPor exemplo, temos uma string “Bom dia”. Neste caso, temos um vetor de caracteres de tamanho 7 (“B” “o” “m” ” ” “d” “i” “a”). A função flatten irá achatar este vetor e retornar apenas uma string com um único vetor (“Bom dia”).\n\nminha_string <- c(\"B\",\"o\",\"m\",\" \",\"d\",\"i\",\"a\")\nlength (minha_string); minha_string\n\n[1] 7\n\n\n[1] \"B\" \"o\" \"m\" \" \" \"d\" \"i\" \"a\"\n\nminha_string <- str_flatten(minha_string)\nlength (minha_string); minha_string\n\n[1] 1\n\n\n[1] \"Bom dia\"\n\n\n\n\n4.6.0.3 str_dup\nUse para duplicar uma string determinado número de vezes.\n\nfruit |> \n  mutate (str_dup = str_dup(name, 3)) \n\n\n\n  \n\n\n\n\n\n4.6.0.4 str_split_fixed\nUse para “quebrar” um string em partes. A funçao str_split() retorna uma string dividida enquanto a funçao str_split_fixed() retorna uma matriz de caracteres com número fixo de colunas.\nPor exemplo, vamos usar a mesma tabela usada no exemplo da funçao str_c chamada frutas (na fruit). Iremos “quebrar as strings da coluna”nova_string” usando oseparator “_”. Como temos exatamente o mesmo número de sperador em todas as strings, a funções irá nos retornar um vetor de caracteres de tamanho 4.\n\nfrutas |> \n  mutate (str_split = str_split(nova_string, \"_\")) |> \n  pull(str_split)\n\n[[1]]\n[1] \"a\" \"1\" \"1\" \"a\"\n\n[[2]]\n[1] \"b\" \"2\" \"2\" \"b\"\n\n[[3]]\n[1] \"c\" \"3\" \"3\" \"c\"\n\n[[4]]\n[1] \"d\" \"4\" \"4\" \"d\"\n\n[[5]]\n[1] \"e\" \"5\" \"5\" \"e\"\n\n[[6]]\n[1] \"f\" \"6\" \"6\" \"f\"\n\n[[7]]\n[1] \"g\" \"7\" \"7\" \"g\"\n\n[[8]]\n[1] \"h\" \"8\" \"8\" \"h\"\n\n[[9]]\n[1] \"i\" \"9\" \"9\" \"i\"\n\n[[10]]\n[1] \"j\"  \"10\" \"10\" \"j\" \n\n[[11]]\n[1] \"k\"  \"11\" \"11\" \"k\" \n\n[[12]]\n[1] \"l\"  \"12\" \"12\" \"l\" \n\n[[13]]\n[1] \"m\"  \"13\" \"13\" \"m\" \n\n[[14]]\n[1] \"n\"  \"14\" \"14\" \"n\" \n\n[[15]]\n[1] \"o\"  \"15\" \"15\" \"o\" \n\n[[16]]\n[1] \"p\"  \"16\" \"16\" \"p\" \n\n[[17]]\n[1] \"q\"  \"17\" \"17\" \"q\" \n\n[[18]]\n[1] \"r\"  \"18\" \"18\" \"r\" \n\n[[19]]\n[1] \"s\"  \"19\" \"19\" \"s\" \n\n[[20]]\n[1] \"t\"  \"20\" \"20\" \"t\" \n\n[[21]]\n[1] \"u\"  \"21\" \"21\" \"u\" \n\n[[22]]\n[1] \"v\"  \"22\" \"22\" \"v\" \n\n[[23]]\n[1] \"w\"  \"23\" \"23\" \"w\" \n\n[[24]]\n[1] \"x\"  \"24\" \"24\" \"x\" \n\n[[25]]\n[1] \"y\"  \"25\" \"25\" \"y\" \n\n[[26]]\n[1] \"z\"  \"26\" \"26\" \"z\" \n\n[[27]]\n[1] \"A\"  \"27\" \"27\" \"A\" \n\n[[28]]\n[1] \"B\"  \"28\" \"28\" \"B\" \n\n[[29]]\n[1] \"C\"  \"29\" \"29\" \"C\" \n\n[[30]]\n[1] \"D\"  \"30\" \"30\" \"D\" \n\n\nSe quisermos “quebrar” uma string usando um separador e já gerarmos as respectivas colunas em uma tabela, podemos usar a função str_split_fixed(), extrairmos as respectivas matrizes e adicionarmos como colunas na tabela, podemos fazer: .\n\n\n4.6.0.5 str_glue\nUse para interpolar/formatar uma string.\nPor exemplo, se tivermos duas strings: s1 = “Fulano” e s2 = “da Silva”. Podemos “colar” estas strings usando a função str_glue().\n\ns1 <- \"Fulano\"\ns2 <- \"da Silva\"\nstr_glue(\"{s1}\",\" \", \"{s2}\")\n\nFulano da Silva\n\n\nPodemos também juntar strings fixas e variáveis como no exemplo abaixo.\n\ns1 <- \"Fulano\"\ns2 <- \"da Silva\"\nstr_glue(\"Meu nome é {s1}\",\" \", \"{s2}\")\n\nMeu nome é Fulano da Silva\n\n\n\n\n4.6.0.6 str_glue_data\nÉ similar a função str_glue, mas adequada a objetos de dados.\nPor exemplo, vamos juntar o nome das frutas, o nome da linha da tabela que ela está e mais uma string fixa:\n\nfruit |> str_glue_data(\"A {name} é uma fruta.\") \n\nA Apple é uma fruta.\nA Apricot é uma fruta.\nA Avocado é uma fruta.\nA Banana é uma fruta.\nA Blackberry é uma fruta.\nA Blueberry é uma fruta.\nA Cherry é uma fruta.\nA Coconut é uma fruta.\nA Custard-Apple é uma fruta.\nA Dragonfruit é uma fruta.\nA Fig é uma fruta.\nA Gooseberry é uma fruta.\nA Grapes é uma fruta.\nA Guava é uma fruta.\nA Jackfruit é uma fruta.\nA Java Plum é uma fruta.\nA Kiwifruit é uma fruta.\nA Lime é uma fruta.\nA Mango é uma fruta.\nA MuskMelon é uma fruta.\nA Olives é uma fruta.\nA Orange é uma fruta.\nA Papaya é uma fruta.\nA Peach é uma fruta.\nA Pear é uma fruta.\nA Pineapple é uma fruta.\nA Pomegranate é uma fruta.\nA Strawberry é uma fruta.\nA Tamarind é uma fruta.\nA Watermelon é uma fruta."
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#ordenando-string",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#ordenando-string",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.7 Ordenando String",
    "text": "4.7 Ordenando String\n\n4.7.0.1 str_order\nUse para sequenciar um vetor de caracteres.\nPor exemplo, para colocar em sequência de forma decrescente os nomes da frutas, podemos usar:\n\n  str_order(fruit$name, decreasing = TRUE)\n\n [1] 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6\n[26]  5  4  3  2  1\n\n\nO resultado será uma sequência (descrescente) em que cada item do vetor está.\n\n\n4.7.0.2 str_sort\nUse para ordenar um vetor de caracteres.\nPor exemplo, para ordenar de forma decrescente os nomes da frutas, podemos usar:\n\nstr_sort(fruit$name, decreasing = TRUE) |> \n  as_tibble(.name_repair = \"unique\")"
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#auxiliares",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#auxiliares",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.8 Auxiliares",
    "text": "4.8 Auxiliares\n\n4.8.0.1 str_conv\nUse para converter o “encode” de uma string.\n\nx <- rawToChar(as.raw(177))\nx\n\n[1] \"\\xb1\"\n\nstr_conv(x, \"ISO-8859-2\") # Polones a com cedilha\"\n\n[1] \"ą\"\n\nstr_conv(x, \"ISO-8859-1\") # Mais-Menos\n\n[1] \"±\"\n\n\n\n\n4.8.0.2 str_view_all\nUse para ver os valores encontrados na string de acordo com um padrão de busca.\nPor exemplo, se tivermos o padrão de busca como “er”, podemos ver onde na strings ele é encontrado.\n\nstr_view(c(\"Banana\", \"Blueberry\", \"Blackberry\"), \"er\") \n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nA função str_view_all(), mostrará todos os encontros na string, se quiser para a busca do padrão no primeiro encontro, usa str_view().\n\n\n\n\n4.8.0.3 str_wrap\nUse para formatar uma string em parágrafos.\n\nthanks_path <- file.path(R.home(\"doc\"), \"THANKS\")\nthanks <- str_c(readLines(thanks_path), collapse = \"\\n\")\nthanks <- word(thanks, 1, 3, fixed(\"\\n\\n\"))\ncat(str_wrap(thanks, width = 60, indent = 2), \"\\n\")\n\n  R would not be what it is today without the invaluable\nhelp of these people outside of the (former and current)\nR Core team, who contributed by donating code, bug fixes\nand documentation: Valerio Aimale, Suharto Anggono, Thomas\nBaier, Gabe Becker, Henrik Bengtsson, Roger Bivand, Ben\nBolker, David Brahm, G\"oran Brostr\"om, Patrick Burns,\nVince Carey, Saikat DebRoy, Matt Dowle, Brian D'Urso,\nLyndon Drake, Dirk Eddelbuettel, Claus Ekstrom, Sebastian\nFischmeister, John Fox, Paul Gilbert, Yu Gong, Gabor\nGrothendieck, Frank E Harrell Jr, Peter M. Haverty,\nTorsten Hothorn, Robert King, Kjetil Kjernsmo, Roger\nKoenker, Philippe Lambert, Jan de Leeuw, Jim Lindsey,\nPatrick Lindsey, Catherine Loader, Gordon Maclean, Arni\nMagnusson, John Maindonald, David Meyer, Ei-ji Nakama,\nJens Oehlschl\"agel, Steve Oncley, Richard O'Keefe, Hubert\nPalme, Roger D. Peng, Jose' C. Pinheiro, Tony Plate, Anthony\nRossini, Jonathan Rougier, Petr Savicky, Guenther Sawitzki,\nMarc Schwartz, Arun Srinivasan, Detlef Steuer, Bill Simpson,\nGordon Smyth, Adrian Trapletti, Terry Therneau, Rolf Turner,\nBill Venables, Gregory R. Warnes, Andreas Weingessel, Morten\nWelinder, James Wettenhall, Simon Wood, and Achim Zeileis.\nOthers have written code that has been adopted by R and is\nacknowledged in the code files, including"
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#expressões-regulares",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#expressões-regulares",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.9 Expressões Regulares",
    "text": "4.9 Expressões Regulares\nPadrões de buscas são interpretados na funções do pacote stringr como Expressões Regulares (regex). Ou seja, quando uma função possui o parametro pattern =, significa que o interpretador irá entendem como uma expressão regular. Você pode alterar o interpretadores para outros tipos se necessário. Para saber mais sobre isso, acesse Outras Interpretações.\nExpressão Regular é uma sequencia de caracteres que especificam um padrão de busca em uma string.\nNo R, você escreve uma expressão regular como um string, ou seja, uma sequencia de caracteres entre asps simples ’ ou duplas “.\nAlguns caracteres de uma expressão regular não podem ser representados diretamente como uma string no R. Estes são conhecidos como caracteres especiais e são uma sequencia de caracteres que tem um significado específico.\nPor exemplo:\n\n\n\nCaracteres Especiais\nRepresenta\n\n\n\n\n\\\\\n\\\n\n\n\\”\n”\n\n\n\\?\n?\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara obter a lista completa, digite ? “’”.\n\n\nDevido a isto, sempre que aparecer uma barra invertida ( \\ ) em uma expressão regular, você deve digitar duas barras ( \\\\ ) na strings da expressão.\nIsto é uma particularidade do R e outras linguagens isto pode não ser necessário.\nUse a função writeLines() para ver como o R vê sua string depois dos caracteres especiais forem lido.\n\nwriteLines(\"\\\\.\")\n\n\\.\n\n\n\nwriteLines(\"\\\\\")\n\n\\\n\n\nComo exemplo inicial, vamos utilizar a função str_extract() que recebe um string como parametro e também aceita o padrão de busca como outro parametro.\nIremos definir nosso padrão de busca como a letra “a”. Desta forma, se passarmos para a função str_detect a string “Banana” e o padrão “a”, ele deve retornar a letra “a”, pois a string Banana possui a letra “a”.\n\nstr_extract (\"Banana\", \"a\")\n\n[1] \"a\"\n\n\nPor outro lado, se passarmos a string “Fig” com o mesmo padrão de busca, teremos NA como retorno, pois a string “Fig” não possui a letra “a”.\n\nstr_extract (\"Fig\", \"a\")\n\n[1] NA\n\n\n\n4.9.1 Combinando Caracteres\nNo exemplo anterior utilizamos apenas um caractere como padrão de busca, no caso a letra “a”.\nQuando desejamos combinar diversos caracteres (letras, numeros, simbolos, espaços, etc) utilizamos a expressões na tabela abaixo:\nPara facilitar o entendimento, utilizaremos uma string com letras maiúsculas, minúsculas, símbolos e números:\n\nStr_Teste <- \"abc ABC 123\\t.!?\\\\(){}\\n\"\nStr_Teste\n\n[1] \"abc ABC 123\\t.!?\\\\(){}\\n\"\n\n\n\n\n\n\n\n\n\nString Regex no R\nBusca por\n\n\n\n\na\na (etc.)\n\n\n\\\\.\n.\n\n\n\\\\!\n\\!\n\n\n\\\\?\n\\?\n\n\n\\\\\\\\\n\\\\\n\n\n\\\\(\n\\(\n\n\n\\\\)\n\\)\n\n\n\\\\{\n\\{\n\n\n\\\\}\n\\}\n\n\n\\\\n\nnova linha (ENTER)\n\n\n\\\\t\nTAB\n\n\n\\\\s\nqualquer caractere em branco\n\n\n\\\\d\nqualquer digito\n\n\n\\\\w\nqualquer letra\n\n\n\\\\b\nbarra de espaço\n\n\n[:digit:]\ndigitos\n\n\n[:alpha:]\nletras\n\n\n[:lower:]\nletras minúsculas\n\n\n[:upper:]\nletras maiúsculas\n\n\n[:alnum:]\nletras e números\n\n\n[:punct:]\npontuação\n\n\n[:graph:]\nletras, números e pontuação\n\n\n[:space:]\nqualquer espaço em branco\n\n\n[:blank:]\nespaço em branco e barra de espaço (mas não nova linha)\n\n\n.\nqualquer caractere exceto nova linha (ENTER)\n\n\n\nVamos mostrar como usar a tabela acima com alguns exemplos. Para isso, iremos usar a string criada anteriormente chamada “Str_Teste”.\nExemplo 1:\nVamos buscar em nossa string de teste (Str_Teste) a letra minúscula “a”.\nNa coluna da tabela acima chamada String, encontramos oque devemos digitar para construir o padrão de busca. Neste caso, seria “a”.\nSe usarmos a função str_view_all() pssando nossa “Str_Teste” e o padrão de busca “a”, observamos que teremos marcado apenas a letra “a” na string. Isto significa que o padrão de busca foi encontrado na string.\n\nstr_view_all (Str_Teste, \"a\")\n\n\n\n\n\nExemplo 2:\nVamos buscar agora pelo padrão do símbolo de ponto de interrogação “?”. Similar ao exemplo anterior, vemos que apenas o ponto de interrogação foi encontrado.\n\nstr_view_all (Str_Teste, \"\\\\?\")\n\n\n\n\n\nExemplo 3:\nVamos criar agora um padrão que busque por todos os digitos em nossa string.\n\nstr_view_all (Str_Teste, \"\\\\d\")\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara buscarmos pelo inverso do caso anterior, ou seja, todos os caracteres que NÃO são digitos, usamos a letra “D” maiúscula. Isto é válido também para os casos de “\\\\S” e “\\\\W” que seriam o inverso de “\\\\s” e “\\\\w” respectivamente.\n\n\n\nstr_view_all (Str_Teste, \"\\\\D\")\n\n\n\n\n\nExemplo 4:\nVamos criar agora um padrão que busque por todos os digitos e letras em nossa string.\n\nstr_view_all (Str_Teste, \"[:alnum:]\")\n\n\n\n\n\n\n\n4.9.2 Quantificadores\nAgora que já saber como criar padrões de busca para identificar diversos tipos de caracteres, veremos como difinir a quantidade desses caracteres em nosso padrão. Veja a tabela abaixo:\n\n\n\nRegex\nBusca\n\n\n\n\n?\nZero ou um\n\n\n*\nZero ou mais\n\n\n+\nUm ou mais\n\n\n{n}\nExatamente n\n\n\n{n,}\nn ou mais\n\n\n{n,m}\nEntre n e m\n\n\n\nVamos ver como utilizamos estes quantificadores juntamente com os caracteres especiais vistos anteriormente (ver Combinando Caracteres).\nPara os exemplos a seguir utilizaremos a seguinte string de teste: Str_Teste_2 = “.a.aa.aaa”\n\nStr_Teste_2 <- \".a.aa.aaa\"\n\nExemplo 1:\nDigamos que queremos buscar em nossa string de teste “Str_Teste” a letra “a” zero ou uma vez, para isso faremos:\n\nstr_view_all(Str_Teste_2, \"a?\")\n\n\n\n\n\nNeste caso, todas as vezes que a funções encontrar a letra “a” zero ou uma vez, elá irá marcar.\n\n\n\n\n\n\nAviso\n\n\n\nSe usarmos a função str_view() ela irá utilizar o padrão apenas até o primeiro encontro e depois irá para a busca, veja:\n\n\n\nstr_view(Str_Teste_2, \"a?\")\n\n\n\n\n\nObserve que a busca para logo no primeiro caractere, pois estamos buscando pela letra “a” ZERO ou mais vezes.\nExemplo 2:\nAgora vamos iremos buscar pela letra “a” UMA ou mais vezes, porém iremos utilizar a função str_view() ou invés da str_view_all(), parando a busca assim que o primeiro encontro ocorra:\n\nstr_view(Str_Teste_2, \"a+\")\n\n\n\n\n\nExemplo 3:\nNeste exemplo, queremos criar um padrão de busca pela letra “a”, mas que ela ocorra DUAS a TRÊS vezes.\n\nstr_view(Str_Teste_2, \"a{2,3}\")\n\n\n\n\n\nVeja que ele localizou apenas as duas letras “aa” e não marcou as letras “aaa”. Isto é porque utilizamos a função str_view(), que parou a busca assim que a primeiro encontro ocorreu. Se quisermos continuar a busca, devemos utilizar a função str_view_all().\n\nstr_view_all(Str_Teste_2, \"a{2,3}\")\n\n\n\n\n\nExemplo 4:\nNeste exemplo, usaremos a tabela frutas, criada quando descrevemos a função str_c. Veja com ela era para se recordar:\n\nfrutas |> \n  head() \n\n\n\n  \n\n\n\nDigamos que precisamos extrair apenas os numeros da coluna “nova_string”. E colocá-los em uma nova coluna chamda “numeros”.\nNeste caso, podemos usar a função str_extract() com um padrão que encontre um número de 0 até 9, seguido por um ou mais “qualquer caractere” e depois outro número de 0 até 9.\nEste padrão irá encontrar padrões como “1_1” ou “2_2”.\nEm seguida, usamos um outro padrão [:punct:] na função str_remove para remover a pontuação.\n\nfrutas |> \n  mutate (numeros = str_extract(nova_string, \"[0-9].+[0-9]\")) |> \n  mutate (numeros = str_remove(numeros, \"[:punct:]\"))\n\n\n\n  \n\n\n\n\n\n4.9.3 Alternadores\nAté aqui, utilizamos os caracteres especiais (Combinando Caracteres) e sabemos como localizá-los em diversas quantidades (Quantificadores). Mas em muitos casos precisamos organizá-los de forma lógica, possibilitando utilizá-los em combinações mais flexíveis. Para isto, utilizamos os símbolos de alternadores, veja:\n\nPara os exemplos a seguir utilizaremos a seguinte string de teste: Str_Teste_3 = “abcde”\n\n\nRegex\nBusca\n\n\n\n\n|\nOU\n\n\n[ ]\nUm dos\n\n\n[^ ]\nTudo exceto\n\n\n[ - ]\nRange\n\n\n\n\nStr_Teste_3 <- \"abcde\"\n\nExemplo 1:\nDigamos que desejamos criar um padrão que busque pela letras “ab” OU a letra “d”, para isto podemos usar:\n\nstr_view_all(Str_Teste_3, \"ab|d\")\n\n\n\n\n\nExemplo 2:\nDigamos que desejamos criar um padrão que busque qualquer um dos caracteres “abe”, para isto podemos usar:\n\nstr_view_all(Str_Teste_3, \"[abe]\")\n\n\n\n\n\nExemplo 3:\nDigamos que desejamos criar um padrão que busque qualquer um range de letras entre as letras “a” até a “c”, para isto podemos usar:\n\nstr_view_all(Str_Teste_3, \"[a-c]\")\n\n\n\n\n\nExemplo 4:\nNeste exemplo, usaremos novamente a tabela frutas, criada quando descrevemos a função str_c.\nDigamos que precisamos filtrar nesta tabela, apenas as frutas que possuem nomes compostos, ou seja, separados por espaço ou uma pontuação (ex “-”).\nPodemos usar a função filter() passando o resultado da função str_detect() junto com um padrão. Há diversas maneiras de construir este padrão. Aqui optar por buscar por caracteres alfa-numéricos (letras e números) e usamos o alternador [^ ] para negar tais caracteres, portanto, iremos identificar se a string NÃO possui letras ou números.\n\nfrutas |> \n  filter (str_detect(name, \"[^[:alnum:]]\")) \n\n\n\n  \n\n\n\n\n\n4.9.4 Ancoragem\nPara definir se a sequência do padrão de busca está no início ou fim da string, utilizamos as expressões de ancoragem:\n\n\n\nRegex\nBusca\n\n\n\n\n^\nInício da string\n\n\n$\nFim da string\n\n\n\nPara os exemplos a seguir utilizaremos a seguinte string de teste: Str_Teste_4 = “aaa”\n\nStr_Teste_4 <- \"aaa\"\n\nExemplo 1:\nPara criar um padrão que busque a letra “a” apenas no fim da string, usamos:\n\nstr_view_all(Str_Teste_4, \"a$\")\n\n\n\n\n\nExemplo 2:\nPara criar um padrão que busque a letra “a” apenas no início da string, usamos:\n\nstr_view_all(Str_Teste_4, \"^a\")\n\n\n\n\n\nExemplo 3:\nNeste exemplo, usaremos novamente a tabela frutas, criada quando descrevemos a função str_c.\nDigamos que queremos filtrar apenas as frutas que terminem com a letra “a” E também que terminem com a letra “o”. Podemos fazer:\n\nfrutas |> \n  filter (str_detect(name, \"[ao]$\")) \n\n\n\n  \n\n\n\n\n\n4.9.5 Grupos\nVocê pode utilizar parênteses ( ) para definir expressões de precedência ou para serem referenciados posteriormente através da ordem de criação.\nPara os exemplos a seguir utilizaremos a seguinte string de teste: Str_Teste_5 = “abbaab”\n\nStr_Teste_5 <- \"abbaab\"\n\nExemplo 1:\nDigamos que tenhamos a string “Blueberry” e você queira criar um padrão que busque pela letra “e” precedida das letras “lu” OU “b”.\nNeste caso, devemos criar um grupo de precedência para “lu” OU “b”. Para isto iremos colocar esta parte da expressão entre parênteses (lu|b). agora podemos utilzar este grupo e concluir o padrão de busca conforme a seguir:\n\nstr_view_all(\"Blueberry\", \"(lu|b)e\")\n\n\n\n\n\nVeja que se nossa string fosse “Blueberry is special”, a letra “e” de “special” não seria encontrada:\n\nstr_view_all(\"Blueberry is special\", \"(lu|b)e\")\n\n\n\n\n\nSe quisermos criar um padrão que encontre a letra “e” precedida de qualquer letra, podemos fazer:\n\nstr_view_all(\"Blueberry is special\", \"([:alpha:])e\")\n\n\n\n\n\nExemplo 2:\nAo criar um grupo, como vimos no exemplo anterior, podemos fazer referência à este grupo usando \\\\n, on n é a ordem de criação do grupo.\nPor exemplo, digamos que criamos um grupo utilizando os parênteses ( ) que contenha apenas letra “a”. Seu código ficaria (a), e ele poderia ser referenciado com \\\\1, pois foi o primeiro grupo a ser criado.\nDigamos que agora, você crie um segundo grupo com a letra “b”, seu código ficaria (b) e poderia ser referenciado com \\\\2.\nSabendo como criar os grupos e como referênciá-los, podemos montar um padrão de busca utilizando tanto os grupos quanto suas referência. Veja este exemplo:\n\nstr_view_all(Str_Teste_5, \"(a)(b)\\\\2\\\\1\")\n\n\n\n\n\nNeste exemplo, nosso padrão busca por “ba”, atraveś de \\\\2\\\\1, desde que tenham precedência de “ab”, através dos grupos (a)(b).\nExemplo 3:\nDigamos que tenhamos a string “Tem uma banana na mesa”. Queremos criar uma padrão que busque as letras “nana”. Apesar de termos soluções mais simples, poderíamos criar um grupo contendo “na” e usar a ordem de referência para concluir a expressão:\n\nstr_view_all(\"Tem uma banana na mesa\", \"(na)\\\\1\")\n\n\n\n\n\nExemplo 4:\nNeste exemplo, usaremos novamente a tabela frutas, criada quando descrevemos a função str_c.\nAqui iremos obter o mesmo resultado para o Problema 4 descrito na seção Quantificadores.\nPorém agora vamos usar a função str_replace() e o suporte à grupos que acabamos de ver para atingir o mesmo resultado, ou seja, extrair apenas os números da coluna nova_string.\n\nfrutas |> \n  mutate (numeros = str_replace(nova_string, \".+([0-9]).?([0-9]).+\", \"\\\\1\\\\2\")) \n\n\n\n  \n\n\n\nDetalhes do exemplo acima:\nObserve que a função str_replace(), recebe dois padrões, sendo o primeiro de busca e o segundo daquilo que iremos substituir o primeiro.\nNeste caso, nosso padrão de busca, encontra “qualquer caractere” “uma ou mais vezes”, depois cria um “grupo com números de 0 a 9”, seguido por “qualquer caractere zero ou uma vez” e depois cria o segundo “grupo com números de 0 à 9” e conclui com “qualquer caractere uma ou mais vezes”.\nCom nosso padrão de busca criado, iremos criar nosso padrão de substituição, ou seja, aquilo que for encontrado pelo padrão de busca, será substituído pelo padrão de substituição.\nNosso padrão de substituição ficou simples (“\\\\1\\\\2”). Veja que ele apenas pega o conteúdo do grupo 1 e grupo 2 criados no padrão de busca usando parênteses para substituir.\n\n\n4.9.6 Pesquisa ao Redor\nEm alguns casos, precisamos criar um padrão que olhe ao redor para encontrar o que buscamos.\nHá símbolos para definirmos grupos que estão precedendo o que buscamos e há símbolos para definirmos grupos que estão posteriores ao que buscamos. Há também símbolos para negar os casos anteriores e posteriores.\nVeja a tabela:\n\nPara os exemplos a seguir utilizaremos a seguinte string de teste: Str_Teste_6 = “bacad”\n\n\nRegex\nBusca\n\n\n\n\n(?= )\nSeguido por\n\n\n(?! )\nNão seguido por\n\n\n(?<= )\nPrecedido por\n\n\n(?<! )\nNão precedido por\n\n\n\n\nStr_Teste_6 <- \"bacad\"\n\nExemplo 1:\nVamos criar um padrão de busca que localize a letra “a”, mas queremos a(s) letra(s) “a” que são seguidas apenas pela letra “c”.\nPara isso iremos criar um grupo (“c”), mas como é um grupo que irá seguir aquilo que buscamos, ao invés dos parêntese apenas, iremos utilizar o símbolo da tabela anterior “?=”a fazer (?=c). Depois adicionamos a busca pela letra “a”.\n\nstr_view_all(Str_Teste_6, \"a(?=c)\")\n\n\n\n\n\nExemplo 2:\nVamos criar um padrão de busca que localize a letra “a”, mas queremos a(s) letra(s) “a” que são precedidas pela letra “b”. Usando a mesma tabela e raciocínio do exemplo anterior, podemos criar o grupo com a letra b, mas como é um grupo de precedência, temos que adicionar os símbolos “?<=” e fazer:\n\nstr_view_all(Str_Teste_6, \"(?<=b)a\")\n\n\n\n\n\nExemplo 4:\nNeste exemplo, usaremos novamente a tabela frutas, criada quando descrevemos a função str_c.\nDigamos que iremos filter as frutas que comecem com as letras “B” e “P” se forem seguidas das letras “e” e “l”. Desta forma, não teremos na saída frutas como “Banana” ou “Pineapple”\n\nfrutas |> \n  filter(str_detect(name, \"^[BP](?=[el])\"))"
  },
  {
    "objectID": "Manipulacao_Strings/Manipulacao de strings com stringr.html#outras-interpretações",
    "href": "Manipulacao_Strings/Manipulacao de strings com stringr.html#outras-interpretações",
    "title": "4  Manipulacao de Strings com STRINGR",
    "section": "4.10 Outras Interpretações",
    "text": "4.10 Outras Interpretações\n\n4.10.0.1 regex\nConforme visto na seção Expressões Regulares, o interpretador padrão das funções do pacote stringr, é o regex, ou seja, sempre que tivermos o parâmetro pattern =, se não especificarmos nada, ele irá interpretar a string deste parêmetro como se fosse uma expressão regular (regex).\nA seguir, veremos como mudar este padrão e introduzir outros interpretadores disponíveis.\n\n\n4.10.0.2 fixed\nPara buscar bytes nativos (raw), podemos usar o interpretador fixed(). Esta opção é bastante rápida, mas pode perder alguns caracteres que podem estar representados de maneiras diferentes (ex não ASCII).\nExemplo:\n\nstr_detect(\"\\u0130\", fixed(\"i\"))\n\n[1] FALSE\n\n\n\n\n4.10.0.3 coll\nPara comparar strings respeitando seu agrupamento. Interessante para strings com localização e não sensíveis a maiúsculas ou minúsculas.\nExemplo:\n\nstr_detect(\"\\u0130\", coll(\"i\", TRUE, locale = \"tr\"))\n\n[1] TRUE\n\n\n\n\n4.10.0.4 boundary\nPara localizar fronterias entre caracteres. quebra de linhas, sentenças ou palavras.\n\n\n\n\n\n\nDica\n\n\n\nPara maiores informações veja os exemplo digitando ?stringr::modifiers"
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html",
    "href": "DataHora/Datas_e_horas_com_lubridate.html",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "",
    "text": "A seguir temos vários exemplos de manipulação de variáveis data e hora utilizando o pacote LUBRIDATE do R. Para saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=lubridate.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\ngt\nlubridate\n\n\nlibrary (tidyverse)\nlibrary (gt)\nlibrary (lubridate)"
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#tipos-de-objetos-de-data-e-hora",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#tipos-de-objetos-de-data-e-hora",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.2 Tipos de objetos de data e hora",
    "text": "5.2 Tipos de objetos de data e hora\n\n5.2.0.1 Datetime\nUma variável do tipo “datetime” (data e hora) representa um ponto na linha do tempo armazenado em um número que representa o número de segundos desde 01-01-1970 00:00:00 (UTC).\n\n\n\n\n\n\nNota\n\n\n\nUniversal Time Coordinated (UTC), é uma escala coordenada de tempo, mantida pelo “Bureau International des Poids et Mesures (BIPM)”. Até 1972, era chamado de (GTM ou Greenwich Mean Time). É também conhecida como “Z time” ou “Zulu Time”.\n\n\n\n\n5.2.0.2 Date\nQuando nos referimos à uma variável “date”(data), significa que ela armazena um número inteiro que representa o número de dias desde 01-01-1970.\n\n\n5.2.0.3 Time\nQuando nos referimos à uma variável “time” (tempo em segundos), ela armazena um número inteiro que representa o número de segundos desde às 00:00:00 (hms).\nPara os vários exemplos a seguir, utilizaremos os seguintes objetos data e hora:\n\ndt <-  as_datetime(1511870400)\nd <- as_date(17498)\nt <-hms::as_hms(85)\ndt; d; t\n\n[1] \"2017-11-28 12:00:00 UTC\"\n\n\n[1] \"2017-11-28\"\n\n\n00:01:25\n\n\n\n\n\n\n\n\nDica\n\n\n\nOs objetos gerados pela maioria das funções do lubridate usam os padrões POSIXct, POSIXlt, Date, Period ou objetos que podem ser convertidos para o POSIXlt. Para maiores informações sobre estas classes, digite:\n?DateTimeClasses\nPOSIXct: armazena segundos desde 01-01-1970 00:00:00 (Unix epoch) POSIXlt: armazena uma lista de dia, mês, ano, hora, min, segundos, etc.\n\n\n\n\n5.2.1 Exemplos da Folha de Referência\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência do lubridate disponível no site do RStudio.\n\n\n\n\n\n\n\nNota\n\n\n\nEm geral, ao final de cada comando, as vezes você verá a chamada à função gt(). Isto é apenas para a formatação da tabela de saída e não é necessário para que você entenda os comandos precedentes. Em alguns casos, onde o volume de dados de saída pode ser extenso, usamos também a função head() para mostrar apenas as linhas iniciais. Quando o exemplo possui muitas colunas de saída, eventualmente utilizamos a função select() para selecionar apenas algumas colunas.\nEm alguns casos usaremos funções de manipulação de dados do pacote dplyr, como mutate () ou count().\n\n\n\n\n\n\n\n\nNota\n\n\n\nO termo data-frame descrito ao longo deste texto, é utilizado de forma livre para objetos do tipo data.frame, tibble, entre outros. Pense como se fosse uma tabela de um banco de dados e/ou uma planilha do MS Excel, contendo linhas e colunas. Apesar de não ser rigorosamente igual à uma tabela, muitas vezes usaremos estes termos de forma intercambiável para facilitar o entendimento de iniciantes."
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#validando-data-e-hora",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#validando-data-e-hora",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.3 Validando Data e Hora",
    "text": "5.3 Validando Data e Hora\nO pacote lubridate possui uma série de funções para obter e definir os elementos de ano, mês, dia, hora, minuto e segundos de um objeto data e hora.\nUse as funções a seguir servem para identificar estes elementos em seus dados a partir de uma string. Cada uma delas aceita o argumento “tz” para definir o fuso-horário (timezone), se este não for definido, UTC é utilizado.\nEstas funções são nomeadas conforme a tabela abaixo e sua ordem obedece tal nomenclatura:\n\n\n\nElemento\nLetra\n\n\n\n\ny\nano (year)\n\n\nm\nmês (month)\n\n\nd\ndia (day)\n\n\nh\nhora (hour)\n\n\nm\nminuto (minute)\n\n\ns\nsegundos (seconds)\n\n\n\nPor exemplo, para criar um objeto datetime passando a string “2017-11-28T14:02:00”, utilzamos a função ymd_hms(). Isto porque ao montar a string de data e hora, colocamos como ordem o ano, mês, dia, hora, minuto e segundo.\n\nymd_hms(\"2017-11-28T14:02:00\")\n\n[1] \"2017-11-28 14:02:00 UTC\"\n\n\nSe passarmos a string trocando o ano pela dia, devemos usar a função dmy_hms():\n\ndmy_hms(\"28-11-2017T14:02:00\")\n\n[1] \"2017-11-28 14:02:00 UTC\"\n\n\n\n\n\n\n\n\nNota\n\n\n\nVeja que tanto a função ymd_hms() quanto a dmy_hms(), geraram o mesmo objeto datetime. Se quisermos obter o valor inteiro que representa este objeto desde 01-01-1970 00:00:00, podemos usar a função decimal_date()\n\n\nVeja o código abaixo com mais alguns exemplos das funções validando os elementos da string passada para a função:\n\n# ymd_hms(), ymd_hm(), ymd_h().\nymd_hms(\"2017-11-28T14:02:00\") |> print()\n\n[1] \"2017-11-28 14:02:00 UTC\"\n\n# ydm_hms(), ydm_hm(), ydm_h().\nydm_hms(\"2017-22-12 10:00:00\") |>  print()\n\n[1] \"2017-12-22 10:00:00 UTC\"\n\n# mdy_hms(), mdy_hm(), mdy_h(). \nmdy_hms(\"11/28/2017 1:02:03\") |>  print()\n\n[1] \"2017-11-28 01:02:03 UTC\"\n\n# dmy_hms(), dmy_hm(), dmy_h().\ndmy_hms(\"1 Jan 2017 23:59:59\")|>  print()\n\n[1] \"2017-01-01 23:59:59 UTC\"\n\n# ymd(), ydm(). \nymd(20170131)|>  print()\n\n[1] \"2017-01-31\"\n\n# mdy(), myd(). \nmdy(\"July 4th, 2000\")|>  print()\n\n[1] \"2000-07-04\"\n\n# dmy(), dym(). \ndmy(\"4th of July '99\")|>  print()\n\n[1] \"1999-07-04\"\n\n# yq() Q para quartil. \nyq(\"2001: Q3\")|>  print()\n\n[1] \"2001-07-01\"\n\n# my(), ym(). \nmy(\"07-2020\")|>  print()\n\n[1] \"2020-07-01\"\n\n#hms::hms() ou lubridate::hms(), ms() ou hm() para períodos.\nhms::hms(sec = 0, min = 1, hours = 2)\n\n02:01:00\n\n\n\n5.3.1 Outras funções úteis\n\n5.3.1.1 date_decimal\nUse para converter um número decimala para data e hora:\n\ndate_decimal(2017.5)\n\n[1] \"2017-07-02 12:00:00 UTC\"\n\n\n\n\n5.3.1.2 now\nUse para obter um objeto data e hora do instante:\n\nnow(tzone = \"America/Sao_Paulo\")\n\n[1] \"2022-09-01 11:14:37 -03\"\n\n\n\n\n\n\n\n\nImportante\n\n\n\nSe o fuso-horário (tzone =) não for informado, a função utilizará aquele utilzado pelo sitema operacional em execução.\n\n\n\n\n5.3.1.3 today\nUse para obter a data atual.\n\ntoday()\n\n[1] \"2022-09-01\"\n\n\n\n\n5.3.1.4 fast_strptime\nUse para converter vetores de caracteres para objetos data e hora (POSIXlt) de forma rápida.\n\nfast_strptime('9/1/01', '%y/%m/%d')\n\n[1] \"2009-01-01 UTC\"\n\n\n\n\n5.3.1.5 parse_date_time\nUse para converter vetores de caracteres para objetos data e hora (POSIXct) de forma mais simplificada.\n\nparse_date_time(\"19/1/1\", \"ymd\")\n\n[1] \"2019-01-01 UTC\""
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#obtendo-e-definindo-componentes-de-data-e-hora",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#obtendo-e-definindo-componentes-de-data-e-hora",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.4 Obtendo e Definindo Componentes de Data e Hora",
    "text": "5.4 Obtendo e Definindo Componentes de Data e Hora\nUse as funções abaixo para obter um componente de um objeto data e hora.\n\n# Obter o \"DIA\" de um objeto \"datetime\"\nday(dt)\n\n[1] 28\n\n# Obter a \"DATA\"\ndate(dt)\n\n[1] \"2017-11-28\"\n\n# Obter a \"ANO\".\n# Para obter o \"ANO ISO 8610 use isoyear()\n# Para obter o \"ANO Epidemiológico use epiyear()\nyear(dt)\n\n[1] 2017\n\n# Obter o \"MÊS\". \n# Use argumentos label= e addr= para obter o nome ou abreviação do mês.\nmonth(dt)\n\n[1] 11\n\n# Obter o \"DIA DA SEMANA\".\n# Use argumentos label= e addr= para obter o nome ou abreviação do dia.\nwday(dt, label = TRUE) \n\n[1] ter\nLevels: dom < seg < ter < qua < qui < sex < sáb\n\n# Obter o \"DIA DO TRIMESTRE\".\nqday(dt) \n\n[1] 59\n\n# Obter a HORA\". \nhour(dt)\n\n[1] 12\n\n# Obter os \"MINUTOS\". \nminute(dt)\n\n[1] 0\n\n# Obter os \"SEGUNDOS\". \nsecond(dt)\n\n[1] 0\n\n# Obter o \"FUSO-HORÁRIO. \ntz(dt)\n\n[1] \"UTC\"\n\n# Obter a \"SEMANA DO ANO\". \nweek(dt)\n\n[1] 48\n\n# ara obter a \"SEMANA DO ANO\" ISO 8160 use isoyear()\n# Para obter a \"SEMANA DO ANO\" Epidemiológico use epiyear()\n\n# Obter o \"TRIMESTRE\". \nquarter(dt)\n\n[1] 4\n\n# Obter o \"SEMESTRE\". \nsemester(dt)\n\n[1] 2\n\n# Saber se é \"MANHÃ (am). \nam(dt)\n\n[1] FALSE\n\n# Saber se é \"TARDE\" (pm).\npm(dt)\n\n[1] TRUE\n\n# Saber se é \"HORÁRIO DE VERÃO\" \ndst(d)\n\n[1] FALSE\n\n# Saber se é \"ANO BISEXTO\"\nleap_year(d)\n\n[1] FALSE\n\n\nPara definir um componente de um objeto, podemos utilzar as funções acima, porém com o sinal de atribuição.\nPor exemplo, para alterar o dia de “28” do objeto “d”, para dia “1”, podemos fazer:\n\nday(d) |>  print() \n\n[1] 28\n\nday(d) <- 1\nprint(d) \n\n[1] \"2017-11-01\"\n\n\nPodemos também atualizar um componente do objeto data e hora:\n\n# Atualizar um componente do objeto\nupdate(dt, mday = 2, hour = 1)\n\n[1] \"2017-11-02 01:00:00 UTC\"\n\n\nO exemplo acima, altera o dia do mês para 2 e a hora para 01."
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#arredondando-data-e-hora",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#arredondando-data-e-hora",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.5 Arredondando Data e Hora",
    "text": "5.5 Arredondando Data e Hora\nUse as funções a seguir para “arredondar” ou aproximar um objeto data e hora para unidades de ajuste. As unidades válidas são:\n\nsecond, minute, hour, day, week, month, bimonth, quarter, season, halfyear e year.\n\n\n5.5.0.1 floor_date\nUse para “arredondar para baixo” a data e hora para a unidade mais próxima.\nPor exemplo, digamos que temos um objeto data = “2017-11-28” e queremos arredondar para baixo, sendo que a unidade é mês, ou seja, arredondar para o início do mês:\n\nfloor_date(dt, unit=\"month\")\n\n[1] \"2017-11-01 UTC\"\n\n\nround_date\nUse para “arredondar” a data para a unidade mais próxima.\n\nround_date(dt, unit=\"month\")\n\n[1] \"2017-12-01 UTC\"\n\n\nVeja que no exemplo acima, como tínhamos dia 28/11 e pedimos para arredondar na unidade “month”, ele arredondou para o mês 01/12.\nSe o dia fosse 14/11, a função arredondaria para 01/11.\n\n\n5.5.0.2 ceiling_date\nUse para “arredondar para cima” a data e hora para a unidade mais próxima.\n\nceiling_date(dt, unit=\"month\")\n\n[1] \"2017-12-01 UTC\""
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#imprimindo-data-e-hora",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#imprimindo-data-e-hora",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.6 Imprimindo data e hora",
    "text": "5.6 Imprimindo data e hora\nEm alguns casos, desejamos imprimir um objeto data e hora de uma maneira específica e/ou mais amigável. O pacote lubridate tem a capacidade de utilizar “templates” e ainda permite modificá-los para customizar como a impressão do objeto será feita.\n\n5.6.0.1 stamp\nUse para criar um “template” mais amigável à partir de uma string de exemplo. Veja também as função stamp_date() e stamp_time() que são funções específicas para lidar com datas e horas respectivamente.\nEm geral criamos uma função que utiliza a função stamp() e depois a utilizamos em nosso script passando o objeto data e hora. Veja este exemplo:\n\nsf <- stamp(\"Criado terça-feira, 17 de janeiro de 2022 às 3:34\") \nsf(ymd(\"2020-04-05\"))\n\n[1] \"Criado domingo-feira, 05 de abril de 2020 às 00:00\"\n\n\n\n\n\n\n\n\nDica\n\n\n\nProcure usar o dia maior que 12 na hora de criar o template. Isto facilita para função distinguir que parte do template é o mês e qual parte é o dia."
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#fuso-horários",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#fuso-horários",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.7 Fuso-Horários",
    "text": "5.7 Fuso-Horários\nO R reconhece ~600 fuso-horários. Cada um deles, tem iformações sobre o fuso-horário, horário de verão e variações de calendário históricas de uma área. O R define apenas um fuso-horário por vetor.\nUse o fuso-horário “UTC” para evitar horários-de-verão nos objetos.\nPara obter uma lista dos fuso-horários disponíveis, use:\n\nOlsonNames() |> \n  as_tibble()\n\n\n\n  \n\n\n\n\n5.7.0.1 Sys.timezone\nUse para obter o fuso-horário atual, use:\n\nSys.timezone()\n\n[1] \"America/Sao_Paulo\"\n\n\n\n\n5.7.0.2 with_tz\nUse para obter o mesmo objeto data e hora em um novo fuso-horário (novo relógio).\n\nwith_tz(dt, tzone = \"US/Alaska\")\n\n[1] \"2017-11-28 03:00:00 AKST\"\n\n\n\n\n5.7.0.3 local_time\nPara saber a diferença entre fuso-horários, podemos usar a função local_time e definir a unidade. Por exemplo:\n\nlocal_time(dt, tz = \"US/Alaska\", units = \"hours\")\n\nTime difference of 3 hours\n\n\n\n\n5.7.0.4 force_tz\nUse para obter o mesmo objeto data e hora em um novo fuso-horário (novo data e hora).\n\nforce_tz(dt, \"US/Pacific\")\n\n[1] \"2017-11-28 12:00:00 PST\""
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#matemática-com-data-e-hora",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#matemática-com-data-e-hora",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.8 Matemática com Data e Hora",
    "text": "5.8 Matemática com Data e Hora\n\n5.8.1 Introdução\nO pacote lubridate fornece três classes de intervalo de tempo para fazer cálculos com data e hora.\n\nPeríodos: Acompanham mudanças no horário do relógio, isto ignora irregularidades na “linha do tempo”.\nDurações: Acompanham a passagem do “tempo físico”, o que diverge do horário do relógio quando irregularidades na “linha do tempo” acontecem.\nIntervalos: Representam um intervalo específico da “linha do tempo”, limitado pelo início e fim da data e hora.\n\nEste três formas de enchergam a “linha do tempo” é necessário pois cálculos de data e hora usando a “linha do tempo” são inconsistentes.\nSabemos que nem todos os anos têm 365 dias, com no caso do ano bi-sexto. Ou no caso de minutos de um retorno do horário de verão tem 60 segundos.\nPense nos seguintes cenários:\nSe tivermos um dia normal, a “linha do tempo” ficaria algo como:\n\n\nnor <- ymd_hms(\"2018-01-01 01:30:00\",tz=\"US/Eastern\") \nprint(nor)\n\n[1] \"2018-01-01 01:30:00 EST\"\n\n\nJá, quando o horário de verão se inicia, termos o seguinte cenário na linha do tempo:\n\n\ngap <- ymd_hms(\"2018-03-11 01:30:00\",tz=\"US/Eastern\")\n\nQuando o horário então se encerra, temos na linha do tempo este cenário:\n\n\nlap <- ymd_hms(\"2018-11-04 00:30:00\",tz=\"US/Eastern\")\n\nE ainda temos o “ano-bisexto”, que também causa inconsistência na linha do tempo:\n\n\nleap <- ymd(\"2019-03-01\")\n\nPara os casos acima, criamos quarto objetos data e hora: nor, gap, lap e leap para representar cada cenário de inconsistência na linha do tempo.\nAgora veremos com as três classes do lubridate citadas anteriormente reagem em cada situação:\n\n\n5.8.2 Períodos\nVimos que os períodos acompanham as mudanças no horário do relógio, isto ignora irregularidades na “linha do tempo”.\nPor exemplo, se quisermos adicionar 90 minutos ao objeto nor criado anteriormente, teremos:\n\nnor + minutes(90)\n\n[1] \"2018-01-01 03:00:00 EST\"\n\n\n\nJá, se quisermos adicionar 90 minutos no dia do início do horário de verão (objeto gap), teremos:\n\ngap + minutes(90)\n\n[1] \"2018-03-11 03:00:00 EDT\"\n\n\n\nVeja que o período ignorou a inconsistência na linha do linha e trouxe o resultado como ela não existisse.\nO mesmo aconteceria com a data e hora do objeto lap criado no fim do horário de verão:\n\nlap + minutes(90)\n\n[1] \"2018-11-04 02:00:00 EST\"\n\n\n\nSituação identica aconteceria para o objeto leap criado em ano bisexto. Por exemplo, digamos que queremos somar um período de 1 ano.\n\nleap + years(1)\n\n[1] \"2020-03-01\"\n\n\n\nAs funções de períodos para adicionar ou subtrair data e hora, tem o nome da unidade seguido de um “s”. Nos exemplos anterior somamos minutos usando minutes() e anos usando years().\nA lista abaixo traz as funções que criam objetos períodos, ou sejam, que modelam eventos que acontecem em horário específico do relógio.\nPodemos utilzar estes objetos para somar ou subtrair de objetos data ae hora.\n\n\n\nFunção\nObjeto Período\n\n\n\n\nyears(x = 1)\nx anos\n\n\nmonths(x)\nx meses\n\n\nweeks(x = 1)\nx semanas\n\n\ndays(x = 1)\nx dias\n\n\nhours(x = 1)\nx horas\n\n\nminutes(x = 1)\nx minutos\n\n\nseconds(x = 1)\nx segundos\n\n\nmilliseconds(x = 1)\nx milisegundos\n\n\nmicroseconds(x = 1)\nx microsegundos\n\n\nnanoseconds(x = 1)\nx nanosegundos\n\n\npicoseconds(x = 1)\nx picosegundos\n\n\n\nPor exemplo, se quisermos criar um objeto período com 3 meses e 12 dias, fazemos:\n\np <- months(3) + days(12)\np\n\n[1] \"3m 12d 0H 0M 0S\"\n\n\nPara subtrair este período de um objeto data e hora, fazemos:\n\ndt - p\n\n[1] \"2017-08-16 12:00:00 UTC\"\n\n\nPodemos também usar as funções abaixo para criar objetos período:\n\n5.8.2.1 period\nUse para automatizar a criação de períodos.\nPor exemplo, para criar um objeto com período de 5 anos, podemos usar years(5) ou:\n\nperiod(5, unit = \"years\")\n\n[1] \"5y 0m 0d 0H 0M 0S\"\n\n\n\n\n5.8.2.2 as.period\nUse para transformar objetos de duração, intervalos e números para obejtos do tipo período:\nPor exemplos, temos um número 5 e queremos criar um período de 5 dias, podemos fazer:\n\nas.period(5, unit=\"days\")\n\n[1] \"5d 0H 0M 0S\"\n\n\n\n\n5.8.2.3 period_to_seconds\nUse para transformar um objeto do tipo período no total de número de segundos do período:\n\nperiod_to_seconds(p)\n\n[1] 8926200\n\n\n\n\n\n5.8.3 Duração\nDiferentes dos objetos períodos, os objetos do tipo duração (duration), Acompanham a passagem do “tempo físico”, o que diverge do horário do relógio quando irregularidades na “linha do tempo” acontecem.\nPor exemplo, digamos que temos nosso “dia normal” na linha do tempo e adicionarmos 90 minutos de duração:\n\nnor + dminutes(90)\n\n[1] \"2018-01-01 03:00:00 EST\"\n\n\n\nAté aqui, o resultado foi similar à adicionarmos um objeto do tipo período de 90 minutes.\nPorém, veja o que acontece quando temos uma inconsistência na linha do tempo, como por exemplo nosso início de horário de verão em nosso objeto gap.\n\ngap + dminutes(90)\n\n[1] \"2018-03-11 04:00:00 EDT\"\n\n\n\nO mesmo acontece com nosso término de horário de verão em nosso objeto lap:\n\nlap + dminutes(90)\n\n[1] \"2018-11-04 01:00:00 EST\"\n\n\n\nOu mesmo com nosso ano bi-sexto:\n\nleap\n\n[1] \"2019-03-01\"\n\nleap + dyears(1)\n\n[1] \"2020-02-29 06:00:00 UTC\"\n\n\n\nPodemos pensar em objetos de duração como um modelo físico, como uma vida útil de uma bateria. As durações são armazenados como segundos, que é a única unidade distância consistente.\nPor exemplo, se criarmos um objeto duração equivalente à 14 dias, ele irá armazenar 1209600s.\n\ndd <- ddays(14)\ndd\n\n[1] \"1209600s (~2 weeks)\"\n\n\n\n\n\n\n\n\nDica\n\n\n\nHá também uma classe chamada “difftime”, que se encontra no R base, ou seja, fora do pacote lubridate, usada para lidar com durações de tempo.\n\n\nAs funções para criar objetos de duração, são similares às dos objetos períodos, porém se iniciam com a letra “d”, veja:\n\nPodemos também usar as funções abaixo para criar objetos duração:\n\n\nFunção\nObjeto Duração\n\n\n\n\ndyears(x = 1)\n31536000x anos\n\n\ndmonths(x)\n2629800x meses\n\n\ndweeks(x = 1)\n604800x semanas\n\n\nddays(x = 1)\nx86400x dias\n\n\ndhours(x = 1)\n3600x horas\n\n\ndminutes(x = 1)\n60x minutos\n\n\ndseconds(x = 1)\nx segundos\n\n\ndmilliseconds(x = 1)\nx X \\(10^3\\) milisegundos\n\n\ndmicroseconds(x = 1)\nx X \\(10^6\\) microsegundos\n\n\ndnanoseconds(x = 1)\nx X \\(10^9\\) nanosegundos\n\n\ndpicoseconds(x = 1)\nx X \\(10 ^{12}\\)picosegundos\n\n\n\n\n5.8.3.1 duration\nUse para automatizar a criação de durações.\nPor exemplo, para criar um objeto com duração de 5 anos, podemos usar dyears(5) ou:\n\nduration(5, unit = \"years\")\n\n[1] \"157788000s (~5 years)\"\n\n\n\n\n5.8.3.2 as.duration\nUse para transformar objetos de períodos, intervalos e números para objetos do tipo duração:\nPor exemplos, temos um número 10 e queremos criar um período de 10 segundos, podemos fazer:\n\nas.duration(10)\n\n[1] \"10s\"\n\n\n\n\n5.8.3.3 make_difftime\nUse para criar um objeto difftime (R base) com um número específico de unidades.\n\nmake_difftime(3600)\n\nTime difference of 1 hours\n\n\n\n\n\n5.8.4 Intervalo\nObjeto do tipo intervalo, representam um intervalo específico da “linha do tempo”, limitado pelo início e fim da data e hora. Se dividirmor o intervalo, pela pela duração teremos a distância física do tempo. Se dividirmos o intervalo pelo período, termeos a distância relativa ao relógio.\nPodemos criar um objeto de intervalo, usando a função interval() ou o símbolo %--%.\n\ni <- interval(ymd(\"2017-01-01\"), d)\nj <- d %--% ymd(\"2017-12-31\")\ni; j\n\n[1] 2017-01-01 UTC--2017-11-01 UTC\n\n\n[1] 2017-11-01 UTC--2017-12-31 UTC\n\n\nObserve pelo resultado acima, temos duas data para cada objeto, a da esquerda representa o início do intervalo e a da direito o fim.\nPor exemplo, vamos pegar um dia normal na linha do tempo, representado pelo objeto nor e definirmos como o início do intervalo, e para o fim do intervalo usaremos nor mais um período de 90 minutos.\n\ninterval(nor, nor + minutes(90))\n\n[1] 2018-01-01 01:30:00 EST--2018-01-01 03:00:00 EST\n\n\n\nAgora, em uma linha do tempo inconsistente, o intervalo se mantém alinhado com o relógio. Veja como fica quando adicionamos um intervalo de 90 minutos quando temos o início de um horário de verão:\n\ninterval(gap, gap+minutes(90))\n\n[1] 2018-03-11 01:30:00 EST--2018-03-11 03:00:00 EDT\n\n\n\nDe forma similar, ocorre quando temos um intervalo quando há o término de um horário de verão:\n\ninterval(lap, lap+minutes(90))\n\n[1] 2018-11-04 00:30:00 EDT--2018-11-04 02:00:00 EST\n\n\n\nOu mesmo quando temos um intervalo em um ano bi-sexto:\n\ninterval(leap, leap + years(1))\n\n[1] 2019-03-01 UTC--2020-03-01 UTC\n\n\n\nO pacote lubridate possui diversas funções para lidar com intervalo.\n\n5.8.4.1 %within%\nUse para identificar se um objeto do tipo intervalo ou data e hora “a” cai dentro de um interválo “b”\nPor exemplo, se quisermos se a data e hora atual está dentro do intervalo “i”.\n\nnow () %within% i\n\n[1] FALSE\n\n\n\n\n5.8.4.2 int_start\nUse para obter ou definir o início de um intervalo:\n\nint_start(i)\n\n[1] \"2017-01-01 UTC\"\n\n\n\nint_start(i) <- now()\n\n\n\n\n\n\n\nNota\n\n\n\nA função int_end() faz o oposto, ou seja, obtem ou define o fim de um intervalo.\n\n\nint_aligns\nUse para identificar se dois objetos do tipo intervalo estão alinhados, ou seja, compartilham de uma mesma data e hora.\n\nint_aligns(i,j)\n\n[1] TRUE\n\n\nNo exemplo acima, temos “2017-11-28” como início de um objeto e fim de outro, por isso dizemos que eles estão alinhados.\n\n\n\n\n\n\nNota\n\n\n\nSe quisermos saber se estes objetos estão sobrepostos, ou seja, tem partes de uma intervá-lo que também fazem parte de outro, utilizamos a função int_overlaps().\n\n\n\n\n5.8.4.3 int_diff\nUse para transformar em intervalos, os valores que estão em um vetor de data e hora.\n\nv <- c(dt, dt+100, dt+1000); int_diff(v)\n\n[1] 2017-11-28 12:00:00 UTC--2017-11-28 12:01:40 UTC\n[2] 2017-11-28 12:01:40 UTC--2017-11-28 12:16:40 UTC\n\n\nint_flip\nUse para colocar em ordem reversa a direção de um intervalo, ou seja, a dat e hora do fim vai para o início do intervalo e a data e hora do início vai para o final.\n\nint_flip(i)\n\n[1] 2017-11-01 UTC--2022-09-01 14:14:38 UTC\n\n\nPara colocar em ordem padrão um intervalo de acordo com a linha do tempo, podemos usar a função int_standardize().\n\nint_standardize(i)\n\n[1] 2017-11-01 UTC--2022-09-01 14:14:38 UTC\n\n\n\n\n5.8.4.4 int_length\nUse para obter, em segundos, o tempo total de um intervalo:\n\nint_length(i)\n\n[1] -152547279\n\n\n\n\n5.8.4.5 int_shift\nUse para mover um intervalo para mais ou para menos na linha do tempo.\nPor exemplo, se mover todo o intervalo (início e fim) em um dia antes da linha do tempo, podemos fazer:\n\nint_shift(i, days(-1))\n\n[1] 2022-08-31 11:14:38 -03--2017-10-30 22:00:00 -02\n\n\n\n\n5.8.4.6 as.interval\nUse para criar um objeto intervalo com determinado periodo definindo uma dat e hora de início.\nPor exemplo, para criarmos um intervalo de 1 dia, iniciando na data atual, podemos fazer:\n\nas.interval(days(1), start = now())\n\n[1] 2022-09-01 11:14:38 -03--2022-09-02 11:14:38 -03\n\n\n\n\n\n\n\n\nNota\n\n\n\nPodemos usar a função is.interval() para saber se um objeto é um intervalo válido ou não."
  },
  {
    "objectID": "DataHora/Datas_e_horas_com_lubridate.html#datas-imaginárias",
    "href": "DataHora/Datas_e_horas_com_lubridate.html#datas-imaginárias",
    "title": "5  Datas e horas com LUBRIDATE",
    "section": "5.9 Datas Imaginárias",
    "text": "5.9 Datas Imaginárias\nÉ importante observar que nem todos os anos tem 365 dias (ex: ano bi-sexto) e nem todos os minutos tem 60 segundos (ex: fim de horário de verão).\nIsso é importante de ser observado, pois em alguns casos tentamos criar data imaginárias, como por exemplo “Fev 31”, adicionando um mês à “Jan 31”. As funções do pacote lubridate são inteligentes o suficiente e neste caso retornaria um valor NA:\n\n\njan31 <- ymd(20180131)\njan31 + months(1)\n\n[1] NA\n\n\n\n5.9.1 Aritmética dos meses\nPorém, as vezes, intuitivamente, é isto que desejamos fazer, ou seja, adicionar “um mês” a “Jan 31”, mas que a função seja inteligente o suficiente para rolar para o último dia do mês.\nAdicionar ou subtrair meses as vezes é uma tarefa difícil, pois temos meses de diferentes tamanhos (ex: 30, 31, 28 dias ou até 29). Por isso, em alguns casos é útil termos a possibildade de fazermos um ajustes automáticos.\nPara isso usamos, ao invés do sinal de adição “+”, utilizamos o símbolo %m+% para adicionar meses (ou %m-% para subtrair). Veja:\n\njan31 %m+% months(1)\n\n[1] \"2018-02-28\"\n\n\nA função add_with_rollback() nos permite rolar a data da soma para o primeiro dia do mês seguinte (e não o último dia do mês anterior) usando o argumento roll_to_first.\n\nadd_with_rollback(jan31, months(1), roll_to_first = TRUE)\n\n[1] \"2018-03-01\""
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "",
    "text": "A seguir temos vários exemplos de visualização de dados utilizando o pacote GGPLOT2 do R. Este é um pacote muito flexível para gerar diversos tipos de gráficos.\n\n\n\n\n\n\nNota\n\n\n\nApesar de visualização de dados não ser especificamente parte das etapas de transformação e manipulação de dados, acreditamos ser importante um conhecimento básico sobre o tema, pois muitas vezes, para explicarmos aquilo que estamos transformando ou manipulando, o fazemos de forma gráfica para melhor compreensão.\nO objetivo não é explicar a aplicabilidade e/ou o a função de cada gráfico, mas sim, como ele pode ser construído.\n\n\nPara saber mais sobre este pacote, acesse:\nhttps://cran.r-project.org/package=ggplot2.\n\n\n\n\n\n\nAviso\n\n\n\nPara melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:\nhttps://education.rstudio.com/learn/beginner/.\n\n\nPara os exemplos, iremos carregar os seguintes pacotes:\n\ntidyverse\ngt\n\n\nlibrary (tidyverse)\nlibrary (gt)\n\n\n\nA maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na Folha de Referência do stringr disponível no site do RStudio."
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#tipos-de-variáveis",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#tipos-de-variáveis",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.2 Tipos de Variáveis",
    "text": "6.2 Tipos de Variáveis\nNão é intuito deste tópico aprofundar neste tema, porém como a natureza de cada gráfico pode estar relacionada ao tipo de variável que ele irá representar, vamos rever de forma resumida os tipos de variáveis aleatórias no contexto de análise de dados e do ggplot.\nEste conhecimento é importante, pois iremos nos referir a eles, principalmente quando tratarmos das funções de Geometrias (geoms).\nPodemos categorizar as variáveis em Qualitativas ou Quantitativas. (Fávero 2021)\n\n6.2.0.1 Qualitativas\nRepresentam as características de um indivíduo, objeto ou elemento que não podem ser medidas ou quantificadas.\nAs variáveis qualitativas, também poder ser classificadas em função do número de categorias em:\n\nDicotômica ou Binária: Apenas duas categorias.\nPolicotômica: Mais que duas categorias.\n\nOu em função da escala de mensuração em:\n\nNominal: As unidades são classificadas em categorias em relação à características representadas. Sem ordem ou relação entre si. (ex: sexo)\nOrdinal: As unidades são classificadas em categorias em relação à características representadas. Há uma ordem ou relação entre si. (ex: grau de escolaridade)\n\n\n\n\n\n\n\nNota\n\n\n\nTipicamente, um dado qualitativo em natureza representa valores discretos que pertencem a um conjunto finito de classes. Estes valores discretos podem ser representados através de um número ou textos.\nEm geral, variáveis qualitativas são representadas no ggplot com o tipo fatores (factors) ou caracteres(chr).\n\n\n\n\n6.2.0.2 Quantitativa\nRepresentam as características de um indivíduo, objeto ou elemento resultantes de uma contagem ou mensuração.\nAs variáveis quantitativas, também podem ser classificadas em função da escala de precisão.\n\nDiscreta: Assumem conjunto finito de valores, frequentemente de uma contagem (ex: número de filhos, quantidade de carros, etc)\nContínua: Assumem conjunto infinito de valores, frequentemente com resultado de uma mensuração (ex: peso, altura, salário, etc)\n\nOu em função da escala de mensuração em:\n\nIntervalar: As unidades são ordenadas em relação à características mensurada e possui um unidade de constante. A origem, ou ponto zero, não expressa ausência de quantidade. (ex: temperatura)\nRazão: As unidades são ordenadas em relação à características mensurada e possui um unidade de constante. A origem, ou ponto zero, é única e expressa ausência de quantidade.(ex: distância percorrida)\n\n\n\n\n\n\n\nCuidado\n\n\n\nVale lembrar que nem sempre uma variável representada por um número é quantitativa. O número da carteira de identidade é um exemplo disso. Apesar dos números ela é uma variável qualitativa.\n\n\n\n\n6.2.0.3 Discretas e Contínuas no GGPLOT\nO ggplot2, em geral irá associar as variáveis caractere (char) e fatores (factors) em escalas discretas de forma automática. Já as variáveis numéricas, o ggplot irá associar automaticamente com escalas contínuas.\nVocê verá nas seções seguintes este tipo de segregação, ou seja, um gráfico para variáveis discretas, contínuas ou um mix de ambas e assim por diante.\n\n\n\n\n\n\nImportante\n\n\n\nQuando tivermos variáveis que não seguem este padrão, devemos “transformá-las, usando funções como as_factor(), as.integer(), as.double, etc.\nPor exemplo, para representar uma variável que é do tipo inteiro, porém é discreta, deveremos antes alterá-la para um fator antes de submeter ao ggplot preferencialmente."
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#gramática-dos-gráficos",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#gramática-dos-gráficos",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.3 Gramática dos Gráficos",
    "text": "6.3 Gramática dos Gráficos\nO pacote ggplot2 é uma implementação do livro “Grammar of Graphics”, que apresenta um conceito de quais seriam os elementos de um gráfico e suas interconexões. O modelo teórico proposto no livro é que através de camadas definidas qualquer gráfico pode ser construído. Abaixo o modelo, que deve ser interpretado de baixo para cima.\n\nDe uma forma bem resumida, a idéia é que você possa construir minimamente qualquer gráfico com base nestes mesmos elementos: um conjunto de dados, um sistema de coordenadas e geometrias, que seriam marcas visuais que representas os pontos dos dados.\n\nNo caso do ggplot2, para mostrar valores no gráfico, as varíaveis do conjunto de dados podem ser mapeadas em propriedadas visuais da geometria (geom).\nEste mapeamento de estética (aesthetic) é feito através da função aes() e podemos fazer mapeamentos estéticos como cor, tamanho, forma, etc."
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#modelo-para-construção-de-um-gráfico",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#modelo-para-construção-de-um-gráfico",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.4 Modelo para Construção de um Gráfico",
    "text": "6.4 Modelo para Construção de um Gráfico\nNo caso do ggplot2, podemos definir uma espécie de modelo (template) para a sintaxe de construção de gráficos:\n\nVejamos a seguir uma introdução ao uso do modelo visto acima:\n\n\n6.4.0.1 ggplot\nA função ggplot() inicia um gráfico que será completado com as camadas adicionadas na sequência, como uma geometria, um sistema de coordenada ou até um tema.\nUsando o modelo acima, vamos gerar nosso primeiro gráfico.\nComo base de dados usaremos a tabela mtcars. Para maiores informação sobre as variáveis (colunas) e observações (linhas) do mtcars, digite ?mtcars.\n\nmtcars\n\n\n\n  \n\n\n\n\nggplot(data = mtcars) +\n  geom_point (mapping = aes(x = hp, y = mpg ))\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nObserve que mesmo sem definirmos escalas, temas, transformações estatísticas ou outras camadas, o gráfico ainda assim foi gerado.\nIsto acontece porque o ggplot tem valores padrões dinâmicos que tentam prover o melhor resultado possível com o mínimo de esforço.\n\n\n\n\n\n\n\n\nDica\n\n\n\nA definição da estética com seu mapeamento, feito neste exemplo na função de geometria (geom_point) poderá ser feito também na função ggplot().\n\n\nApesar do gráfico final ser similar, a estética mapeamento poderá ser utilizada pelas funções geom_*() nas camadas seguintes, sem a necessidade de repetí-la, caso contrário, ela será restrito apenas àquela geom() na qual foi declarada. Veja:\n\nggplot(data = mtcars, mapping = aes(x = hp, y = mpg))+\n  geom_point()\n\n\n\n\nPor ser comum o uso do argumento data = e mapping =, podemos excluídas do código, deixando-o mais enxuto, porém mais difícil para quem não tem tanta familiaridade, veja:\n\nggplot(mtcars,aes(x = hp, y = mpg)) +\n  geom_point()\n\n\n\n\n\n\n6.4.0.2 last_plot\nUse para retornar o último gráfico gerado.\n\nlast_plot()\n\n\n\n\n\n\n6.4.0.3 ggsave\nUse para salvar o gráfico em uma imagem. O tipo de imagem é selecionado pela extensão do arquivo de saída.\nPor exemplo, para salvar o diretório atual um arquivo com o gráfico chamado “plot-01.png” com o formato de imagem “.PNG” de tamanho 5x5 centímetros, fazemos:\n\nggsave(\"plot-01.png\", width = 5, height = 5, units = \"cm\")"
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#camadas",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#camadas",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.5 Camadas",
    "text": "6.5 Camadas\n\n6.5.1 Introdução\nA seguir iremos apresentar as principais camadas do ggplot e suas principais funções.\n\n\n\n\n\n\nNota\n\n\n\nPara a camada de dados, o ggplot aceitará qualquer conjunto de dados (data frame). Para facilitar a criação do gráfico recomenda-se que os dados já estejam organizados (tidy) com observações em linhas e variáveis em colunas.\n\n\n\nEstéticas\nGeometrias\nEstatísticas\nEscalas\nCoordenadas\nFacetas\nTema\n\n\n\n6.5.2 Estéticas\nPodemos mapear a estética de uma camada à variáveis presentes em nossa camada de dados até definí-las manualmente. Se não especificarmos de forma explícita, o ggplot tentará assumir valores padrões que serão usados por determinada função outras camadas, como a de geometria ou de estatística.\nExistem estéticas que são comuns a quase todas as camadas, como cor, forma, tamanho, etc.\nA estética é vinculada à uma variável através da função aes(). É comum, apesar de não ser mandatório para todas as estéticas, que determinemos os valores para x e y.\nA seguir veremos algumas delas:\n\n6.5.2.1 color e fill\nUse para definir a cor (color) ou preenchimento (fill) para a estética.\n\nggplot(mtcars)+\n  geom_point(aes(x = hp, y = mpg, color = \"red\"))\n\n\n\n\nNo exemplo acima, definimos que a estética “x”, assumirá valores provenientes da variável que existe em nossos dados chamada “hp”. Já a estética “y”, assumirá valores provenientes da variável “mpg”.\nJá a estética “color” assumirá o valor constante “red”. Na string de color =, podemos usar valores de cores em inglês, como “red” ou “blue”, ou também códigos RGB, como ““#00ABFF” ou “FF00AA”.\n\n\n\n\n\n\nImportante\n\n\n\nObserve que o valor definido da cor, foi dentro dos parênteses da função aes(), ou seja, ela está fazendo o mapeamento da estética cor (color) com os dados. Se utilizarmos o argumento color = da função geom_point(),estaremos definindo um valor fora do mapeamento.\n\n\n\nggplot(mtcars)+\n  geom_point(aes(x = hp, y = mpg) , color = \"red\")\n\n\n\n\nApesar do resultado ser similar, observe que no exemplo anterior tivemos color como um mapeamento da estética, como definimos o valor fixo com a cor “red”, seria como tivessemos em nossos dados uma coluna onde todas as linhas tivessem o valor “red”. Já no exemplo acima, estamos simplemente dizendo à função da geometria que queremos a cor vermelha para ela.\nVejamos um outro exemplo para que fique claro este ponto.\nVamos gerar o mesmo gráfico onde colocamos “red” como parte da estética, porém agora, iremos mapeá-la com a coluna “qsec” de nossos dados mtcars:\n\nggplot(mtcars)+\n  geom_point(aes(x = hp, y = mpg, color = qsec))\n\n\n\n\nObserve que neste caso a estética de cor foi mapeada com a variável qsec. Por se tratar de uma variável contínua, o ggplot escolheu autometicamente uma sequência de cores, neste caso do azul claro para o azul escuro, para representar este tipo de variável. Veremos mais adiante como customizar esta e outras escolhar automáticas feitas nas escalas.\n\n\n6.5.2.2 linetype\nUse para definir a linha utilizada no gráfico. Podemos utilizar um número de 0 a 6 ou um nome:\n(0 = “blank”, 1 = “solid”, 2 = “dashed”, 3 = “dotted”, 4 = “dotdash”, 5 = “longdash”,6 = “twodash”)\nPor exemplo, ao invés de utilizarmos a geometria de pontos (geom_point), vamos utilzar a geometria de linha (geom_line):\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg) , linetype = \"dotted\")\n\n\n\n\n\n\n6.5.2.3 size\nUse para definir o tamanho, no caso de uma linha em “mm”.\nComo dito anteriormente, estes valores são comuns para vários geometrias. Por exemplo, podemos utilizar o argumento size também na geometria de pontos (geom_point):\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), size = 5)\nggplot(mtcars)+\n  geom_point(aes(x = hp, y = mpg), size = 5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.2.4 lineend\nUse para definir o terminador da linha. Os valores podem ser: round, butt e square.\n\nsquaredbuttround\n\n\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), lineend = \"square\", size = 4)\n\n\n\n\n\n\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), lineend = \"butt\", size = 4)\n\n\n\n\n\n\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), lineend = \"round\", size = 4)\n\n\n\n\n\n\n\n\n\n6.5.2.5 linejoin\nUse para definir a junção da linha. Os valores podem ser: round, mitre e bevel.\n\nroundmitrebevel\n\n\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), linejoin = \"round\", size = 4)\n\n\n\n\n\n\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), linejoin = \"mitre\", size = 4)\n\n\n\n\n\n\n\nggplot(mtcars)+\n  geom_line(aes(x = hp, y = mpg), linejoin = \"bevel\", size = 4)\n\n\n\n\n\n\n\n\n\n6.5.2.6 shape\nUse para definir a forma. Podemos passar um número ou um nome em inglês da forma conforme abaixo:\n\n\nggplot(mtcars)+\n  geom_point(aes(x = hp, y = mpg), shape = \"square cross\",  size = 3)\nggplot(mtcars)+\n  geom_point(aes(x = hp, y = mpg), shape = 5, size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.3 Geometrias\nO ggplot nos permite selecionar para o mesmo gráfico uma ou mais formas geométrias. Por exemplo, eu posso ter o mesmo gráfico final, mas ao invés de ter pontos representando os dados, podemos ter barras e assim por diante.\n\n\n\n\n\n\nAviso\n\n\n\nLembre-se que cada função retornará uma camada, portanto, a ordem de criação das camadas afeta o resultado do gráfico, pois uma será criada sobre a anterior.\n\n\n\n6.5.3.1 Gráficos Primitivos\nPara os exemplos a seguir, utilizaremos duas bases de dados, uma chamada economics e outra chamada seals.\n\nEconomicsSeals\n\n\n\neconomics\n\n\n\n  \n\n\n\n\n\n\nseals\n\n\n\n  \n\n\n\n\n\n\nPara simplificar o código dos próximos exemplos, iremos criar dois objetos gráfico do ggplot:\nO primeiro chamado “a”, irá conter um objeto ggplot com os dados de economics, mapeando a estética de x para a variável “date” e y para a variável “unemployed”.\nO segundo chamado “b”, irá conter um objeto ggplot com os dados de seals, mapeando a estética de x para a variável “long” e y para a variável “lat”.\nDesta forma trabalharemos com os mesmos objetos base e adicionaremos apenas novas camadas utilizando o operador “+” a fim de identificar os detalhes das diversas funções de geometria e não precisarmos repetir o código das camadas iniciais do gráfico.\n\na <- ggplot(economics, aes(date, unemploy))\nb <- ggplot(seals, aes(x = long, y = lat))\n\n\n\n\n\n\n\nNota\n\n\n\nPara simplificar o código, em algum momentos podemos omitir o argumento, como data=, mapping = , x = , y = . Isto porque já estamos os valores na ordem que a função nos pede.\n\n\nAgora com os objetos inicialmente criados, iremos adicionar novas camadas afim de obtermos os gráficos e entendermos algumas das funções de geometria para gráficos primitivos.\n\n\n6.5.3.2 geom_blank\nUse para garantir limites para todos os gráficos de acordo com os dados.\n\na + geom_blank()\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nUse a função expand_limits() para expandir os limites do gráfico usando dados. Ver ?expand_limits para mais detalhes.\n\n\n\n\n6.5.3.3 geom_curve\nUse para criar curvas.\n\nb + geom_curve(aes(yend = lat + 1, xend = long + 1), curvature = 1)\n\n\n\n\n\n\n6.5.3.4 geom_path\nUse para conectar observações.\n\na + geom_path(lineend = \"butt\", linejoin = \"round\", linemitre = 1)\n\n\n\n\n\n\n6.5.3.5 geom_polygon\nUse para criar poligonos. É similar a geom_path(), porém a parte interna é preenchida com argumento fill =.\n\na + geom_polygon(aes(alpha = 50))\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nO argumento alpha = , é muito comum na definição de cores. De maneira simplificada, ele indica o nível de transparência de uma cor, sendo 0, nenhuma transparência e 1 transparência total.\n\n\n\n\n6.5.3.6 geom_rect\nUse para criar retângulos.\n\nb + geom_rect(aes(xmin = long, ymin = lat,\nxmax = long + 1, ymax = lat + 1))\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nA função geom_title() fazem a mesma coisa, porém são parametrizadas de forma diferente. A geom_rect usa a localização dos 4 cantos do quadrado, enquanto a geom_tile usa o centro e seu tamanho (largura e altura) para dimensionar.\n\n\n\n\n6.5.3.7 geom_ribbon\nUse para criar uma “fita”. Para cada valor de x, ela mostra um intervalo y, definido por ymin e ymax. Veja que geom_area() é um caso especial do geom_ribbon(), onde o ymin é fixo em 0 e y é usado no lugar de ymax.\n\na + geom_ribbon (aes(ymin = unemploy - 900,\nymax = unemploy + 900))\n\n\n\n\n\n\n6.5.3.8 Segmentos de Linhas\nEstas funções de geometrias, permitem criar diversos tipo de segmentos de linha e são úteis quando precisamos “marcar” ou definir algo no gráfico, com linhas verticais ou horizontais por exemplo.\n\n\n6.5.3.9 geom_abline\nUse para criar uma linha de um ponto “a” até um ponto “b”, passando o intercepto e a inclinação da reta.\n\nb +  geom_abline(aes(intercept = 0, slope = 1))\n\n\n\n\n\n\n6.5.3.10 geom_hline\nUse para criar uma ou mais linhas horizontais.\n\nb + geom_hline(aes(yintercept = lat))\n\n\n\n\nVeja que no exemplo anterior, fizemos o mapeamento do argumento yintercept como parte da estética (aes), mapeando este argumento com a variável “lat” de nossos dados.\nSe quisermos simplesmente traçar uma linha com o intercepto do eixo y, correspondendo ao valor 40 (por exemplo, se fosse um tipo de meta), podemos definir este valor fora do mapeamento:\n\nb + geom_hline(yintercept = 40)\n\n\n\n\n\n\n6.5.3.11 geom_vline\nUse para criar uma ou mais linhas horizontais.\n\nb + geom_vline(aes(xintercept = long))\n\n\n\n\n\n\n6.5.3.12 geom_segment\nÉ similar ao geom_curve, porém ao invés de criar uma curva, criar um segmento de reta.\n\nb + geom_segment(aes(yend = lat + 1, xend = long + 1))\n\n\n\n\n\n\n6.5.3.13 geom_spoke\nUse para criar um segmento, parametrizado pela localização, direção e distância.\n\nb + geom_spoke(aes(angle = 1:1155, radius = 1))\n\n\n\n\n\n\n6.5.3.14 Uma Variável Contínua\nQuando precisamos analisar um varíavel contínua, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto “c” e outro “c2”, aos quais iremos adicionar novas camadas. Similar ao que fizemos anteriormente, porém agora utilizaremos a base de dados “mpg”.\n\nmpg\n\n\n\n  \n\n\n\nCriando os objetos ggplot:\n\nc <- ggplot(mpg, aes(hwy))\nc2 <- ggplot(mpg)\n\n\n\n\n\n\n\nImportante\n\n\n\nObserve que o objeto “c”, usa a base “mpg” já atribuindo a variável “hwy” para x= da estética. Esta configuração será aplicada para qualquer funções geom_*() a não ser que explicitamente tenhamos uma estética redefinindo isso dentro de outra camanda de geometria.\nJá para o objeto “c2”, não temos a estética de x definida, portanto, teremos que definí-la em nas próximas camadas com a funções de geometria (geom_*()).\n\n\n\n\n6.5.3.15 geom_histogram\nUse para criar histogramas, ou seja, uma forma de visualizar uma variável contínua dividindo no eixo x em classes e contando o número de observações de cada classe no eixo y.\nO argumento binwidth = define o tamanho das classes.\nNo exemplo a seguir, dividimos a variável contínua de consumo por rodagem (hwy) em classes com 2 observações cada.\n\nc + geom_histogram(binwidth = 2) \n\n\n\n\nSe desejar definir o número de classes ao invés de quantas observações terão cada classe, utilize o argumento bins =.\n\nc + geom_histogram(bins = 16) \n\n\n\n\n\n\n6.5.3.16 geom_freqpoly\nUse para gerar um gráfico de polígonos de frequência. Enquanto o histograma gera um gráfico de barras, esta geometria gera uma linha.\n\nc + geom_freqpoly(bins = 30)\n\n\n\n\n\n\n6.5.3.17 geom_area\nUse para criar um gráfico de área, onde para cada valor no eixo x, há um valor y máximo e o valor de y mínimo é sempre zero.\n\n\n\n\n\n\nNota\n\n\n\nVocê verá um argument (stat = “bin”) abaixo. Veremos as estatísticas na seção ESTATÍSTICAS (STATS). Por hora, pense apenas que é uma forma de definirmos os valores que iremos mostrar para o eixo y. Por padrão o número de agrupamento (bin) é 30.\n\n\n\nc + geom_area(stat = \"bin\", bins = 32)\n\n\n\n\n\n\n6.5.3.18 geom_density\nUse para fazer um gráfico de densidade. Usando funções de estimativa de densidade de kernel, seria uma versão mais “arredondada” do histogram, mostrando a função densidade de probabilidade da variável.\nHá a possibilidade de configurar vários kernels das funções de densidade, como “gaussian”, “rectangular”, “triangular”, “epanechnikov”, “biweight”, “cosine” ou “optcosine”.\n\nc + geom_density(kernel = \"gaussian\")\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nVeja que podemos criar duas geometrias, uma com o histograma e outra de densidade sobrepostas. Para isto temos que sobreescrever a estética definida previamente para o eixo y (antes era count) usando ..density..\n\n\n\nc + geom_histogram(aes(y = ..density..)) +\n  geom_density()\n\n\n\n\n\n\n6.5.3.19 geom_dotplot\nUse para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.\n\nc + geom_dotplot() \n\n\n\n\n\n\n6.5.3.20 geom_qq\nUse para criar um gráfico de quantil-quantil. Em geral utilizado para confirmar se uma variável tem uma distribuição gaussiana.\n\nc2 + geom_qq(aes(sample = hwy))\n\n\n\n\n\n\n6.5.3.21 Uma Variável Discreta\nQuando precisamos analisar um varíavel discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto “d” ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente usando a base de dados mpg. Utilizaremos a variável combustível (fl).\n\nd <- ggplot(mpg, aes(fl))\n\n\n\n6.5.3.22 geom_bar\nUse para criar um gráfico de barras.\n\nd + geom_bar()\n\n\n\n\nVeja outro exemplo: Como aconteceu com o combustível (fl), podemos pegar a variável tipo da classe do veículo (class) e gerar um gráfico de barras também.\n\nd + geom_bar(aes(x = class))\n\n\n\n\nUsando o argumento da estética para cor do preenchimento (fill), podemos mapear uma variável igual ou diferente. Com isto, o ggplot automaticamente criará uma legenda para os diferentes valores da varíavel. Veja o que acontece quando temos x=fl e fill = class:\n\nd + geom_bar(aes(fill =class))\n\n\n\n\nNote que como a estética herdada do objeto ggplot base (d) tinha o mapeamento de x para a variável combustível (fl), ela ainda permanece no eixo x.\nSe sobrescrevermos este mapeamento para a estética do geom_bar com a mesma variável para x e fill, teremos:\n\nd + geom_bar (aes(x = class, fill = class)) \n\n\n\n\nNote que o resultado automático do gráfico foi um pouco diferente. Quando tivemos x = fl e fill = class as barras foram empilhadas (stack) e quando tivemos x = class e fill = class, as barras foram lado colocadas lado a lado (dogde).\nPor padrão, o ggplot, quando múltiplas barras ocupam o mesmo ponto, elas são empilhadas. Este comportamento pode ser definido através do argumento position = .\nVeja as diferentes opções:\n\ndodgedodge2stackfill\n\n\n\nd + geom_bar(aes(fill =class), position = \"dodge\")\n\n\n\n\n\n\n\nd + geom_bar(aes(fill =class), position = \"dodge2\")\n\n\n\n\n\n\n\nd + geom_bar(aes(fill = class) , position = \"stack\")\n\n\n\n\n\n\n\nd + geom_bar(aes(fill =class), position = \"fill\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nAs geometrias podem ter valores calculados autometicamente “computed variables”. Isto é para faciliar a geração dos gráficos com valores padrões. No caso da geom_bar, não precisamos passar que no eixo y gostaríamos de ter a contagem da variável que está no eixo x. Veja que então, a variável y não ficou sem um valor, ele apenas foi substituído pela contagem (count) automaticamente. A geom_bar tem “count” e “prop” como varíveis computadas.\nPara saber quais varíaveis são computadas automaticamente para cada geometria, veja a ajuda com ?geom_bar.\n\n\n\n\n6.5.3.23 Duas Variáveis Discretas\nQuando precisamos analisar um duas varáveis discretas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto “g” ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados diamonds. Utilizaremos as variáveis corte (cut) e cor (color).\n\ng <- ggplot(diamonds, aes(cut, color))\n\n\n\n6.5.3.24 geom_count\nEsta é uma variante do geom_point() que conta o número de observação em cada localização e então mapeia a contagem na área do ponto.\n\ng + geom_count()\n\n\n\n\n\n\n6.5.3.25 geom_jitter\nÉ similar ao geom_point, porém adiciona uma variação aleatória em cada ponto.\n\ng + geom_jitter(height = 2, width = 2)\n\n\n\n\nComo várias outras geometrias, podemos adicionar uma cor na estética do geom_jitter, mapeando outra váriável, como por exemplo o corte (cut) para facilitar a visualização:\n\ng + geom_jitter(aes(color = cut), height = 2, width = 2)\n\n\n\n\n\n\n6.5.3.26 Uma Variável Contínua e Outra Discreta\nQuando precisamos analisar uma varável contínua e outra discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto “f” ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados mpg. Utilizaremos as variáveis classe (class) e consumo na estrada (hwy).\n\nf <- ggplot(mpg, aes(class, hwy))\n\n\n\n6.5.3.27 geom_col\nUse para criar um gráfico de colunas. Ele é similar ao gráfico de barras, porém agora, no eixo y, teremos uma variável contínua. Observe que enquanto no geom_bar, o eixo y é calculado automaticamente, aqui na geom_col, você precisa ter a variável já nos seus dados.\n\nf + geom_col()\n\n\n\n\nAssim, como no geom_bar, podemos definir a cor de preenchimento da estética para geom_col, usando fill =.\nVamos usar a variável de número de cilindros (cyl) como exemplo.\n\nf + geom_col(aes(fill = cyl))\n\n\n\n\n\n\n\n\n\n\nAviso\n\n\n\nVeja que no caso acima, o ggplot tentou automaticamente ajustar a escala de cores para uma escala contínua. Dá a impressão que temos veículos com 7 cilindros inclusive.\n\n\nIsto é porque em nossos dados, a variável “cyl” é do tipo inteiro (integer) e com isto, o ggplot2 entende como um variável contínua.\nPara obter o efeito pretendido, temos algumas opções. Uma seria mudar a variável cyl para o tipo fator (factor) usando a função as_factor(). Veja:\n\nf + geom_col(aes(fill = as_factor(cyl)))\n\n\n\n\nPor padrão, as classes são colocadas de forma empilhada, similar ao que vimos na geom_bar. Se quisermos colocadas lado a lado, devemos fazer:\n\nf + geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nA largura das colunas é expandida automaticamente, pois não temos valores para todas as combinações. Por exemplo, não temos 8 cilindros em carros compatos. Há formas difrentes de ajutar isso, uma delas é ajustar a base de dados, criando as combinações possíveis utilização a função tidyr::complete()\n\n\n\ncomplete(mpg, class, cyl) |> ggplot () +\n  geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = \"dodge\")\n\n\n\n\n\n\n6.5.3.28 geom_boxplot\nUse para criar um gráfico boxplot (box e whiskers). Este gráfico é bastante interessante, pois mostra cinco estatísticas automaticamente (a mediana, primeiro e terceiro quartis e os limites max e min) e os pontos fora da curva individualmente (outlyers).\nPara este exemplo, iremos além de definir uma cor de preenchimento através do argumento fill = , iremos remover a legenda desta camada usando show.legend = FALSE.\n\n\nf + geom_boxplot(aes(fill = factor(class)), show.legend = FALSE)\n\n\n\n\nPara mostrar a média ao invés da media, podemos fazer:\n\nf + geom_boxplot(aes(middle = mean(hwy)))\n\n\n\n6.5.3.29 geom_dotplot\nUse para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.\n\nf + geom_dotplot(aes(color = class),binaxis = \"y\", stackdir = \"center\")\n\n\n\n\n\n\n6.5.3.30 geom_violin\nUse para criar um gráfico de violino. Ele mostra de forma compacta a distribuição de uma variável contínua.\n\nf + geom_violin(aes(fill = class), scale = \"area\")\n\n\n\n\n\n\n6.5.3.31 Duas Variáveis Contínuas\nQuando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto “e” ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados mpg. Utilizaremos as variáveis consumo na cidade (cty) e consumo na estrada (hwy).\n\ne <- ggplot(mpg, aes(cty, hwy))\n\n\n\n6.5.3.32 geom_label\nUse para adicionar uma camada de texto (labels) no gráfico. Ela pode ser utilizada sozinha como em gráficos de dispersão, mas é mais comum, usá-la em conjunto com outras geometrias. Por exemplo, colocar os valores acima de cada barra em um geom_bar(). Por padrão, o texto a ser adicionado, tem um retângulo atrás para facilitar a leitura.\nO argumento nudge_* =, ajusta a posição casos textos estejam no mesmo ponto\n\ne + geom_label(aes(label = cty), nudge_x = 1, nudge_y = 1)\n\n\n\n\nNo exemplo acima, temos um gráfico com um texto em cada ponto de cruzamento entre a variável no eixo x e a correspondente no eixo y.\nVeja um uso do geom_label em conjunto com outra geom.\nExemplo 1:\nNeste caso, iremos sumarizar os dados e obtermos um tabela contendo cada classe e a soma do consumo na estrada (hwy). Depois criaremos uma geometria de colunas e adicionaremos uma camada com o texto.\n\ngeom_labeldados\n\n\n\ndados <- mpg |> group_by(class) |> summarise(hwy = sum(hwy))\n\ndados |> ggplot(aes(class, hwy, fill = class)) +\n  geom_col() +\n  geom_label(aes(label = hwy))\n\n\n\n\n\n\n\ndados\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPodemos utilizar o argumento position = e através da função position_stacked centralizar o ajuste vertical (vjust) para colocar o texto no centro da coluna e remover a camada da legenda:\n\n\n\ndados |> \n  ggplot(aes(class, hwy, fill = class)) +\n  geom_col() +\n  geom_label(aes(label = hwy), \n             position = position_stack(vjust = 0.5),\n             show.legend = FALSE)\n\n\n\n\nExemplo 3:\nNeste exemplo, seguiremos uma outra abordagem. Vimos na seção da geom_bar que ela calcula automaticamente a contagem dos valores para o eixo y, ou seja, nós não tinhamos esta contagem em nossos dados e não queremos preparar um tabela resumida com fizemos no exemplo anterior. Neste caso, podemos utilzar esta estatística calculada usando o parametro stat.\nVeremos mais detalhes sobre as estatisticas na seção Estatísticas (stats)\n\nggplot(mpg, aes(x = fl, fill = fl))+\n  geom_bar() + \n  geom_label(stat  = \"count\", \n             aes(label = paste0(\"Total = \", after_stat(count))),\n             size = 2,\n             show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nVeja acima que podemos controlar o tamanho (size) e definirmos um string junto com a variável que colocamos no texto utilziando a função paste0().\n\n\n\n\n6.5.3.33 geom_point\nUse para gerar um gráfico de pontos ou dispersão. Este tipo de gráfico é muito úteil quando queremos mostrar relações entre as duas variáveis contínuas. Apesar dele também poder ser usado para comparar uma contínua com uma discreta, as opções de geometria como geom_jitter ou geom_count são mais apropriadas.\n\ne + geom_point()\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nUm gráfico de bolhas (bubblechart) é um gráfico de pontos com uma terceira variável associada ao tamanho dos pontos.\n\n\n\ne + geom_point(aes(size = displ), alpha = 0.3)\n\n\n\n\n\n\n6.5.3.34 geom_quantile\nUse para criar um gráfico de quantis. Seria o equivalente contínuo do boxplot.\n\ne + geom_quantile()\n\n\n\n\nPodemos definir quantis quantis queremos obter, por exemplo, se quisermos obter uma quebra de 5% , 50% e 95% podemos fazer:\n\ne + geom_quantile(quantiles = c(0.05, .5, 0.95))\n\n\n\n\n\n\n6.5.3.35 geom_rug\nUse para criar um gráfico de tapete (rug chart) com pequenas linhas para complementar uma visão 2Ds com duas visões de uma dimensão.\nO argumento sides é uma string que controla onde os tapetes irão aparecer no gráfico: “trbl” = top, right, bottom e left.\n\ne + geom_rug(sides = \"bl\")\n\n\n\n\nFica interessante colocar uma camada adicional com geom_point para entender melhor o que acontece neste tipo de gráfico. Veja que as linhas do tapete ficam mais próximas quando temos mais concentração de pontos. Como este gráfico mostra todos os pontos, ele faz mais sentido com pequenos conjuntos de dados.\n\ne + geom_rug(sides = \"bl\") +\n    geom_point()\n\n\n\n\n\n\n6.5.3.36 geom_smooth\nUse para ajudar a encontrar padrões na visualização quando há muitos dados sobrepostos.\n\ne + geom_smooth(method = \"lm\")\n\n\n\n\nVocê pode usá-lo para traçar linhas de tendência também.\n\ne + geom_point() +\n    geom_smooth(method = \"lm\", se= FALSE)\n\n\n\n\n\n\n6.5.3.37 geom_text\nUse para criar uma geometria com textos. É similar ao geom_label, porém não tem um quadrado envolta do texto por padrão:\n\ne + geom_text(aes(label = cty), nudge_x = 1, nudge_y = 1)\n\n\n\n\nAssim como aocntece no geom_label, podemos utilizar como camada adicional à outras geometrias. Veja:\n\ndados |> \n  ggplot(aes(class, hwy, fill = class)) +\n  geom_col() +\n  geom_text(aes(label = hwy), \n             position = position_stack(vjust = 0.5),\n             show.legend = FALSE)\n\n\n\n\n\n\n6.5.3.38 Mapas de Calor e Densidade\nEn alguns casos, precisamos mostrar como as duas variáveis contínuas se relacionam, dividindo o plano em retângulos e plotando os número de casos em cada retãngulo e preenchendo a cor de acordo com o número de casos. Para os exemplos a seguir, usaremos novamente a base “diamonds” em um objeto “h” .\n\nh <- ggplot(diamonds, aes(carat, price))\n\n\n\n6.5.3.39 geom_bind2d\nUse para gerar um mapa de calor com classe de contagem 2d. O gráfico é formado dividindo o plano em retângulos e plotando os número de casos em cada retangulo e preenchendo a cor de acordo com o número de casos.\n\nh + geom_bin2d(binwidth = c(0.25, 500))\n\n\n\n\n\n\n6.5.3.40 geom_density_2d\nUse para gerar um gráfico de contorno. É um gráfico de densidade (ver geom_density) só que para duas variáveis.\n\nh + geom_density_2d()\n\n\n\n\n\n\n6.5.3.41 geom_hex\nUse para gerar um mapa de calor hexagonal. O gráfico é formado dividindo o plano em hexagonos e plotando os número de casos em cada retangulo e preenchendo a cor de acordo com o número de casos.\n\nh + geom_hex(bins = 40)\n\n\n\n\n\n\n6.5.3.42 Duas Variáveis Discretas\nQuando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto “g” e “e” ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados mpg e diamonds. Utilizaremos as variáveis de mpg consumo na cidade (cty) e consumo na estrada (hwy) e de diamonds (cut e color).\n\ng <- ggplot(diamonds, aes(cut, color))\ne <- ggplot(mpg, aes(cty, hwy))\n\n\n\n6.5.3.43 geom_count\nEsta geometria é uma variante da geom_point que conta o número de observações para cada localização do gráfico e então mapeia o número da contagem com cada ponto.\n\ng + geom_count()\n\n\n\n\n\n\n6.5.3.44 geom_jitter\nUse para criar um gráfico de pontos com o uma dispersão aleatória em cada ponto sobreescrito. É similar a escrever geom_point(position = “jitter”).\n\ne + geom_jitter(height = 1, width = 1)\n\n\n\n\nPara entender como esta dispersão aleatória funciona, compare uma geometria de pontos onde temos vaŕios pontos no mesmo local (sem a dispersão em vermelho) e com a dispersão (jitter).\n\ne +\n  geom_jitter(alpha = 0.4, height = 1, width = 1) +\n  geom_point(color = \"red\")\n\n\n\n\n\n\n6.5.3.45 Mapas\nO ggplot2 também pode gerar gráficos de mapas.\nPara isso iremos criar um conjunto de dados à partir da base “USArrests”, contendo onúmero de assassinatos por estado americano. Depois iremos usar usar a função map_data() para criar um data frame com as iformações para o mapa (latitude e longitude). Depois usaremos este data frame para a geometria de mapas (geom_map).\n\nmapadata framedata frame de mapa\n\n\n\ndata <- data.frame(murder = USArrests$Murder,\nstate = tolower(rownames(USArrests)))\n\nmap <- map_data(\"state\")\nk <- ggplot(data, aes(fill = murder))\n\nk + geom_map(aes(map_id = state), map = map) +\n    expand_limits(x = map$long, y = map$lat)\n\n\n\n\n\n\n\ndata\n\n\n\n  \n\n\n\n\n\n\nmap\n\n\n\n  \n\n\n\n\n\n\nPara uma utilização mais moderna e e precisa de gráficos geográficos/mapas, recomenda-se o uso de uma geometria chamada geom_sf. Ela é capaz de mapear objetos do tipo “Simple Feature” do pacote”sf” diretamento no ggplot2. Este é um assunto bastante complexo, mas apenas como carater ilustrativo, veja como seria o plot do estado de São Paulo.\n\nlibrary (sf)\n\nsp <- st_read(dsn = \"shapefile_sp/estado_sp.shp\")\n\nReading layer `estado_sp' from data source \n  `/home/scopinho/MyBriefcase/github/Livro_Data_Transf_R/Visualizacao/shapefile_sp/estado_sp.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 645 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -53.11011 ymin: -25.31232 xmax: -44.16137 ymax: -19.77966\nGeodetic CRS:  SIRGAS 2000\n\nggplot (sp) +\n  geom_sf(color = \"Blue\")\n\n\n\n\n\n\n6.5.3.46 Visualizando Erros\nQuando precisamos analisar intervalos verticais, com linhas, barras e barras de erros, podemos usar as seguintes geometrias abaix. Porém, como nas demais seções, iremos preparar nosso objeto básico para evitar repetição de código.\nAgora teremos um objeto “j” ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base “df” que criaremos a seguir.\n\ndf <- data.frame(grp = c(\"A\", \"B\"), fit = 4:5, se = 1:2)\nj <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))\n\nVamos entender como é a base de dados “df” criada.\n\ndf\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNota\n\n\n\nA coluna “SE”, significa “standard error” ou erro padrão.\n\n\nJá o objeto ggplot base que criamos tem a variável grp no eixo x, fit no eixo y. Também definimos o y-min como fit - se (erro padrão) e o ymax como fit + se.\n\nj <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))\n\n\n\n6.5.3.47 geom_crossbar\nUse para criar uma barra no intervalo vertical. Esta função criará duas barras com um ponto central baseado em ymin, x e ymax. o argumento fatten = , é um fator multiplicador para o separador do meio.\n\nj + geom_crossbar(fatten = 5)\n\n\n\n\nVeja que a distância do ponto central de A até seu limite de baixo é definido por fit + se em nossa tabela de dados e nosso objeto “j”. O mesmo ocorre para o limite inferior.\n\n\n6.5.3.48 geom_errorbar\nUse para traçar barras de erro. Similar ao geom_crossbar, mas não mostra o ponto central ou as linhas laterais.\n\nj + geom_errorbar()\n\n\n\n\n\n\n6.5.3.49 geom_linerange\nSimilar a geom_errorbar, mas sem as linha superior ou inferior.\n\nj + geom_linerange()\n\n\n\n\n\n\n6.5.3.50 geom_pointrange\nSimilar à geom_linerange, porém monstrando o ponto central.\n\nj + geom_pointrange()\n\n\n\n\n\n\n6.5.3.51 Três Variáveis\nO ggplot não consegue criar gráficos 3D verdadeiros, porém permite visualizar superfícies 3D em 2 duas dimensões. Quando precisamos criar tais gráficos, as geometrias a seguir ajudam a fornecer um gráfico apropriado.\nNovamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto “l” ao qual iremos adicionar novas camadas. Isto é similar ao que fizemos anteriormente, só que agora usando a base de dados seals. Faremos um ajuste, criando uma coluna “z”, que será a raiz quadrada das somas dos quadrados de delta_long e delta_lat. Mapearemos nosso objeto ggplot base com x = long e y = lat:\n\nseals$z <- with(seals, sqrt(delta_long^2 + delta_lat^2))\nl <- ggplot(seals, aes(long, lat))\n\n\n\n6.5.3.52 geom_contour\n\nl + geom_contour(aes(z = z))\n\n\n\n\n\n\n6.5.3.53 geom_contour_filled\n\nl + geom_contour_filled(aes(z = z, color = z))\n\n\n\n\n\n\n6.5.3.54 geom_raster\n\nl + geom_raster(aes(fill = z), hjust = 0.5,\nvjust = 0.5, interpolate = FALSE)\n\n\n\n\n\n\n6.5.3.55 geom_tile\n\nl + geom_tile(aes(fill = z))\n\n\n\n\n\n\n\n6.5.4 Estatísticas\nPodemos dizer que as estatísticas, ou mais precisamente, uma transformação estatística, é uma maneira diferente de construirmos uma camada.\nAssim como cada camada de geometria possui uma transformação estatística padrão, cada estatística possui uma geometria padrão.\nA transformação estatística cria novas variáveis que não estavam presentes em nossos dados originais (ex: count, pop)\n\nPodemos visualizar uma transofrmação estatística mudando a estatística padrão de uma geometria (ex: geom_bar(stat=“count”) ou usando uma função stat() (ex: stat_count(geom=“bar”) que chama uma geometria padrão para criar uma camada.\n\n\n\n\n\n\nNota\n\n\n\nPodemos usar a sintaxe ..nome.. para mapear uma estatística em uma estética (aes()).\n\n\nPara ficar mais claro, vejamos o seguinte caso:\n\ni + stat_density_2d(aes(fill = ..level..),\ngeom = \"polygon\")\n\nExplicando com mais detalhes o exemplo acima, vemos que estamos uma adicionando uma camada no gráfico representado pela letra “i”.\nDepois estamos criando uma nova camada através da estatística “stat_density_2d”. Esta função cria diversas variáveis calculadas automaticamente que podem ser acessadas por ..level.., e neste caso estamos atribuindo uma variável calculada ao mapeamento de preenchimento fill =.\nAo final, estamos forçando uma geometria “polygon” ou invés da geometria padrão desta função que seria “density_2d”.\nVeja o exemplo abaixo:\n\nmpg |> ggplot(aes(x = class, fill = class))+\n  stat_count()\nmpg |> ggplot(aes(x = class, color = class))+\n  stat_count( geom = \"point\")\n\n\n\n\n\n\n\n\n\n\n\nNeste caso, estamos criando no gráfico da esquerda, uma camada usando a função stat_count (que tem com padrão a geom=“bar”) e no gráfico da direita, estamos forçando uma geometria de pontos.\nO mesmo poderia ser feito, utilizando a geometria e alterando a estatística padrão. Veja como seria:\n\nmpg |> ggplot(aes(x = class, fill = class))+\n  geom_bar()\nmpg |> ggplot(aes(x = class, color = class))+\n  geom_point(stat = \"count\")\n\n\n\n\n\n\n\n\n\n\n\nVeja que tivemos que alterar a estatística padrão apenas da geom_point. Isto porque a geom_bar, já possui a estatística “count” como padrão, já a geom_point, possui a estatística “identity” como padrão.\n\n\n\n\n\n\nImportante\n\n\n\nA transformação estatística “identity”, significa nenhuma transformação, ou seja, utiliza os dados que estão em nossa tabela original. É muito utilizada quando não queremos que alguma geometria faça o cálculo da transformação estatística para nós, mas sim, quando quisermos utilizar os dados já calculados em alguma coluna da tabela.\n\n\nA seguir teremos uma sequência, demonstrando a criação de diversas camadas utilizando as transformações estatísticas e suas respectiva geometrias padrão.\n\n\n\n\n\n\nDica\n\n\n\nPara maiores detalhes dos argumentos, variáveis computadas e geometrias padrão, digite ?<nome_função_estatística> (ex: ?stat_count)\n\n\n\n6.5.4.1 stat_bin\n\n\n6.5.4.2 stat_count\n\n\n6.5.4.3 stat_density\n\nc + stat_bin(binwidth = 1, boundary = 10)\nc + stat_count(width = 1)\nc + stat_density(adjust = 1, kernel = \"gaussian\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.4.4 stat_bin_2d\n\n\n6.5.4.5 stat_hex\n\n\n6.5.4.6 stat_density_2d\n\n\n6.5.4.7 stat_ellipse\n\ne + stat_bin_2d(bins = 30, drop = T)\ne + stat_bin_hex(bins = 30)\ne + stat_density_2d(contour = TRUE, n = 100)\ne + stat_ellipse(level = 0.95, segments = 51, type = \"t\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.4.8 stat_contour\n\n\n6.5.4.9 stat_summary_hex\n\n\n6.5.4.10 stat_summary_2d\n\n\n6.5.4.11 stat_boxplot\n\n\n6.5.4.12 sta_ydensity\n\nl + stat_contour(aes(z = z))\nl + stat_summary_hex(aes(z = z), bins = 30, fun = max)\nl + stat_summary_2d(aes(z = z), bins = 30, fun = mean)\nf + stat_boxplot(coef = 1.5)\nf + stat_ydensity(kernel = \"gaussian\", scale = \"area\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.4.13 stat_ecdf\n\n\n6.5.4.14 stat_quantile\n\n\n6.5.4.15 stat_smooth\n\ne + stat_ecdf(n = 40)\ne + stat_quantile(quantiles = c(0.1, 0.9),\nformula = y ~ log(x), method = \"rq\")\ne + stat_smooth(method = \"lm\", formula = y ~ x, se = T,\nlevel = 0.95)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.4.16 stat_function\n\n\n6.5.4.17 stat_qq\n\n\n6.5.4.18 stat_sum\n\n\n6.5.4.19 stat_summary\n\n\n6.5.4.20 stat_identity\n\n\n6.5.4.21 stat_unique\n\nggplot() + xlim(-5, 5) + \n  stat_function(fun = dnorm, n = 20, geom = \"point\")\nggplot() + stat_qq(aes(sample = 1:100))\ne + stat_sum()\ne + stat_summary(fun.data = \"mean_cl_boot\")\nh + stat_summary_bin(fun = \"mean\", geom = \"bar\")\ne + stat_identity()\ne + stat_unique()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.5 Escalas\nAs escalas mapeiam os valores dos dados em um valor visual de uma estética. Quando criamos uma gráfico, o ggplot adiciona escala para cada mapeamento de forma automática. Mas é possível alterar as escalas padrão.\nVejamos o gráfico abaixo:\n\nd + geom_bar()\n\n\n\n\nQuando escrevemos o código acima, o ggplot identifica que a variável x é do tipo discreta (categórica) e cria uma escala para ela. Faz o mesmo o o count do eixo y. Portanto, se sobrescrevermos as configurações da escala do eixo x para uma escala discreta, não haverá mudanças.\n\nd + geom_bar()+\n  scale_x_discrete()\n\n\n\n\nNo examplo a seguir, iremos sobrescrever a escala de preenchimento (fill) para um tipo manual, ou seja, onde iremos manualmente definir as cores de preenchimento, ou limites da escala (de onde até onde ela valerá) e os pontos de parada, seu nome e os títulos (labels). Veja como ficaria:\n\nn <- d + geom_bar(aes(fill = fl))\n\nn + scale_fill_manual(\nvalues = c(\"skyblue\", \"royalblue\", \"blue\", \"navy\"),\nlimits = c(\"d\", \"e\", \"p\", \"r\"), breaks =c(\"d\", \"e\", \"p\", \"r\"),\nname = \"fuel\", labels = c(\"D\", \"E\", \"P\", \"R\"))\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nLembre-se que já existe uma configuração de escala par o eixo x criada por padrão. Quando estamos sobrescrevendo com novos valores, se estes valores não sobrepoem os antigos, os valore anteriores ficam valendo. Por isso, a cor não foi alterada para o combustível (fl = c), já que deinifmos os limites da nova escala apenas para (d, e, p , r).\n\n\n\n6.5.5.1 Escalas de Propósito Geral\nEstas escalas são usadas na maioria das estéticas para mapear valores para os eixos x e y, preenchimento, cores, tipos de linhas, etc.\n\n\n6.5.5.2 scale_*_continuous\nUse par mapear valores contínuos para os valores visuais.\nPor exemplo, vamos , ver a diferença entre a escala padrão definida para a variável “count” e outra sobrescrevendo a escala e deixando-a de forma reversa.\n\n#Com escala padrão contínua para hwy.\nc + geom_line(stat = \"count\") +\n  scale_x_continuous()\n#Alterando o argumento trans = para inverter a escala.\nc + geom_line(stat = \"count\") +\n  scale_x_continuous(trans = \"reverse\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.5.3 scale_*_discrete\nSimilar a scale_*_continuous porém para variáveis discretas.\nPor exemplo:\n\n  d + geom_bar() +\n    scale_y_discrete(name = \"Número de observações\")\n\n\n\n\n\n\n6.5.5.4 scale_*_binned\nUse para deixar discreta um variável contínua, separando em classes. Veja o exemplo com a variável de consumo (hwy). Estamos alterando a escala e agrupando em 30 classes esta variável contínua.\n\nc + geom_bar() +\n  scale_x_binned(n.breaks = 30)\n\n\n\n\n\n\n6.5.5.5 scale_*_identity\n\n#Criando uma tabela com as cores como uma variável.\ndfc <- data.frame(\n  x = 1:4,\n  y = 1:4,\n  cor = c(\"red\", \"green\", \"blue\", \"yellow\")) \n\n#Gráfico com o preenchimento como variável discreta (col)\nggplot(dfc, aes(x, y))+\n  geom_col(aes(fill = cor)) \n  # + scale_fill_discrete() isso é o padrão, portanto opcional\n\n#Gráfico com o preenchimento pegando o valor da variável col\nggplot(dfc, aes(x, y)) +\n  geom_col(aes(fill = cor)) +\n  scale_fill_identity()\n\n\n\n\n\n\n\n\n\n\n\nVeja que quando usamos uma nova escala, você precisa definir se quer a legenda e outros elementos.\n\nggplot(dfc, aes(x, y)) +\n  geom_col(aes(fill = cor)) +\n  scale_fill_identity(guide = \"legend\")\n\n\n\n\n\n\n6.5.5.6 scale_*_manual\nUse para definir uma escala de forma manual. Neste exemplo, vamor criar uma variável “cores”, definindo manualmente uma cor para cada classe de veículo.\n\ncores <- c(suv = \"red\", \n          compact = \"blue\", \n          \"2seater\" = \"darkgreen\", \n          minivan = \"orange\",\n          midsize = \"lightblue\",\n          pickup = \"yellow\",\n          subcompact = \"orange3\")\n          \nggplot(mpg, aes(class, hwy)) +\n  geom_col(aes(fill = class)) +\n  scale_fill_manual(values = cores)\n\n\n\n\n\n\n6.5.5.7 scale_*_date\nUse para tratar uma escala como data. Neste exemplo, iremos utilizar o conjunto de dados “billboard” também modificar os labels da escala e quantas paradas ela terá.\n\nbillboard |> \n  ggplot(aes(x = date.entered)) +\n  geom_bar() +\n  scale_x_date(date_labels = \"%m/%Y\", date_breaks = \"20 weeks\")\n\n\n\n\n\n\n6.5.5.8 scale_*_datetime\nSimilar a scale_*_date , porém ela lida com data e hora.\n\n\n6.5.5.9 Escalas de Localização X & Y\nAlgumas escalas alteram a estética dos eixos x e/ou y. O\n\n\n6.5.5.10 scale_*_log10\nUse para plotar o eixo x em escala de log10.\n\nc + geom_line(stat = \"count\")+\n  scale_y_log10()\n\n\n\n\n\n\n6.5.5.11 scale_*_reverse\nUse para inverter a ordem da escala.\n\nc + geom_line(stat = \"count\")+\n  scale_x_reverse()\n\n\n\n\n\n\n6.5.5.12 scale_*_sqrt\nUse para plotar o eixo x em escala quadrática.\n\nc + geom_area(stat = \"count\") +\n  scale_y_sqrt()\n\n\n\n\n\n\n6.5.5.13 Escalas de Cor e Preenchimento\nAs escala de cor (color e fill) possuem características semelhas, tanto para variáveis discretas quanto contínuas. A seguir, usar a cor de preenchimento com funções scale_fill_*, porém as mesmas características estão disponíveis para as funções scale_color_* .\nVariáveis Discretas\n\n\n6.5.5.14 scale_fill_brewer\nUse esta escala de cores para aplicar paletas qualitativas nas cores. As paletas são provenientes do pacote RColorBrewer. Este pacotes possui paletas para cores sequenciais, divergentes e qualitativas.\nPara ver as paletas disponíveis use:\n\nRColorBrewer::display.brewer.all(type = \"qual\")\nRColorBrewer::display.brewer.all(type = \"seq\")\nRColorBrewer::display.brewer.all(type = \"div\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara visualizar apenas as paletas amigáveis à pessoas com sensíveis à diferenciação de cores (colorblind), usa o parametro colorblindFriendly = TRUE\n\n\n\nn + scale_fill_brewer(palette = \"Blues\")\n\n\n\n\n\n\n6.5.5.15 scale_fill_grey\nUse para gerar escalas de cores em diferentes níveis de cinza, com valores de 0 até 1.\n\nn + scale_fill_grey (start = 0.2, end = 0.8)\n\n\n\n\nVariáveis Contínuas\nPara demonstrar algumas escalas de cores para variáveis contínuas, criaremos um objeto ggplot “o”, adicionando a estética de preenchimento para a mesma variável mapeada em na estética “x”.\n\no <- c + geom_dotplot(aes(fill = ..x..))\n\n\n\n6.5.5.16 scale_fill_distiller\nUse para extender as escalas “brewer” das variáveis discretas para variáveis contínuas, adicionando 7 outras cores por interpolação.\n\no + scale_fill_distiller(palette = \"Blues\")\n\n\n\n\n\n\n6.5.5.17 scale_fill_gradient\nUse para criar escalas de cores contínuas com gradiente de duas cores.\n\no + scale_fill_gradient(low=\"red\", high=\"yellow\")\n\n\n\n\n\n\n6.5.5.18 scale_fill_gradient2\nUse para criar escalas de cores contínuas com gradiente de três cores (início, meio e fim).\n\no + scale_fill_gradient2(low = \"red\", high = \"blue\",\nmid = \"white\", midpoint = 25)\n\n\n\n\n\n\n6.5.5.19 scale_fill_gradientn\nUse para criar escalas de cores contínuas com gradiente de múltiplas cores.\n\no + scale_fill_gradientn(colors = topo.colors(6))\n\n\n\n\nAlém da paleta topo.colors(), podemos ainda usar heat.colors(), terrain.colors, rainbow() e cm.colors() para criar um vetor de tamanho específico com cada elemento com uma cor seguindo o padrão de espaço de cores HSV.\nExemplo:\n\n#|layout-ncol: 2\n#|layout-nrow: 2\n\no + scale_fill_gradientn(colors = rainbow(6))\n\n\n\no + scale_fill_gradientn(colors = cm.colors(4))\n\n\n\no + scale_fill_gradientn(colors = heat.colors(3))\n\n\n\no + scale_fill_gradientn(colors = terrain.colors(4))\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPara criar novas paletas de cor, podemos usar a função RColorBrewer::brewer.pal()\n\n\n\n\n6.5.5.20 Escalas de Forma e Tamanho\nAssim como nas demais escala vistas até aqui, temos como definir escalar para forma e tamanho. Vamos criar um objeto “p” com um gráfico de pontos para ver os exemplos:\n\np <- e + geom_point(aes(shape=fl, size = cyl))\n\n\n\n6.5.5.21 scale_shape\nUse para controlar a escala da forma. Ela mapeia variáveis discretas em 6 formas facilmente identificáveis.\n\n\n\n\n\n\nImportante\n\n\n\nSe você tiver mais que 6 valores em sua variável discreta, uma mensagem de aviso iŕa aparecer e NÃO serão mostradas no gráfico. Use scale_shape_manual para fornecer seus próprios valores.\n\n\n\np + scale_shape()\n\n\n\n\n\n\n6.5.5.22 scale_size\nUse para alterar a escala de tamanho da área. Use scale_radius() para alterar o tamanho do raio. Veja no exemplo abaixo, que a variável “cyl” estava mapeada para a estética de tamanho (size) quando criamos o objeto “p”:\n\np <- e + geom_point(aes(shape=fl, size = cyl))\n\nCom isto, o ggplot entendeu que por ser uma variável numérica, deveria aplicar um distribuição contínua quando montou a distribuição de tamanho.\nJá no gráfico da direito, alteramos a escala do tamanho e definimos o número de quebras em 4, 5, 6 e 8 cilindros.\n\np + scale_size()\np + scale_size(breaks = c(4,5,6,8) )\n\n\n\n\n\n\n\n\n\n\n\nAepsar de não ser recomendados, mas apenas para carater ilustrativo, vemos que cyl é uma variável discreta, e portanto poderíamos ajustá-la como tal para que o ggplot automaticamente definisse uma escala de tamanho discreta. Veja o que acontece quando utilizamos as função as_factor() na estética de tamnho para a variável cyl.\n\np2 <- e + geom_point(aes(shape=fl, size = as_factor(cyl)))\n\n\n\n\n6.5.6 Sistema de Coordenadas\nApesar do sistema de coordenadas cartesiano ser o mais comum no mundo dos gráficos, o ggplot aferece uma série de outros sistemas, como coordenadas polares, maps ou até mesmo uma coordenada cartesiana invertendo o eixo x com o y. A seguir verremos alguns exemplos seguindo o modelo padrão, onde criaremos um objeto “r” com uma geometria de barras para iniciar e evitar repetição do código.\n\nr <- d + geom_bar()\n\n\n6.5.6.1 coord_cartesian\nUse para definir e configurar um sistema de coordenadas cartesiano. Este é o sistema padrão do ggplot.\n\nr + coord_cartesian(xlim = c(0,5))\n\n\n\n\n\n\n6.5.6.2 coord_fixed\nUse par criar um sistema de coordenada cartesiano com a proporção de aspecto entro os eixos x e y.\n\nr + coord_fixed(ratio = 1/8)\n\n\n\n\n\n\n6.5.6.3 coord_polar\nUse para mudar o sistema de coordenadas para polar.\n\nr + coord_polar(theta = \"x\", direction = 1)\n\n\n\n\n\n\n6.5.6.4 coord_trans\nUse para transformar as coordenadas cartesianas. Por exemplo, se quisermos alterar o eixo y, para que fique como raiz quadrada, faremos:\n\nr + coord_trans(y = \"sqrt\")\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nComo vimos anteriormente, poreriamos transformar a escala do eixo y atraves das funçoes scale_y*. A diferença e que a alteraçao na escala acontece ANTES das transformaçoes estatisticas enquanto as coordenadas ocorrem DEPOIS. Mudanças de coordenadas também alterar a forma das geometrias.\n\n\n\n\n\n6.5.7 Facetas\nO ggplot usa o conceito de “facetas” para dividir um gráfico em sub-gráficos com base em uma variável discreta.\nVamos crir um objeto “t” base para exemplificar o uso de facetas:\n\nt <- ggplot (mpg, aes(cty, hwy)) + geom_point()\n\n\n6.5.7.1 facet_grid\nUse para criar um grid de facetas:\n\nt + facet_grid(cols = vars(fl))\n\n\n\n\nNeste exemplo, criamos um gráfico, com vários sub-gráficos em colunas, usando a variável “fl” como separador das facetas.\nPodemos criar as facetas em linhas também:\n\nt + facet_grid(rows = vars(year))\n\n\n\n\nOu em um grid de linhas e colunas?:\n\nt + facet_grid(rows = vars(year), cols = vars(fl))\n\n\n\n\n\n\n6.5.7.2 facet_wrap\nUse para agrupar uma faixa de facetas em 2d.\n\nt + facet_wrap (vars(fl))\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPor padrão o ggplot irá usar a mesma escala do eixos para cada faceta. Podemos usar o argumento scales = pafra mudar este comportamento.\n\n\nVeja um exemplo:\n\nt + facet_grid(rows = vars(drv), cols = vars(fl), scales = \"free\")\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPodemos usar os argumento “free_x” e “free_y” para ajustar os limites dos respectivos eixos.\n\n\nPodemos também nomear cada faceta utilzando o argumento labeller =. Veja alguns exemplos:\n\nt + facet_grid(cols = vars(fl), labeller = label_both)\nt + facet_grid(rows = vars(fl),labeller = label_bquote(alpha ^ .(fl)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.8 Temas\nA camada de temas, permite uma customização final ao gráfico, permitindo ajustes nas propriedades dos eixos, legendas, painéis e facetas.\nO ggplot vem com alguns temas pré-definidos, mas você pode customizá-los de acordo com sua necessidade. A recomendação é que você parte de um tema que mais se aproxime da sua necessidade e mude os elementos faltantes. Veja alguns exemplo:\n\ntheme_bwtheme_graytheme_darktheme_classictheme_lighttheme_linedrawtheme_minimaltheme_void\n\n\n\nr + theme_bw()\n\n\n\n\n\n\n\nr + theme_gray()\n\n\n\n\n\n\n\nr + theme_dark()\n\n\n\n\n\n\n\nr + theme_classic()\n\n\n\n\n\n\n\nr + theme_light()\n\n\n\n\n\n\n\nr + theme_linedraw()\n\n\n\n\n\n\n\nr + theme_minimal()\n\n\n\n\n\n\n\nr + theme_void()\n\n\n\n\n\n\n\nDigamos que precisamos alinhar o título do gráfico com todo o gráfico. Neste caso, podemos usar o tema e ajusar o argumento plot.title.position =\n\nr + ggtitle(\"Titulo\")  \nr + ggtitle(\"Titulo\") + \n  theme(plot.title.position = \"plot\")\n\n\n\n\n\n\n\n\n\n\n\nOu digamos que precisamos alterar a cor de fundo do gráfico:\n\nr + theme(panel.background = element_rect(fill = \"lightblue\"))\n\n\n\n\nSão muitas as possibilidades de customização. Veja ?theme para todos os detalhes."
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#ajuste-de-posição",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#ajuste-de-posição",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.6 Ajuste de Posição",
    "text": "6.6 Ajuste de Posição\nEm alguns casos, precisamos alterar a posição de algumas geometrias que ocupariam o mesmo local no gráfico.\nEm geral, utilizamos o argumento “position =” nas geometrias para alterar a definição padrão.\nPara entender melhor a diferença dos tipos de posições mais comuns, vamos criar um objeto ggplot chamado “s” e comparar estes tipos:\n\ns <- ggplot(mpg, aes(fl, fill = drv))\n\n\n6.6.0.1 Position Stack\nUse para colocar as geometrias empilhada uma sobre a outra.\n\ns + geom_bar(position = \"stack\")\n\n\n\n\nPara a geometria de barras (geom_bar), esta é a posição padrão.\n\n\n6.6.0.2 Position Dodge\nUse para colocar as geometrias lado a lado.\n\ns + geom_bar(position = \"dodge\")\n\n\n\n\n\n\n6.6.0.3 Position Fill\nUse para colocar as geometrias empilhadas normalizando a altura.\n\ns + geom_bar(position = \"fill\")\n\n\n\n\n\n\n6.6.0.4 Position Jitter\nUse para adicoinar um mudança aleatória em X e Y para evitar sobreposição do pontos.\n\ne + geom_point(position = \"jitter\")\n\n\n\n\n\n\n6.6.0.5 Position Nudge\nUse para deslocar textos fora dos pontos.\n\ne + geom_text(aes(label = cty), position = position_nudge(1,2)) +\n  geom_point() +\n  scale_x_continuous(limits = c(25,40))\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nNeste caso, ao invés de usarmos a string “nudge” , usamos a função position_nudge para passar os parametros de deslocamento. As funções “position_* funcoinam para ajuster de forma mais refinada o posicionamento. Em geral aceitam os argumento de altura (width) e largura (height).\n\n\n\ns + geom_bar(position = position_dodge(width = 1))"
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#títulos-e-legendas",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#títulos-e-legendas",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.7 Títulos e Legendas",
    "text": "6.7 Títulos e Legendas\n\n6.7.0.1 labs\nPor ser muito comum termos que alterar os títulos dos elementos de um gráficos, o ggplot oferece a função labs().\nPodemos alterar o título do gráfico, o sub-título, o título de rodapé, o nome alternativo e uma estética (por exemplo, x ou y).\nVeja o exemplo no objeto “t” criado previamente.\n\nt + (aes (color = \"fl\")) +\n  labs(x = \"Texto do eixo X\", y = \"Texto do eixo Y\",\ntitle =\"Título geral do gráfico\",\nsubtitle = \"Sub-título do gráfico\",\ncaption = \"Texto de rodapé\",\nalt = \"Texto alternativo do gráfico para representação em texto\",\ncolor = \"Título da Legenda\")\n\n\n\n\n\n\n6.7.0.2 guides\nUse para definir os texto das guias. Guias são parte do gráfico que ajudam em sua interpretação. Por exemplo, a legenda é uma guia. As próprias marcas nos eixos são outro tipo de guias. As barras de tamanho ou forma, são outra forma de guias.\nPor exemplo, se quisermos alterar a posição das guias do eixo x a cada duas marcas, podemos fazer usando a função guide():\n\np + guides(x = guide_axis(n.dodge = 2))\n\n\n\n\nPara alterar o título da legenda da estética de tamanho (size) e colocá-la à direita da legenda, podemos fazer:\n\np + guides(size = guide_legend(title = \"Novo Título\", title.position = \"right\"))\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nPodemos também remover um determinada guia fazendo = “none”.\n\n\n\nn + guides(fill = \"none\")\n\n\n\n\n\n\n6.7.0.3 annotate\nUse para gerar alguma anotação no gráfico, criando uma camada adicional. Você pode criar uma anotação de qualquer geométria. No exemplo abaixo, usaremos a geometria de texto (text) e de reta (segment) para escrever o texto e a seta.\n\nt + annotate(geom = \"text\", \n             x = 34, y = 30, \n             label = \"Anotação\", \n             color = \"red\") +\n  \nannotate(geom = \"segment\",\n         x = 31, xend = 29, y = 32-2, yend = 34-2, \n         arrow = arrow(type = \"closed\", length = unit(0.02, \"npc\")),  \n         color = \"red\")\n\n\n\n\n\n\n6.7.0.4 theme\nPodemos também através do tema, definir a posição da legenda por exemplo:\n\nn + theme(legend.position = \"bottom\")\n\n\n\n\nPodemos definir também atraǘes da escala o título e os texto de cada item da estética. Por exemplo, para alterar a legenda do preenchimento atraveś da escala, podemos fazer:\n\nn +  scale_fill_discrete(name = \"Title\",\nlabels = c(\"A\", \"B\", \"C\", \"D\", \"E\"))"
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#zoom",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#zoom",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.8 Zoom",
    "text": "6.8 Zoom\nUse para dar um zoom no gráfico. Podemos fazer o zoom removendo os valores que não serão vistos no gráfico, ou mantendo-os (preferencial).\nZoom mantendo os pontos (preferencial):\n\nt\n\n\n\nt + coord_cartesian(xlim = c(0, 25), ylim = c(10, 20))\n\n\n\n\nZoom excluindo os pontos não visíveis:\nFazemos este zoom, definindo limites das escalas:\n\nt + xlim(0, 25) + ylim(10, 20)\n\n\n\n\nOu fazendo o equilavente de forma mais explícita:\n\nt + scale_x_continuous(limits = c(0, 25)) +\nscale_y_continuous(limits = c(10, 20))"
  },
  {
    "objectID": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#bônus",
    "href": "Visualizacao/Visualizacao_de_dados_com_ggplot2.html#bônus",
    "title": "6  Visualização de Dados com GGPLOT2",
    "section": "6.9 Bônus",
    "text": "6.9 Bônus\nComo vimos, há uma infinidade de possibilidades para criação de gráficos com o pacote ggplot, porém seus códigos podem se tornam com muitas linhas dado ao grau de customização que você precisa. Nossa recomendação é criar um gráfico com os ajustes nas principais camadas e depois uma função mais simplificada para chamar este código de forma repetida.\nA idéia não é esclarecer os detalhes de criação de funções no R, mas sim, dar um exemplo para otimizar o código criado para o ggplot.\nExemplo:\nVamos criar nosso gráfico inicial:\n\ng_barras <- \n  mpg |> \n  ggplot(aes(x = manufacturer, fill = class)) +\n    geom_bar() +\n    geom_text(stat = \"count\", \n              aes(label = ..count..), \n              position = position_stack(vjust = 0.5), \n              size = 3) +\n    scale_fill_brewer(type = \"qual\", \n                      palette = 2, \n                      direction = -1) +\n    labs(y = \"Quantidade\" ) +\n    guides(fill = guide_legend(nrow = 3))  +\n    theme_grey() + \n    theme(legend.position = \"bottom\") +\n    theme(axis.text.x = element_text(angle = 90)) +\n    theme(panel.background = element_rect(fill = \"#E5F3F7\")) \n\nmaior_valor <- mpg |> \n  count(manufacturer, class, sort = TRUE) |> \n  slice_head(n = 1) #Identificamos o grupo com maior qtd\n\ng_barras + labs(\n    title = \"Exemplo de gráfico dinâmico com função\",\n    subtitle = paste0(maior_valor[[1]], \" / \", maior_valor[[2]], \" tem a maior qtd com \", maior_valor$n, \" unidades.\")) # Criamos um subtitulo para o grpo com maior Qtd dinamicamente.\n\n\n\n\nApós termos o gráfico com as customizações que desejamos, podemos criar uma função. Neste caso, ela irá receber apenas os dados, a variável do eixo x e de preenchimento.\n\n# Função para gerar o gráfico\ncria_grafico_barras <- function(dados, eixo_x, preenchimento) {\n  \n  g_barras <- \n    {{dados}} |> \n    ggplot(aes(x = {{eixo_x}}, fill = {{preenchimento}})) +\n    geom_bar() +\n    geom_text(stat = \"count\", \n              aes(label = ..count..), \n              position = position_stack(vjust = 0.5), size = 3) +\n    scale_fill_brewer(type = \"qual\", \n                      palette = 2, \n                      direction = -1) +\n    labs(y = \"Quantidade\" ) +\n    guides(fill = guide_legend(nrow = 3))  +\n    theme_grey() + \n    theme(legend.position = \"bottom\") +\n    theme(axis.text.x = element_text(angle = 90)) +\n    theme(panel.background = element_rect(fill = \"#E5F3F7\"))\n\nmaior_valor <- {{dados}} |> \n  count({{eixo_x}}, {{preenchimento}} , sort = TRUE) |> \n  slice_head(n = 1)\n\ng_barras <- \n  g_barras + labs(\n    title = \"Exemplo de gráfico dinâmico com função\",\n    subtitle = paste0(maior_valor[[1]], \" / \", maior_valor[[2]], \" tem a maior qtd com \", maior_valor$n, \" unidades.\"))\n\n\nreturn(g_barras)\n\n}\n\nAgora podemos usar a função com as mesmas ou outras variáveis. Apenas devemos observer o tipo das variáveis. Se sua função cria gráfico com variáveis discretas, ela pode não funcionar devidamente se’ passar variável contínua. Talvez você possa criar outra função, ou deixá-la mais “inteligente”.\n\n#Usando a função criada.\nmpg |> \ncria_grafico_barras(manufacturer, class)\n\n\n\n\n\n#Usando a função criada om outros parametros.\n\nmpg |> \n  mutate (year = as_factor(year)) |>  #Alterando a variável year para factor antes para torná-la discreta.\n  cria_grafico_barras(class, year)\n\n\n\n\n\n\n\n\nFávero, Belfiore, Luiz P. 2021. «Manual de Análise de Dados». Comput. J., dezembro."
  }
]