# Visualização de Dados com GGPLOT2

## Introdução

A seguir temos vários exemplos de visualização de dados utilizando o pacote GGPLOT2 do R. Este é um pacote muito flexível para gerar diversos tipos de gráficos.

::: callout-note
Apesar de visualização de dados não ser especificamente parte das etapas de transformação e manipulação de dados, acreditamos ser importante um conhecimento básico sobre o tema, pois muitas vezes, para explicarmos aquilo que estamos transformando ou manipulando, o fazemos de forma gráfica para melhor compreensão.

O objetivo não é explicar a aplicabilidade e/ou o a função de cada gráfico, mas sim, como ele pode ser construído.
:::

Para saber mais sobre este pacote, acesse:

[https://cran.r-project.org/package=ggplot2](https://cran.r-project.org/package=stringr){.uri}.

::: callout-warning
Para melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:

<https://education.rstudio.com/learn/beginner/>.
:::

Para os exemplos, iremos carregar os seguintes pacotes:

-   **tidyverse**

-   **gt**

```{r}
#| echo: true
library (tidyverse)
library (gt)
```

### Exemplos da Folha de Referência

A maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na [**Folha de Referência**](https://github.com/scopinho/R-cheatsheets/blob/main/translations/portuguese/data-visualization_pt.pdf) do stringr disponível no site do [RStudio](rstudio.com).

[![](images/cs-ggplot-01.png)](images/cs-ggplot-01.png)

[![](images/cs-ggplot-02.png)](images/cs-ggplot-02.png)

------------------------------------------------------------------------

#### Variáveis Discretas e Contínuas no GGPLOT

O ggplot2, em geral irá associar as variáveis **caractere** (char) e **fatores** (factors) em escalas **discretas** de forma automática. Já as variáveis **numéricas,** o ggplot irá associar automaticamente com escalas **contínuas**.

Você verá nas seções seguintes este tipo de segregação, ou seja, um gráfico para variáveis discretas, contínuas ou um mix de ambas e assim por diante.

::: callout-important
Quando tivermos variáveis que não seguem este padrão, devemos "transformá-las, usando funções como as_factor(), as.integer(), as.double, etc.

Por exemplo, para representar uma variável que é do tipo inteiro, porém é discreta, deveremos antes alterá-la para um fator antes de submeter ao ggplot preferencialmente.
:::

## Gramática dos Gráficos

O pacote ggplot2 é uma implementação do livro "***Grammar of Graphics***", que apresenta um conceito de quais seriam os elementos de um gráfico e suas interconexões. O modelo teórico proposto no livro é que através de camadas definidas qualquer gráfico pode ser construído. Abaixo o modelo, que deve ser interpretado de baixo para cima.

![](images/grammar-01.jpg){width="354"}

De uma forma bem resumida, a idéia é que você possa construir minimamente qualquer gráfico com base nestes mesmos elementos: um **conjunto de dados**, um **sistema de coordenadas** e **geometrias**, que seriam marcas visuais que representas os pontos dos dados.

![](images/ggplot-01.jpg){width="475"}

No caso do ggplot2, para mostrar valores no gráfico, as varíaveis do conjunto de dados podem ser **mapeadas** em propriedadas visuais da geometria (geom).

Este mapeamento de estética (aesthetic) é feito através da função aes() e podemos fazer mapeamentos estéticos como cor, tamanho, forma, etc.

![](images/ggplot-02.jpg){width="475"}

## Modelo para Construção de um Gráfico

No caso do ggplot2, podemos definir uma espécie de modelo (template) para a sintaxe de construção de gráficos:

![](images/ggplot_template-01.jpg){width="556"}

Vejamos a seguir uma introdução ao uso do modelo visto acima:

------------------------------------------------------------------------

#### ggplot

A função ggplot() inicia um gráfico que será completado com as camadas adicionadas na sequência, como uma geometria, um sistema de coordenada ou até um tema.

Usando o modelo acima, vamos gerar nosso primeiro gráfico.

Como base de dados usaremos a tabela **mtcars**. Para maiores informação sobre as **variáveis** (colunas) e **observações** (linhas) do mtcars, digite ?mtcars.

```{r}

mtcars
```

```{r}
ggplot(data = mtcars) +
  geom_point (mapping = aes(x = hp, y = mpg ))
```

::: callout-note
Observe que mesmo sem definirmos escalas, temas, transformações estatísticas ou outras camadas, o gráfico ainda assim foi gerado.

Isto acontece porque o ggplot tem valores padrões dinâmicos que tentam prover o melhor resultado possível com o mínimo de esforço.
:::

::: callout-tip
A definição da estética com seu mapeamento, feito neste exemplo na função de geometria (geom_point) poderá ser feito também na função ggplot().
:::

Apesar do gráfico final ser similar, a estética mapeamento poderá ser utilizada pelas funções geom\_\*() nas camadas seguintes, sem a necessidade de repetí-la, caso contrário, ela será restrito apenas àquela geom() na qual foi declarada. Veja:

```{r}
ggplot(data = mtcars, mapping = aes(x = hp, y = mpg))+
  geom_point()
```

Por ser comum o uso do argumento data = e mapping =, podemos excluídas do código, deixando-o mais enxuto, porém mais difícil para quem não tem tanta familiaridade, veja:

```{r}
ggplot(mtcars,aes(x = hp, y = mpg)) +
  geom_point()
```

#### last_plot

Use para retornar o último gráfico gerado.

```{r}
last_plot()
```

#### ggsave

Use para salvar o gráfico em uma imagem. O tipo de imagem é selecionado pela extensão do arquivo de saída.

Por exemplo, para salvar o diretório atual um arquivo com o gráfico chamado "plot-01.png" com o formato de imagem ".PNG" de tamanho 5x5 centímetros, fazemos:

```{r}
ggsave("plot-01.png", width = 5, height = 5, units = "cm")
```

## Camadas

### Introdução

A seguir iremos apresentar as principais camadas do ggplot e suas principais funções.

::: callout-note
Para a camada de **dados**, o ggplot aceitará qualquer conjunto de dados (data frame). Para facilitar a criação do gráfico recomenda-se que os dados já estejam organizados (**tidy**) com observações em linhas e variáveis em colunas.
:::

-   Estéticas

-   Geometrias

-   Estatísticas

-   Escalas

-   Coordenadas

-   Facetas

-   Tema

### Estéticas

Podemos mapear a estética de uma camada à variáveis presentes em nossa camada de dados até definí-las manualmente. Se não especificarmos de forma explícita, o ggplot tentará assumir valores padrões que serão usados por determinada função outras camadas, como a de geometria ou de estatística.

Existem estéticas que são comuns a quase todas as camadas, como **cor**, **forma**, **tamanho**, etc.

A estética é vinculada à uma variável através da função ***aes***(). É comum, apesar de não ser mandatório para todas as estéticas, que determinemos os valores para x e y.

A seguir veremos algumas delas:

#### color e fill

Use para definir a **cor** (color) ou **preenchimento** (fill) para a estética.

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg, color = "red"))
```

No exemplo acima, definimos que a estética "**x**", assumirá valores provenientes da variável que existe em nossos dados chamada "**hp**". Já a estética "**y**", assumirá valores provenientes da variável "**mpg**".

Já a estética "color" assumirá o valor constante "red". Na string de color =, podemos usar valores de cores em inglês, como "red" ou "blue", ou também códigos RGB, como ""#00ABFF" ou "FF00AA".

::: callout-important
Observe que o valor definido da cor, foi dentro dos parênteses da função aes(), ou seja, ela está fazendo o mapeamento da estética cor (color) com os dados. Se utilizarmos o argumento color = da função geom_point(),estaremos definindo um valor fora do mapeamento.
:::

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg) , color = "red")
```

Apesar do resultado ser similar, observe que no exemplo anterior tivemos color como um mapeamento da estética, como definimos o valor fixo com a cor "red", seria como tivessemos em nossos dados uma coluna onde todas as linhas tivessem o valor "red". Já no exemplo acima, estamos simplemente dizendo à função da geometria que queremos a cor vermelha para ela.

Vejamos um outro exemplo para que fique claro este ponto.

Vamos gerar o mesmo gráfico onde colocamos "red" como parte da estética, porém agora, iremos mapeá-la com a coluna "qsec" de nossos dados mtcars:

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg, color = qsec))
```

Observe que neste caso a estética de cor foi mapeada com a variável qsec. Por se tratar de uma variável contínua, o ggplot escolheu autometicamente uma sequência de cores, neste caso do azul claro para o azul escuro, para representar este tipo de variável. Veremos mais adiante como customizar esta e outras escolhar automáticas feitas nas escalas.

#### linetype

Use para definir a linha utilizada no gráfico. Podemos utilizar um número de 0 a 6 ou um nome:

*(0 = "blank", 1 = "solid", 2 = "dashed", 3 = "dotted", 4 = "dotdash", 5 = "longdash",6 = "twodash")*

Por exemplo, ao invés de utilizarmos a geometria de pontos (geom_point), vamos utilzar a geometria de linha (geom_line):

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg) , linetype = "dotted")
```

#### size

Use para definir o tamanho, no caso de uma linha em "mm".

Como dito anteriormente, estes valores são comuns para vários geometrias. Por exemplo, podemos utilizar o argumento size também na geometria de pontos (geom_point):

```{r}
#| layout-ncol: 2

ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), size = 5)

ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), size = 5)
```

#### lineend

Use para definir o terminador da linha. Os valores podem ser: *round*, *butt* e *square*.

::: panel-tabset
## squared

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "square", size = 4)
```

## butt

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "butt", size = 4)
```

## round

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "round", size = 4)
```
:::

#### linejoin

Use para definir a junção da linha. Os valores podem ser: *round*, *mitre* e *bevel*.

::: panel-tabset
## round

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "round", size = 4)
```

## mitre

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "mitre", size = 4)
```

## bevel

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "bevel", size = 4)
```
:::

#### shape

Use para definir a forma. Podemos passar um número ou um nome em inglês da forma conforme abaixo:

![](images/aes_shape-01.jpg)

```{r}
#| layout-ncol: 2 

ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), shape = "square cross",  size = 3)
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), shape = 5, size = 3)
```

### Geometrias {#geometrias-geoms}

O ggplot nos permite selecionar para o mesmo gráfico uma ou mais formas geométrias. Por exemplo, eu posso ter o mesmo gráfico final, mas ao invés de ter pontos representando os dados, podemos ter barras e assim por diante.

::: callout-warning
Lembre-se que cada função retornará uma camada, portanto, a ordem de criação das camadas afeta o resultado do gráfico, pois uma será criada sobre a anterior.
:::

#### **Gráficos Primitivos**

Para os exemplos a seguir, utilizaremos duas bases de dados, uma chamada **economics** e outra chamada **seals**.

::: panel-tabset
## Economics

```{r}
economics
```

## Seals

```{r}
seals
```
:::

Para simplificar o código dos próximos exemplos, iremos criar dois objetos gráfico do ggplot:

O primeiro chamado "**a**", irá conter um objeto ggplot com os dados de **economics**, mapeando a estética de **x** para a variável "**date**" e **y** para a variável "**unemployed**".

O segundo chamado "**b**", irá conter um objeto ggplot com os dados de **seals**, mapeando a estética de **x** para a **variável** "**long**" e **y** para a variável "**lat**".

Desta forma trabalharemos com os mesmos objetos base e adicionaremos apenas novas camadas utilizando o operador "**+**" a fim de identificar os detalhes das diversas funções de geometria e não precisarmos repetir o código das camadas iniciais do gráfico.

```{r}
a <- ggplot(economics, aes(date, unemploy))
b <- ggplot(seals, aes(x = long, y = lat))
```

::: callout-note
Para simplificar o código, em algum momentos podemos omitir o argumento, como data=, mapping = , x = , y = . Isto porque já estamos os valores na ordem que a função nos pede.
:::

Agora com os objetos inicialmente criados, iremos adicionar novas camadas afim de obtermos os gráficos e entendermos algumas das funções de geometria para gráficos primitivos.

#### geom_blank

Use para garantir limites para todos os gráficos de acordo com os dados.

```{r}
a + geom_blank()
```

::: callout-tip
Use a função **expand_limits**() para expandir os limites do gráfico usando dados. Ver ?expand_limits para mais detalhes.
:::

#### geom_curve

Use para criar curvas.

```{r}
b + geom_curve(aes(yend = lat + 1, xend = long + 1), curvature = 1)
```

#### geom_path

Use para conectar observações.

```{r}
a + geom_path(lineend = "butt", linejoin = "round", linemitre = 1)
```

#### geom_polygon

Use para criar poligonos. É similar a geom_path(), porém a parte interna é preenchida com argumento fill =.

```{r}
a + geom_polygon(aes(alpha = 50))
```

::: callout-note
O argumento alpha = , é muito comum na definição de cores. De maneira simplificada, ele indica o nível de transparência de uma cor, sendo 0, nenhuma transparência e 1 transparência total.
:::

#### geom_rect

Use para criar retângulos.

```{r}
b + geom_rect(aes(xmin = long, ymin = lat,
xmax = long + 1, ymax = lat + 1))
```

::: callout-note
A função **geom_title()** fazem a mesma coisa, porém são parametrizadas de forma diferente. A geom_rect usa a localização dos 4 cantos do quadrado, enquanto a geom_tile usa o centro e seu tamanho (largura e altura) para dimensionar.
:::

#### geom_ribbon

Use para criar uma "fita". Para cada valor de x, ela mostra um intervalo y, definido por ymin e ymax. Veja que geom_area() é um caso especial do geom_ribbon(), onde o ymin é fixo em 0 e y é usado no lugar de ymax.

```{r}
a + geom_ribbon (aes(ymin = unemploy - 900,
ymax = unemploy + 900))
```

#### **Segmentos de Linhas**

Estas funções de geometrias, permitem criar diversos tipo de segmentos de linha e são úteis quando precisamos "marcar" ou definir algo no gráfico, com linhas verticais ou horizontais por exemplo.

#### geom_abline

Use para criar uma linha de um ponto "a" até um ponto "b", passando o intercepto e a inclinação da reta.

```{r}
b +  geom_abline(aes(intercept = 0, slope = 1))
```

#### geom_hline

Use para criar uma ou mais linhas horizontais.

```{r}
b + geom_hline(aes(yintercept = lat))
```

Veja que no exemplo anterior, fizemos o mapeamento do argumento yintercept como parte da estética (aes), mapeando este argumento com a variável "lat" de nossos dados.

Se quisermos simplesmente traçar uma linha com o intercepto do eixo y, correspondendo ao valor 40 (por exemplo, se fosse um tipo de meta), podemos definir este valor fora do mapeamento:

```{r}
b + geom_hline(yintercept = 40)
```

#### geom_vline

Use para criar uma ou mais linhas horizontais.

```{r}
b + geom_vline(aes(xintercept = long))
```

#### geom_segment

É similar ao geom_curve, porém ao invés de criar uma curva, criar um segmento de reta.

```{r}
b + geom_segment(aes(yend = lat + 1, xend = long + 1))
```

#### geom_spoke

Use para criar um segmento, parametrizado pela localização, direção e distância.

```{r}
b + geom_spoke(aes(angle = 1:1155, radius = 1))
```

#### **Uma Variável Contínua**

Quando precisamos analisar um varíavel contínua, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto "**c**" e outro "**c2**", aos quais iremos adicionar novas camadas. Similar ao que fizemos anteriormente, porém agora utilizaremos a base de dados "**mpg**".

```{r}
mpg
```

Criando os objetos ggplot:

```{r}
c <- ggplot(mpg, aes(hwy))
c2 <- ggplot(mpg)
```

::: callout-important
Observe que o objeto "**c**", usa a base "mpg" **já atribuindo a variável "hwy" para x= da estética**. Esta configuração será aplicada para qualquer funções geom\_\*() a não ser que explicitamente tenhamos uma estética redefinindo isso dentro de outra camanda de geometria.

Já para o objeto "**c2**", **não temos a estética** de x definida, portanto, teremos que definí-la em nas próximas camadas com a funções de geometria (geom\_\*()).
:::

#### geom_histogram

Use para criar histogramas, ou seja, uma forma de visualizar uma variável contínua dividindo no eixo x em classes e contando o número de observações de cada classe no eixo y.

O argumento binwidth = define o tamanho das classes.

No exemplo a seguir, dividimos a variável contínua de consumo por rodagem (hwy) em classes com 2 observações cada.

```{r}
c + geom_histogram(binwidth = 2) 
```

Se desejar definir o número de classes ao invés de quantas observações terão cada classe, utilize o argumento bins =.

```{r}
c + geom_histogram(bins = 16) 
```

#### geom_freqpoly

Use para gerar um gráfico de polígonos de frequência. Enquanto o histograma gera um gráfico de barras, esta geometria gera uma linha.

```{r}
c + geom_freqpoly(bins = 30)
```

#### geom_area

Use para criar um gráfico de área, onde para cada valor no eixo x, há um valor y máximo e o valor de y mínimo é sempre zero.

::: callout-note
Você verá um argument (stat = "bin") abaixo. Veremos as **estatísticas** na seção [ESTATÍSTICAS (STATS)](#estatísticas-stats). Por hora, pense apenas que é uma forma de definirmos os valores que iremos mostrar para o eixo y. Por padrão o número de agrupamento (bin) é 30.
:::

```{r}
c + geom_area(stat = "bin", bins = 32)
```

#### geom_density

Use para fazer um gráfico de **densidade**. Usando funções de estimativa de densidade de kernel, seria uma versão mais "arredondada" do histogram, mostrando a função densidade de **probabilidade** da variável.

Há a possibilidade de configurar vários kernels das funções de densidade, como "gaussian", "rectangular", "triangular", "epanechnikov", "biweight", "cosine" ou "optcosine".

```{r}
c + geom_density(kernel = "gaussian")
```

::: callout-tip
Veja que podemos criar duas geometrias, uma com o histograma e outra de densidade sobrepostas. Para isto temos que sobreescrever a estética definida previamente para o eixo y (antes era count) usando ..density..
:::

```{r}
c + geom_histogram(aes(y = ..density..)) +
  geom_density()
```

#### geom_dotplot

Use para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.

```{r}
c + geom_dotplot() 
```

#### geom_qq

Use para criar um gráfico de quantil-quantil. Em geral utilizado para confirmar se uma variável tem uma distribuição gaussiana.

```{r}
c2 + geom_qq(aes(sample = hwy))
```

#### **Uma Variável Discreta**

Quando precisamos analisar um varíavel discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**d**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente usando a base de dados **mpg**. Utilizaremos a variável combustível (fl).

```{r}
d <- ggplot(mpg, aes(fl))
```

#### geom_bar

Use para criar um gráfico de barras.

```{r}
d + geom_bar()
```

Veja outro exemplo: Como aconteceu com o combustível (fl), podemos pegar a variável tipo da classe do veículo (class) e gerar um gráfico de barras também.

```{r}
d + geom_bar(aes(x = class))
```

Usando o argumento da estética para cor do preenchimento (fill), podemos mapear uma variável igual ou diferente. Com isto, o ggplot automaticamente criará uma legenda para os diferentes valores da varíavel. Veja o que acontece quando temos x=fl e fill = class:

```{r}
d + geom_bar(aes(fill =class))
```

Note que como a estética herdada do objeto ggplot base (d) tinha o mapeamento de x para a variável combustível (fl), ela ainda permanece no eixo x.

Se sobrescrevermos este mapeamento para a estética do geom_bar com a mesma variável para x e fill, teremos:

```{r}
d + geom_bar (aes(x = class, fill = class)) 
```

Note que o resultado automático do gráfico foi um pouco diferente. Quando tivemos x = fl e fill = class as barras foram **empilhadas** (stack) e quando tivemos x = class e fill = class, as barras foram lado colocadas **lado a lado** (dogde).

Por padrão, o ggplot, quando múltiplas barras ocupam o mesmo ponto, elas são empilhadas. Este comportamento pode ser definido através do argumento **position =** .

Veja as diferentes opções:

::: panel-tabset
## dodge

```{r}
d + geom_bar(aes(fill =class), position = "dodge")
```

## dodge2

```{r}
d + geom_bar(aes(fill =class), position = "dodge2")
```

## stack

```{r}
d + geom_bar(aes(fill = class) , position = "stack")
```

## fill

```{r}

d + geom_bar(aes(fill =class), position = "fill")
```
:::

::: callout-tip
As geometrias podem ter valores calculados autometicamente "computed variables". Isto é para faciliar a geração dos gráficos com valores padrões. No caso da geom_bar, não precisamos passar que no eixo y gostaríamos de ter a contagem da variável que está no eixo x. Veja que então, a variável y não ficou sem um valor, ele apenas foi substituído pela contagem (count) automaticamente. A geom_bar tem "count" e "prop" como varíveis computadas.

Para saber quais varíaveis são computadas automaticamente para cada geometria, veja a ajuda com ?geom_bar.
:::

#### **Duas Variáveis Discretas**

Quando precisamos analisar um duas varáveis discretas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**g**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **diamonds**. Utilizaremos as variáveis corte (cut) e cor (color).

```{r}
g <- ggplot(diamonds, aes(cut, color))
```

#### geom_count

Esta é uma variante do geom_point() que conta o número de observação em cada localização e então mapeia a contagem na área do ponto.

```{r}
g + geom_count()

```

#### geom_jitter

É similar ao geom_point, porém adiciona uma variação aleatória em cada ponto.

```{r}
g + geom_jitter(height = 2, width = 2)
```

Como várias outras geometrias, podemos adicionar uma cor na estética do geom_jitter, mapeando outra váriável, como por exemplo o corte (cut) para facilitar a visualização:

```{r}
g + geom_jitter(aes(color = cut), height = 2, width = 2)
```

#### **Uma Variável Contínua e Outra Discreta**

Quando precisamos analisar uma varável contínua e outra discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**f**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg**. Utilizaremos as variáveis classe (class) e consumo na estrada (hwy).

```{r}
f <- ggplot(mpg, aes(class, hwy))
```

#### geom_col

Use para criar um gráfico de colunas. Ele é similar ao gráfico de barras, porém agora, no eixo y, teremos uma variável contínua. Observe que enquanto no geom_bar, o eixo y é calculado automaticamente, aqui na geom_col, você precisa ter a variável já nos seus dados.

```{r}
f + geom_col()
```

Assim, como no geom_bar, podemos definir a cor de preenchimento da estética para geom_col, usando fill =.

Vamos usar a variável de número de cilindros (cyl) como exemplo.

```{r}
f + geom_col(aes(fill = cyl))
```

::: callout-warning
Veja que no caso acima, o ggplot tentou automaticamente ajustar a escala de cores para uma escala contínua. Dá a impressão que temos veículos com 7 cilindros inclusive.
:::

Isto é porque em nossos dados, a variável "cyl" é do tipo inteiro (integer) e com isto, o ggplot2 entende como um variável contínua.

Para obter o efeito pretendido, temos algumas opções. Uma seria mudar a variável cyl para o tipo fator (factor) usando a função as_factor(). Veja:

```{r}
f + geom_col(aes(fill = as_factor(cyl)))
```

Por padrão, as classes são colocadas de forma empilhada, similar ao que vimos na [geom_bar]. Se quisermos colocadas lado a lado, devemos fazer:

```{r}
f + geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = "dodge")
```

::: callout-tip
A largura das colunas é expandida automaticamente, pois não temos valores para todas as combinações. Por exemplo, não temos 8 cilindros em carros compatos. Há formas difrentes de ajutar isso, uma delas é ajustar a base de dados, criando as combinações possíveis utilização a função tidyr::**complete**()
:::

```{r}
complete(mpg, class, cyl) |> ggplot () +
  geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = "dodge")
```

#### geom_boxplot

Use para criar um gráfico boxplot (box e whiskers). Este gráfico é bastante interessante, pois mostra cinco estatísticas automaticamente (a mediana, primeiro e terceiro quartis e os limites max e min) e os pontos fora da curva individualmente (outlyers).

Para este exemplo, iremos além de definir uma cor de preenchimento através do argumento fill = , iremos remover a legenda desta camada usando show.legend = FALSE.\

```{r}
f + geom_boxplot(aes(fill = factor(class)), show.legend = FALSE)
```

Para mostrar a média ao invés da media, podemos fazer:

```{r}
#| eval: false
f + geom_boxplot(aes(middle = mean(hwy)))
```

#### geom_dotplot

Use para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.

```{r}
f + geom_dotplot(aes(color = class),binaxis = "y", stackdir = "center")
```

#### geom_violin

Use para criar um gráfico de violino. Ele mostra de forma compacta a distribuição de uma variável contínua.

```{r}
f + geom_violin(aes(fill = class), scale = "area")
```

#### **Duas Variáveis Contínuas**

Quando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**e**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg**. Utilizaremos as variáveis consumo na cidade (cty) e consumo na estrada (hwy).

```{r}
e <- ggplot(mpg, aes(cty, hwy))
```

#### geom_label

Use para adicionar uma camada de texto (labels) no gráfico. Ela pode ser utilizada sozinha como em gráficos de dispersão, mas é mais comum, usá-la em conjunto com outras geometrias. Por exemplo, colocar os valores acima de cada barra em um geom_bar(). Por padrão, o texto a ser adicionado, tem um retângulo atrás para facilitar a leitura.

O argumento nudge\_\* =, ajusta a posição casos textos estejam no mesmo ponto

```{r}
e + geom_label(aes(label = cty), nudge_x = 1, nudge_y = 1)
```

No exemplo acima, temos um gráfico com um texto em cada ponto de cruzamento entre a variável no eixo x e a correspondente no eixo y.

Veja um uso do geom_label em conjunto com outra geom.

**Exemplo 1:**

Neste caso, iremos sumarizar os dados e obtermos um tabela contendo cada classe e a soma do consumo na estrada (hwy). Depois criaremos uma geometria de colunas e adicionaremos uma camada com o texto.

::: panel-tabset
## geom_label

```{r}
dados <- mpg |> group_by(class) |> summarise(hwy = sum(hwy))

dados |> ggplot(aes(class, hwy, fill = class)) +
  geom_col() +
  geom_label(aes(label = hwy))
```

## dados

```{r}
dados
```
:::

::: callout-tip
Podemos utilizar o argumento position = e através da função position_stacked centralizar o ajuste vertical (vjust) para colocar o texto no centro da coluna e remover a camada da legenda:
:::

```{r}
dados |> 
  ggplot(aes(class, hwy, fill = class)) +
  geom_col() +
  geom_label(aes(label = hwy), 
             position = position_stack(vjust = 0.5),
             show.legend = FALSE)
```

**Exemplo 3:**

Neste exemplo, seguiremos uma outra abordagem. Vimos na seção da geom_bar que ela calcula automaticamente a contagem dos valores para o eixo y, ou seja, nós não tinhamos esta contagem em nossos dados e não queremos preparar um tabela resumida com fizemos no exemplo anterior. Neste caso, podemos utilzar esta estatística calculada usando o parametro stat.

Veremos mais detalhes sobre as estatisticas na seção [Estatísticas (stats)](#estatísticas-stats)

```{r}
ggplot(mpg, aes(x = fl, fill = fl))+
  geom_bar() + 
  geom_label(stat  = "count", 
             aes(label = paste0("Total = ", after_stat(count))),
             size = 2,
             show.legend = FALSE)
```

::: callout-note
Veja acima que podemos controlar o tamanho (size) e definirmos um string junto com a variável que colocamos no texto utilziando a função **paste0**().
:::

#### geom_point

Use para gerar um gráfico de pontos ou dispersão. Este tipo de gráfico é muito úteil quando queremos mostrar relações entre as duas variáveis contínuas. Apesar dele também poder ser usado para comparar uma contínua com uma discreta, as opções de geometria como geom_jitter ou geom_count são mais apropriadas.

```{r}
e + geom_point()
```

::: callout-tip
Um gráfico de bolhas (bubblechart) é um gráfico de pontos com uma terceira variável associada ao tamanho dos pontos.
:::

```{r}
e + geom_point(aes(size = displ), alpha = 0.3)
```

#### geom_quantile

Use para criar um gráfico de quantis. Seria o equivalente contínuo do boxplot.

```{r}
e + geom_quantile()
```

Podemos definir quantis quantis queremos obter, por exemplo, se quisermos obter uma quebra de 5% , 50% e 95% podemos fazer:

```{r}
e + geom_quantile(quantiles = c(0.05, .5, 0.95))
```

#### geom_rug

Use para criar um gráfico de tapete (rug chart) com pequenas linhas para complementar uma visão 2Ds com duas visões de uma dimensão.

O argumento sides é uma string que controla onde os tapetes irão aparecer no gráfico: "trbl" = top, right, bottom e left.

```{r}
e + geom_rug(sides = "bl")
```

Fica interessante colocar uma camada adicional com geom_point para entender melhor o que acontece neste tipo de gráfico. Veja que as linhas do tapete ficam mais próximas quando temos mais concentração de pontos. Como este gráfico mostra todos os pontos, ele faz mais sentido com pequenos conjuntos de dados.

```{r}
e + geom_rug(sides = "bl") +
    geom_point()
```

#### geom_smooth

Use para ajudar a encontrar padrões na visualização quando há muitos dados sobrepostos.

```{r}
e + geom_smooth(method = "lm")
```

Você pode usá-lo para traçar linhas de tendência também.

```{r}
e + geom_point() +
    geom_smooth(method = "lm", se= FALSE)
```

#### geom_text

Use para criar uma geometria com textos. É similar ao geom_label, porém não tem um quadrado envolta do texto por padrão:

```{r}
e + geom_text(aes(label = cty), nudge_x = 1, nudge_y = 1)
```

Assim como aocntece no geom_label, podemos utilizar como camada adicional à outras geometrias. Veja:

```{r}
dados |> 
  ggplot(aes(class, hwy, fill = class)) +
  geom_col() +
  geom_text(aes(label = hwy), 
             position = position_stack(vjust = 0.5),
             show.legend = FALSE)
```

#### **Mapas de Calor e Densidade**

En alguns casos, precisamos mostrar como as duas variáveis contínuas se relacionam, dividindo o plano em retângulos e plotando os número de casos em cada retãngulo e preenchendo a cor de acordo com o número de casos. Para os exemplos a seguir, usaremos novamente a base "**diamonds**" em um objeto "**h**" .

```{r}
h <- ggplot(diamonds, aes(carat, price))
```

#### geom_bind2d

Use para gerar um mapa de calor com classe de contagem 2d. O gráfico é formado dividindo o plano em retângulos e plotando os número de casos em cada retangulo e preenchendo a cor de acordo com o número de casos.

```{r}
h + geom_bin2d(binwidth = c(0.25, 500))

```

#### geom_density_2d

Use para gerar um gráfico de contorno. É um gráfico de densidade (ver [geom_density]) só que para duas variáveis.

```{r}
h + geom_density_2d()
```

#### geom_hex

Use para gerar um mapa de calor hexagonal. O gráfico é formado dividindo o plano em hexagonos e plotando os número de casos em cada retangulo e preenchendo a cor de acordo com o número de casos.

```{r}
h + geom_hex(bins = 40)

```

#### **Duas Variáveis Discretas**

Quando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**g**" e "**e**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg e diamonds**. Utilizaremos as variáveis de mpg consumo na cidade (cty) e consumo na estrada (hwy) e de diamonds (cut e color).

```{r}
g <- ggplot(diamonds, aes(cut, color))
e <- ggplot(mpg, aes(cty, hwy))
```

#### geom_count

Esta geometria é uma variante da geom_point que conta o número de observações para cada localização do gráfico e então mapeia o número da contagem com cada ponto.

```{r}
g + geom_count()
```

#### geom_jitter

Use para criar um gráfico de pontos com o uma dispersão aleatória em cada ponto sobreescrito. É similar a escrever geom_point(position = "jitter").

```{r}
e + geom_jitter(height = 1, width = 1)
```

Para entender como esta dispersão aleatória funciona, compare uma geometria de pontos onde temos vaŕios pontos no mesmo local (sem a dispersão em vermelho) e com a dispersão (jitter).

```{r}
e +
  geom_jitter(alpha = 0.4, height = 1, width = 1) +
  geom_point(color = "red")
  
```

#### **Mapas**

O ggplot2 também pode gerar gráficos de mapas.

Para isso iremos criar um conjunto de dados à partir da base "**USArrests**", contendo onúmero de assassinatos por estado americano. Depois iremos usar usar a função **map_data**() para criar um data frame com as iformações para o mapa (latitude e longitude). Depois usaremos este data frame para a geometria de mapas (geom_map).

::: panel-tabset
## mapa

```{r}
data <- data.frame(murder = USArrests$Murder,
state = tolower(rownames(USArrests)))

map <- map_data("state")
k <- ggplot(data, aes(fill = murder))

k + geom_map(aes(map_id = state), map = map) +
    expand_limits(x = map$long, y = map$lat)

```

## data frame

```{r}
data
```

## data frame de mapa

```{r}
map
```
:::

Para uma utilização mais moderna e e precisa de gráficos geográficos/mapas, recomenda-se o uso de uma geometria chamada **geom_sf**. Ela é capaz de mapear objetos do tipo "**Simple Feature"** do pacote"**sf**" diretamento no ggplot2. Este é um assunto bastante complexo, mas apenas como carater ilustrativo, veja como seria o plot do estado de São Paulo.

```{r}
library (sf)

sp <- st_read(dsn = "shapefile_sp/estado_sp.shp")

ggplot (sp) +
  geom_sf(color = "Blue")
```

#### **Visualizando Erros**

Quando precisamos analisar intervalos verticais, com linhas, barras e barras de erros, podemos usar as seguintes geometrias abaix. Porém, como nas demais seções, iremos preparar nosso objeto básico para evitar repetição de código.

Agora teremos um objeto "**j**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base "**df**" que criaremos a seguir.

```{r}
df <- data.frame(grp = c("A", "B"), fit = 4:5, se = 1:2)
j <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))
```

Vamos entender como é a base de dados "df" criada.

```{r}
df
```

::: callout-note
A coluna "SE", significa "standard error" ou erro padrão.
:::

Já o objeto ggplot base que criamos tem a variável grp no eixo x, fit no eixo y. Também definimos o y-min como fit - se (erro padrão) e o ymax como fit + se.

```{r}
#| eval: false
j <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))
```

#### geom_crossbar

Use para criar uma barra no intervalo vertical. Esta função criará duas barras com um ponto central baseado em ymin, x e ymax. o argumento fatten = , é um fator multiplicador para o separador do meio.

```{r}
j + geom_crossbar(fatten = 5)
```

Veja que a distância do ponto central de A até seu limite de baixo é definido por fit + se em nossa tabela de dados e nosso objeto "j". O mesmo ocorre para o limite inferior.

#### geom_errorbar

Use para traçar barras de erro. Similar ao geom_crossbar, mas não mostra o ponto central ou as linhas laterais.

```{r}
j + geom_errorbar()
```

#### geom_linerange

Similar a geom_errorbar, mas sem as linha superior ou inferior.

```{r}
j + geom_linerange()
```

#### geom_pointrange

Similar à geom_linerange, porém monstrando o ponto central.

```{r}
j + geom_pointrange()
```

#### **Três Variáveis**

O ggplot não consegue criar gráficos 3D verdadeiros, porém permite visualizar superfícies 3D em 2 duas dimensões. Quando precisamos criar tais gráficos, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto "**l**" ao qual iremos adicionar novas camadas. Isto é similar ao que fizemos anteriormente, só que agora usando a base de dados **seals**. Faremos um ajuste, criando uma coluna "z", que será a raiz quadrada das somas dos quadrados de delta_long e delta_lat. Mapearemos nosso objeto ggplot base com x = long e y = lat:

```{r}
seals$z <- with(seals, sqrt(delta_long^2 + delta_lat^2))
l <- ggplot(seals, aes(long, lat))
```

#### geom_contour

```{r}
l + geom_contour(aes(z = z))
```

#### geom_contour_filled

```{r}
l + geom_contour_filled(aes(z = z, color = z))
```

#### geom_raster

```{r}
l + geom_raster(aes(fill = z), hjust = 0.5,
vjust = 0.5, interpolate = FALSE)
```

#### geom_tile

```{r}
l + geom_tile(aes(fill = z))
```

### Estatísticas {#estatísticas-stats}

Podemos dizer que as estatísticas, ou mais precisamente, uma transformação estatística, é uma maneira diferente de construirmos uma camada.

Assim como cada camada de geometria possui uma transformação estatística padrão, cada estatística possui uma geometria padrão.

A transformação estatística cria novas variáveis que não estavam presentes em nossos dados originais (ex: count, pop)

![](images/ggplot-03.jpg){width="412"}

Podemos visualizar uma transofrmação estatística mudando a estatística padrão de uma geometria (ex: **geom_bar(stat="count")** ou usando uma função stat() (ex: **stat_count(geom="bar")** que chama uma geometria padrão para criar uma camada.

::: callout-note
Podemos usar a sintaxe **..nome..** para mapear uma estatística em uma estética (aes()).
:::

Para ficar mais claro, vejamos o seguinte caso:

```{r}
#| eval: false
i + stat_density_2d(aes(fill = ..level..),
geom = "polygon")
```

Explicando com mais detalhes o exemplo acima, vemos que estamos uma adicionando uma camada no gráfico representado pela letra "i".

Depois estamos criando uma nova camada através da estatística "stat_density_2d". Esta função cria diversas variáveis calculadas automaticamente que podem ser acessadas por ..level.., e neste caso estamos atribuindo uma variável calculada ao mapeamento de preenchimento fill =.

Ao final, estamos forçando uma geometria "polygon" ou invés da geometria padrão desta função que seria "density_2d".

Veja o exemplo abaixo:

```{r}
#| layout-ncol: 2
mpg |> ggplot(aes(x = class, fill = class))+
  stat_count()

mpg |> ggplot(aes(x = class, color = class))+
  stat_count( geom = "point")
```

Neste caso, estamos criando no gráfico da esquerda, uma camada usando a função stat_count (que tem com padrão a geom="bar") e no gráfico da direita, estamos forçando uma geometria de pontos.

O mesmo poderia ser feito, utilizando a geometria e alterando a estatística padrão. Veja como seria:

```{r}
#| layout-ncol: 2
mpg |> ggplot(aes(x = class, fill = class))+
  geom_bar()

mpg |> ggplot(aes(x = class, color = class))+
  geom_point(stat = "count")
```

Veja que tivemos que alterar a estatística padrão apenas da geom_point. Isto porque a geom_bar, já possui a estatística "count" como padrão, já a geom_point, possui a estatística "identity" como padrão.

::: callout-important
A transformação estatística "**identity**", significa nenhuma transformação, ou seja, utiliza os dados que estão em nossa tabela original. É muito utilizada quando não queremos que alguma geometria faça o cálculo da transformação estatística para nós, mas sim, quando quisermos utilizar os dados já calculados em alguma coluna da tabela.
:::

A seguir teremos uma sequência, demonstrando a criação de diversas camadas utilizando as transformações estatísticas e suas respectiva geometrias padrão.

::: callout-tip
Para maiores detalhes dos argumentos, variáveis computadas e geometrias padrão, digite ?\<nome_função_estatística\> (ex: ?stat_count)
:::

#### stat_bin

#### stat_count

#### stat_density

```{r}
#| layout-ncol: 3
c + stat_bin(binwidth = 1, boundary = 10)
c + stat_count(width = 1)
c + stat_density(adjust = 1, kernel = "gaussian")
```

#### stat_bin_2d

#### stat_hex

#### stat_density_2d

#### stat_ellipse

```{r}
#| layout-ncol: 2
#| layout-nrow: 2
e + stat_bin_2d(bins = 30, drop = T)
e + stat_bin_hex(bins = 30)
e + stat_density_2d(contour = TRUE, n = 100)
e + stat_ellipse(level = 0.95, segments = 51, type = "t")
```

#### stat_contour

#### stat_summary_hex

#### stat_summary_2d

#### stat_boxplot

#### sta_ydensity

```{r}
#| layout-ncol: 3
#| layout-nrow: 2

l + stat_contour(aes(z = z))
l + stat_summary_hex(aes(z = z), bins = 30, fun = max)
l + stat_summary_2d(aes(z = z), bins = 30, fun = mean)
f + stat_boxplot(coef = 1.5)
f + stat_ydensity(kernel = "gaussian", scale = "area")
```

#### stat_ecdf

#### stat_quantile

#### stat_smooth

```{r}
#| layout-ncol: 3

e + stat_ecdf(n = 40)

e + stat_quantile(quantiles = c(0.1, 0.9),
formula = y ~ log(x), method = "rq")

e + stat_smooth(method = "lm", formula = y ~ x, se = T,
level = 0.95)

```

#### stat_function

#### stat_qq

#### stat_sum

#### stat_summary

#### stat_identity

#### stat_unique

```{r}
#| layout-ncol: 3
#| layout-nrow: 3
ggplot() + xlim(-5, 5) + 
  stat_function(fun = dnorm, n = 20, geom = "point")

ggplot() + stat_qq(aes(sample = 1:100))

e + stat_sum()

e + stat_summary(fun.data = "mean_cl_boot")

h + stat_summary_bin(fun = "mean", geom = "bar")

e + stat_identity()

e + stat_unique()

```

### Escalas

As escalas mapeiam os valores dos dados em um valor visual de uma estética. Quando criamos uma gráfico, o ggplot adiciona escala para cada mapeamento de forma automática. Mas é possível alterar as escalas padrão.

Vejamos o gráfico abaixo:

```{r}
d + geom_bar()
```

Quando escrevemos o código acima, o ggplot identifica que a variável x é do tipo discreta (categórica) e cria uma escala para ela. Faz o mesmo o o count do eixo y. Portanto, se sobrescrevermos as configurações da escala do eixo x para uma escala discreta, não haverá mudanças.

```{r}
d + geom_bar()+
  scale_x_discrete()
```

No examplo a seguir, iremos sobrescrever a escala de preenchimento (fill) para um tipo manual, ou seja, onde iremos manualmente definir as cores de preenchimento, ou limites da escala (de onde até onde ela valerá) e os pontos de parada, seu nome e os títulos (labels). Veja como ficaria:

```{r}
n <- d + geom_bar(aes(fill = fl))

n + scale_fill_manual(
values = c("skyblue", "royalblue", "blue", "navy"),
limits = c("d", "e", "p", "r"), breaks =c("d", "e", "p", "r"),
name = "fuel", labels = c("D", "E", "P", "R"))
```

::: callout-note
Lembre-se que já existe uma configuração de escala par o eixo x criada por padrão. Quando estamos sobrescrevendo com novos valores, se estes valores não sobrepoem os antigos, os valore anteriores ficam valendo. Por isso, a cor não foi alterada para o combustível (fl = c), já que deinifmos os limites da nova escala apenas para (d, e, p , r).
:::

#### **Escalas de Propósito Geral**

Estas escalas são usadas na maioria das estéticas para mapear valores para os eixos x e y, preenchimento, cores, tipos de linhas, etc.

#### scale\_\*\_continuous

Use par mapear valores contínuos para os valores visuais.

Por exemplo, vamos , ver a diferença entre a escala padrão definida para a variável "count" e outra sobrescrevendo a escala e deixando-a de forma reversa.

```{r}
#| layout-ncol: 2

#Com escala padrão contínua para hwy.
c + geom_line(stat = "count") +
  scale_x_continuous()

#Alterando o argumento trans = para inverter a escala.
c + geom_line(stat = "count") +
  scale_x_continuous(trans = "reverse")
```

#### scale\_\*\_discrete

Similar a scale\_\*\_continuous porém para variáveis discretas.

Por exemplo:

```{r}
  d + geom_bar() +
    scale_y_discrete(name = "Número de observações")
```

#### scale\_\*\_binned

Use para deixar discreta um variável contínua, separando em classes. Veja o exemplo com a variável de consumo (hwy). Estamos alterando a escala e agrupando em 30 classes esta variável contínua.

```{r}
c + geom_bar() +
  scale_x_binned(n.breaks = 30)
```

#### scale\_\*\_identity

```{r}
#| layout-ncol: 2

#Criando uma tabela com as cores como uma variável.
dfc <- data.frame(
  x = 1:4,
  y = 1:4,
  cor = c("red", "green", "blue", "yellow")) 

#Gráfico com o preenchimento como variável discreta (col)
ggplot(dfc, aes(x, y))+
  geom_col(aes(fill = cor)) 
  # + scale_fill_discrete() isso é o padrão, portanto opcional

#Gráfico com o preenchimento pegando o valor da variável col
ggplot(dfc, aes(x, y)) +
  geom_col(aes(fill = cor)) +
  scale_fill_identity()
```

Veja que quando usamos uma nova escala, você precisa definir se quer a legenda e outros elementos.

```{r}
ggplot(dfc, aes(x, y)) +
  geom_col(aes(fill = cor)) +
  scale_fill_identity(guide = "legend")
```

#### scale\_\*\_manual

Use para definir uma escala de forma manual. Neste exemplo, vamor criar uma variável "cores", definindo manualmente uma cor para cada classe de veículo.

```{r}
cores <- c(suv = "red", 
          compact = "blue", 
          "2seater" = "darkgreen", 
          minivan = "orange",
          midsize = "lightblue",
          pickup = "yellow",
          subcompact = "orange3")
          
ggplot(mpg, aes(class, hwy)) +
  geom_col(aes(fill = class)) +
  scale_fill_manual(values = cores)
```

#### scale\_\*\_date

Use para tratar uma escala como data. Neste exemplo, iremos utilizar o conjunto de dados "**billboard**" também modificar os labels da escala e quantas paradas ela terá.

```{r}
billboard |> 
  ggplot(aes(x = date.entered)) +
  geom_bar() +
  scale_x_date(date_labels = "%m/%Y", date_breaks = "20 weeks")
```

#### scale\_\*\_datetime

Similar a scale\_\*\_date , porém ela lida com data e **hora**.

#### **Escalas de Localização X & Y**

Algumas escalas alteram a estética dos eixos x e/ou y. O

#### scale\_\*\_log10

Use para plotar o eixo x em escala de log10.

```{r}
c + geom_line(stat = "count")+
  scale_y_log10()
```

#### scale\_\*\_reverse

Use para inverter a ordem da escala.

```{r}
c + geom_line(stat = "count")+
  scale_x_reverse()
```

#### scale\_\*\_sqrt

Use para plotar o eixo x em escala quadrática.

```{r}
c + geom_area(stat = "count") +
  scale_y_sqrt()
```

#### **Escalas de Cor e Preenchimento**

As escala de cor (color e fill) possuem características semelhas, tanto para variáveis discretas quanto contínuas. A seguir, usar a cor de preenchimento com funções **scale_fill\_\***, porém as mesmas características estão disponíveis para as funções **scale_color\_\*** .

[**Variáveis Discretas**]{.underline}

#### scale_fill_brewer

Use esta escala de cores para aplicar paletas qualitativas nas cores. As paletas são provenientes do pacote **RColorBrewer**. Este pacotes possui paletas para cores **sequenciais**, **divergentes** e **qualitativas**.

Para ver as paletas disponíveis use:

```{r}
#| layout-nrow: 3

RColorBrewer::display.brewer.all(type = "qual")
RColorBrewer::display.brewer.all(type = "seq")
RColorBrewer::display.brewer.all(type = "div")
```

::: callout-tip
Para visualizar apenas as paletas amigáveis à pessoas com sensíveis à diferenciação de cores (colorblind), usa o parametro **colorblindFriendly** = TRUE
:::

```{r}
n + scale_fill_brewer(palette = "Blues")
```

#### scale_fill_grey

Use para gerar escalas de cores em diferentes níveis de cinza, com valores de 0 até 1.

```{r}
n + scale_fill_grey (start = 0.2, end = 0.8)
```

[**Variáveis Contínuas**]{.underline}

Para demonstrar algumas escalas de cores para variáveis contínuas, criaremos um objeto ggplot "**o**", adicionando a estética de preenchimento para a mesma variável mapeada em na estética "x".

```{r}
o <- c + geom_dotplot(aes(fill = ..x..))
```

#### scale_fill_distiller

Use para extender as escalas "brewer" das variáveis discretas para variáveis contínuas, adicionando 7 outras cores por interpolação.

```{r}
o + scale_fill_distiller(palette = "Blues")
```

#### scale_fill_gradient

Use para criar escalas de cores contínuas com gradiente de duas cores.

```{r}
o + scale_fill_gradient(low="red", high="yellow")
```

#### scale_fill_gradient2

Use para criar escalas de cores contínuas com gradiente de três cores (início, meio e fim).

```{r}
o + scale_fill_gradient2(low = "red", high = "blue",
mid = "white", midpoint = 25)
```

#### scale_fill_gradientn

Use para criar escalas de cores contínuas com gradiente de múltiplas cores.

```{r}
o + scale_fill_gradientn(colors = topo.colors(6))
```

Além da paleta topo.colors(), podemos ainda usar heat.colors(), terrain.colors, rainbow() e cm.colors() para criar um vetor de tamanho específico com cada elemento com uma cor seguindo o padrão de espaço de cores HSV.

Exemplo:

```{r}
#|layout-ncol: 2
#|layout-nrow: 2

o + scale_fill_gradientn(colors = rainbow(6))
o + scale_fill_gradientn(colors = cm.colors(4))
o + scale_fill_gradientn(colors = heat.colors(3))
o + scale_fill_gradientn(colors = terrain.colors(4))
```

::: callout-tip
Para criar novas paletas de cor, podemos usar a função **RColorBrewer::brewer.pal**()
:::

#### **Escalas de Forma e Tamanho**

Assim como nas demais escala vistas até aqui, temos como definir escalar para forma e tamanho. Vamos criar um objeto "**p**" com um gráfico de pontos para ver os exemplos:

```{r}
p <- e + geom_point(aes(shape=fl, size = cyl))
```

#### scale_shape

Use para controlar a escala da forma. Ela mapeia variáveis discretas em 6 formas facilmente identificáveis.

::: callout-important
Se você tiver mais que 6 valores em sua variável discreta, uma mensagem de aviso iŕa aparecer e NÃO serão mostradas no gráfico. Use scale_shape_manual para fornecer seus próprios valores.
:::

```{r}
p + scale_shape()
```

#### scale_size

Use para alterar a escala de tamanho da área. Use scale_radius() para alterar o tamanho do raio. Veja no exemplo abaixo, que a variável "cyl" estava mapeada para a estética de tamanho (size) quando criamos o objeto "p":

```{r}
#| eval: false
p <- e + geom_point(aes(shape=fl, size = cyl))
```

Com isto, o ggplot entendeu que por ser uma variável numérica, deveria aplicar um distribuição contínua quando montou a distribuição de tamanho.

Já no gráfico da direito, alteramos a escala do tamanho e definimos o número de quebras em 4, 5, 6 e 8 cilindros.

```{r}
#| layout-ncol: 2
p + scale_size()
p + scale_size(breaks = c(4,5,6,8) )
```

Aepsar de não ser recomendados, mas apenas para carater ilustrativo, vemos que cyl é uma variável discreta, e portanto poderíamos ajustá-la como tal para que o ggplot automaticamente definisse uma escala de tamanho discreta. Veja o que acontece quando utilizamos as função as_factor() na estética de tamnho para a variável cyl.

```{r}
p2 <- e + geom_point(aes(shape=fl, size = as_factor(cyl)))
```

### Sistema de Coordenadas

Apesar do sistema de coordenadas cartesiano ser o mais comum no mundo dos gráficos, o ggplot aferece uma série de outros sistemas, como coordenadas polares, maps ou até mesmo uma coordenada cartesiana invertendo o eixo x com o y. A seguir verremos alguns exemplos seguindo o modelo padrão, onde criaremos um objeto "**r**" com uma geometria de barras para iniciar e evitar repetição do código.

```{r}
r <- d + geom_bar()
```

#### coord_cartesian

Use para definir e configurar um sistema de coordenadas cartesiano. Este é o sistema padrão do ggplot.

```{r}
r + coord_cartesian(xlim = c(0,5))
```

#### coord_fixed

Use par criar um sistema de coordenada cartesiano com a proporção de aspecto entro os eixos x e y.

```{r}
r + coord_fixed(ratio = 1/8)
```

#### coord_polar

Use para mudar o sistema de coordenadas para polar.

```{r}
r + coord_polar(theta = "x", direction = 1)
```

#### coord_trans

Use para transformar as coordenadas cartesianas. Por exemplo, se quisermos alterar o eixo y, para que fique como raiz quadrada, faremos:

```{r}
r + coord_trans(y = "sqrt")
```

::: callout-note
Como vimos anteriormente, poreriamos transformar a escala do eixo y atraves das funçoes scale_y\*. A diferença e que a alteraçao na escala acontece ANTES das transformaçoes estatisticas enquanto as coordenadas ocorrem DEPOIS. Mudanças de coordenadas também alterar a forma das geometrias.
:::

### Facetas

O ggplot usa o conceito de "facetas" para dividir um gráfico em sub-gráficos com base em uma variável discreta.

Vamos crir um objeto "**t**" base para exemplificar o uso de facetas:

```{r}
t <- ggplot (mpg, aes(cty, hwy)) + geom_point()
```

#### facet_grid

Use para criar um grid de facetas:

```{r}
t + facet_grid(cols = vars(fl))
```

Neste exemplo, criamos um gráfico, com vários sub-gráficos em colunas, usando a variável "fl" como separador das facetas.

Podemos criar as facetas em linhas também:

```{r}
t + facet_grid(rows = vars(year))
```

Ou em um grid de linhas e colunas?:

```{r}
t + facet_grid(rows = vars(year), cols = vars(fl))
```

#### facet_wrap

Use para agrupar uma faixa de facetas em 2d.

```{r}
t + facet_wrap (vars(fl))
```

::: callout-tip
Por padrão o ggplot irá usar a mesma escala do eixos para cada faceta. Podemos usar o argumento scales = pafra mudar este comportamento.
:::

Veja um exemplo:

```{r}
t + facet_grid(rows = vars(drv), cols = vars(fl), scales = "free")
```

::: callout-tip
Podemos usar os argumento "free_x" e "free_y" para ajustar os limites dos respectivos eixos.
:::

Podemos também nomear cada faceta utilzando o argumento labeller =. Veja alguns exemplos:

```{r}
#| layout-nrow: 2
t + facet_grid(cols = vars(fl), labeller = label_both)

t + facet_grid(rows = vars(fl),labeller = label_bquote(alpha ^ .(fl)))
```

### Temas

A camada de temas, permite uma customização final ao gráfico, permitindo ajustes nas propriedades dos eixos, legendas, painéis e facetas.

O ggplot vem com alguns temas pré-definidos, mas você pode customizá-los de acordo com sua necessidade. A recomendação é que você parte de um tema que mais se aproxime da sua necessidade e mude os elementos faltantes. Veja alguns exemplo:

::: panel-tabset
#### theme_bw

```{r}
r + theme_bw()
```

#### theme_gray

```{r}
r + theme_gray()
```

#### theme_dark

```{r}
r + theme_dark()
```

#### theme_classic

```{r}
r + theme_classic()
```

#### theme_light

```{r}
r + theme_light()
```

#### theme_linedraw

```{r}
r + theme_linedraw()
```

#### theme_minimal

```{r}
r + theme_minimal()
```

#### theme_void

```{r}
r + theme_void()
```
:::

Digamos que precisamos alinhar o título do gráfico com todo o gráfico. Neste caso, podemos usar o tema e ajusar o argumento **plot.title.position** =

```{r}
#| layout-ncol: 2
r + ggtitle("Titulo")  
  
r + ggtitle("Titulo") + 
  theme(plot.title.position = "plot")
```

Ou digamos que precisamos alterar a cor de fundo do gráfico:

```{r}
r + theme(panel.background = element_rect(fill = "lightblue"))
```

São muitas as possibilidades de customização. Veja ?theme para todos os detalhes.

## Ajuste de Posição

Em alguns casos, precisamos alterar a posição de algumas geometrias que ocupariam o mesmo local no gráfico.

Em geral, utilizamos o argumento "position =" nas geometrias para alterar a definição padrão.

Para entender melhor a diferença dos tipos de posições mais comuns, vamos criar um objeto ggplot chamado "**s**" e comparar estes tipos:

```{r}
s <- ggplot(mpg, aes(fl, fill = drv))
```

#### Position Stack

Use para colocar as geometrias empilhada uma sobre a outra.

```{r}
s + geom_bar(position = "stack")
```

Para a geometria de barras (geom_bar), esta é a posição padrão.

#### Position Dodge

Use para colocar as geometrias lado a lado.

```{r}
s + geom_bar(position = "dodge")
```

#### Position Fill

Use para colocar as geometrias empilhadas normalizando a altura.

```{r}
s + geom_bar(position = "fill")
```

#### Position Jitter

Use para adicoinar um mudança aleatória em X e Y para evitar sobreposição do pontos.

```{r}
e + geom_point(position = "jitter")
```

#### Position Nudge

Use para deslocar textos fora dos pontos.

```{r}
e + geom_text(aes(label = cty), position = position_nudge(1,2)) +
  geom_point() +
  scale_x_continuous(limits = c(25,40))
```

::: callout-note
Neste caso, ao invés de usarmos a string "**nudge**" , usamos a função position_nudge para passar os parametros de deslocamento. As funções "**position\_\*** funcoinam para ajuster de forma mais refinada o posicionamento. Em geral aceitam os argumento de altura (width) e largura (height).
:::

```{r}
s + geom_bar(position = position_dodge(width = 1))
```

## Títulos e Legendas

#### labs

Por ser muito comum termos que alterar os títulos dos elementos de um gráficos, o ggplot oferece a função **labs**().

Podemos alterar o título do gráfico, o sub-título, o título de rodapé, o nome alternativo e uma estética (por exemplo, x ou y).

Veja o exemplo no objeto "t" criado previamente.

```{r}
t + (aes (color = "fl")) +
  labs(x = "Texto do eixo X", y = "Texto do eixo Y",
title ="Título geral do gráfico",
subtitle = "Sub-título do gráfico",
caption = "Texto de rodapé",
alt = "Texto alternativo do gráfico para representação em texto",
color = "Título da Legenda")
```

#### guides

Use para definir os texto das guias. Guias são parte do gráfico que ajudam em sua interpretação. Por exemplo, a legenda é uma guia. As próprias marcas nos eixos são outro tipo de guias. As barras de tamanho ou forma, são outra forma de guias.

Por exemplo, se quisermos alterar a posição das guias do eixo x a cada duas marcas, podemos fazer usando a função **guide**():

```{r}
p + guides(x = guide_axis(n.dodge = 2))
```

Para alterar o título da legenda da estética de tamanho (size) e colocá-la à direita da legenda, podemos fazer:

```{r}
p + guides(size = guide_legend(title = "Novo Título", title.position = "right"))
```

::: callout-tip
Podemos também remover um determinada guia fazendo = "none".
:::

```{r}
n + guides(fill = "none")
```

#### annotate

Use para gerar alguma anotação no gráfico, criando uma camada adicional. Você pode criar uma anotação de qualquer geométria. No exemplo abaixo, usaremos a geometria de texto (text) e de reta (segment) para escrever o texto e a seta.

```{r}
t + annotate(geom = "text", 
             x = 34, y = 30, 
             label = "Anotação", 
             color = "red") +
  
annotate(geom = "segment",
         x = 31, xend = 29, y = 32-2, yend = 34-2, 
         arrow = arrow(type = "closed", length = unit(0.02, "npc")),  
         color = "red")
```

#### theme

Podemos também através do tema, definir a posição da legenda por exemplo:

```{r}
n + theme(legend.position = "bottom")
```

Podemos definir também atraǘes da escala o título e os texto de cada item da estética. Por exemplo, para alterar a legenda do preenchimento atraveś da escala, podemos fazer:

```{r}
n +  scale_fill_discrete(name = "Title",
labels = c("A", "B", "C", "D", "E"))
```

## Zoom

**Use para dar um zoom no gráfico**. Podemos fazer o zoom removendo os valores que não serão vistos no gráfico, ou mantendo-os (preferencial).

Zoom mantendo os pontos (preferencial):

```{r}
t
t + coord_cartesian(xlim = c(0, 25), ylim = c(10, 20))
```

**Zoom excluindo os pontos não visíveis**:

Fazemos este zoom, definindo limites das escalas:

```{r}
t + xlim(0, 25) + ylim(10, 20)
```

Ou fazendo o equilavente de forma mais explícita:

```{r}
t + scale_x_continuous(limits = c(0, 25)) +
scale_y_continuous(limits = c(10, 20))
```

## Bônus

Como vimos, há uma infinidade de possibilidades para criação de gráficos com o pacote ggplot, porém seus códigos podem se tornam com muitas linhas dado ao grau de customização que você precisa. Nossa recomendação é criar um gráfico com os ajustes nas principais camadas e depois uma função mais simplificada para chamar este código de forma repetida.

A idéia não é esclarecer os detalhes de criação de funções no R, mas sim, dar um exemplo para otimizar o código criado para o ggplot.

**Exemplo**:

Vamos criar nosso gráfico inicial:

```{r}

g_barras <- 
  mpg |> 
  ggplot(aes(x = manufacturer, fill = class)) +
    geom_bar() +
    geom_text(stat = "count", 
              aes(label = ..count..), 
              position = position_stack(vjust = 0.5), 
              size = 3) +
    scale_fill_brewer(type = "qual", 
                      palette = 2, 
                      direction = -1) +
    labs(y = "Quantidade" ) +
    guides(fill = guide_legend(nrow = 3))  +
    theme_grey() + 
    theme(legend.position = "bottom") +
    theme(axis.text.x = element_text(angle = 90)) +
    theme(panel.background = element_rect(fill = "#E5F3F7")) 

maior_valor <- mpg |> 
  count(manufacturer, class, sort = TRUE) |> 
  slice_head(n = 1) #Identificamos o grupo com maior qtd

g_barras + labs(
    title = "Exemplo de gráfico dinâmico com função",
    subtitle = paste0(maior_valor[[1]], " / ", maior_valor[[2]], " tem a maior qtd com ", maior_valor$n, " unidades.")) # Criamos um subtitulo para o grpo com maior Qtd dinamicamente.
```

Após termos o gráfico com as customizações que desejamos, podemos criar uma função. Neste caso, ela irá receber apenas os dados, a variável do eixo x e de preenchimento.

```{r}
# Função para gerar o gráfico
cria_grafico_barras <- function(dados, eixo_x, preenchimento) {
  
  g_barras <- 
    {{dados}} |> 
    ggplot(aes(x = {{eixo_x}}, fill = {{preenchimento}})) +
    geom_bar() +
    geom_text(stat = "count", 
              aes(label = ..count..), 
              position = position_stack(vjust = 0.5), size = 3) +
    scale_fill_brewer(type = "qual", 
                      palette = 2, 
                      direction = -1) +
    labs(y = "Quantidade" ) +
    guides(fill = guide_legend(nrow = 3))  +
    theme_grey() + 
    theme(legend.position = "bottom") +
    theme(axis.text.x = element_text(angle = 90)) +
    theme(panel.background = element_rect(fill = "#E5F3F7"))

maior_valor <- {{dados}} |> 
  count({{eixo_x}}, {{preenchimento}} , sort = TRUE) |> 
  slice_head(n = 1)

g_barras <- 
  g_barras + labs(
    title = "Exemplo de gráfico dinâmico com função",
    subtitle = paste0(maior_valor[[1]], " / ", maior_valor[[2]], " tem a maior qtd com ", maior_valor$n, " unidades."))


return(g_barras)

}
```

Agora podemos usar a função com as mesmas ou outras variáveis. Apenas devemos observer o tipo das variáveis. Se sua função cria gráfico com variáveis discretas, ela pode não funcionar devidamente se' passar variável contínua. Talvez você possa criar outra função, ou deixá-la mais "inteligente".

```{r}

#Usando a função criada.
mpg |> 
cria_grafico_barras(manufacturer, class)

```

```{r}
#Usando a função criada om outros parametros.

mpg |> 
  mutate (year = as_factor(year)) |>  #Alterando a variável year para factor antes para torná-la discreta.
  cria_grafico_barras(class, year)
```
