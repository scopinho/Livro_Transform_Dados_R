# Visualização de Dados com GGPLOT2

## Introdução

A seguir temos vários exemplos de visualização de dados utilizando o pacote GGPLOT2 do R.

::: callout-note
Apesar de visualização de dados não ser especificamente parte das etapas de transformação e manipulação de dados, acreditamos ser importante um conhecimento básico sobre o tema, pois muitas vezes, para explicarmos aquilo que estamos transformando ou manipulando, o fazemos de forma gráfica para melhor compreensão.

O objetivo não é explicar a aplicabilidade e/ou o a função de cada gráfico, mas sim, como ele pode ser construído.
:::

Para saber mais sobre este pacote, acesse:

[https://cran.r-project.org/package=ggplot2](https://cran.r-project.org/package=stringr){.uri}.

::: callout-warning
Para melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:

<https://education.rstudio.com/learn/beginner/>.
:::

Para os exemplos, iremos carregar os seguintes pacotes:

-   **tidyverse**

-   **gt**

```{r}
#| echo: true
library (tidyverse)
library (gt)
```

### Exemplos da Folha de Referência

A maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na [**Folha de Referência**](https://github.com/scopinho/R-cheatsheets/blob/main/translations/portuguese/data-visualization_pt_br.pdf) do stringr disponível no site do [RStudio](rstudio.com).

![](images/cheatsheet-01.png)

![](images/cheatsheet-02.png)

------------------------------------------------------------------------

## Tipos de Variáveis

Não é intuito deste tópico aprofundar neste tema, porém como a natureza de cada gráfico pode estar relacionada ao tipo de variável que ele irá representar, vamos rever de forma resumida os tipos de variáveis no contexto de análise de dados e do ggplot.

Este conhecimento é importante, pois iremos nos referir a eles, principalmente quando tratarmos das funções de [Geometrias (geoms)](#geometrias-geoms).

Podemos categorizar as variáveis em **Qualitativas** ou **Quantitativas**. [@favero]

#### Qualitativas

Representam as características de um indivíduo, objeto ou elemento que não podem ser medidas ou quantificadas.

As variáveis **qualitativas**, também poder ser classificadas em função do número de categorias em:

-   **Dicotômica** ou **Binária**: Apenas duas categorias.

-   **Policotômica**: Mais que duas categorias.

Ou em função da escala de mensuração em:

-   **Nominal**: As unidades são classificadas em categorias em relação à características representadas. Sem ordem ou relação entre si. (ex: sexo)

-   **Ordinal**: As unidades são classificadas em categorias em relação à características representadas. Há uma ordem ou relação entre si. (ex: grau de escolaridade)

::: callout-note
Tipicamente, um dado qualitativo em natureza representa valores discretos que pertencem a um conjunto finito de classes. Estes valores discretos podem ser representados através de um número ou textos.

Em geral, variáveis **qualitativas** são representadas no ggplot com o tipo **fatores** (factors) ou **caracteres**(chr).
:::

#### Quantitativa

Representam as características de um indivíduo, objeto ou elemento resultantes de uma contagem ou mensuração.

As variáveis **quantitativas**, também podem ser classificadas em função da escala de precisão.

-   **Discreta**: Assumem conjunto finito de valores, frequentemente de uma contagem (ex: número de filhos, quantidade de carros, etc)

-   **Contínua**: Assumem conjunto infinito de valores, frequentemente com resultado de uma mensuração (ex: peso, altura, salário, etc)

Ou em função da escala de mensuração em:

-   **Intervalar**: As unidades são ordenadas em relação à características mensurada e possui um unidade de constante. A origem, ou ponto zero, não expressa ausência de quantidade. (ex: temperatura)

-   **Razão**: As unidades são ordenadas em relação à características mensurada e possui um unidade de constante. A origem, ou ponto zero, é única e expressa ausência de quantidade.(ex: distância percorrida)

::: callout-caution
Vale lembrar que nem sempre uma variável representada por um número é quantitativa. O número da carteira de identidade é um exemplo disso. Apesar dos números ela é uma variável qualitativa.
:::

#### Discretas e Contínuas no GGPLOT

O ggplot2, em geral irá tratar as variáveis **caractere** (char) e **fatores** (factors) em escalas **discretas**. Já as variáveis **numéricas** com escalas **contínuas**. A separação nas seções adiante, seguem estas definições para segregar os tipos de gráficos e escalas.

::: callout-important
Quando tivermos variáveis que não seguem este padrão, devemos "transformá-las, usando funções como as_factor(), as.integer(), as.double, etc
:::

## Gramática dos Gráficos

O pacote ggplot2 é uma implementação do livro "***Grammar of Graphics***", que apresenta um conceito de quais seriam os elementos de um gráfico e suas interconexões. O modelo teórico proposto no livro é que através de camadas definidas qualquer gráfico pode ser construído. Abaixo o modelo, que deve ser interpretado de baixo para cima.

![](images/grammar-01.jpg){width="354"}

De uma forma bem resumida, a idéia é que você possa construir qualquer gráfico com base nestes mesmos elementos: um **conjunto de dados**, um **sistema de coordenadas** e **geoms**, que seriam marcas visuais que representas os pontos dos dados.

![](images/ggplot-01.jpg){width="475"}

No caso do ggplot2, para mostrar valores no gráfico, as varíaveis do conjunto de dados são **mapeadas** em propriedadas visuais da geometria (geom).

Este mapeamento de estética (aesthetic) é feito através da função aes() e podemos fazer mapeamentos estéticos como cor ou tamanho.

![](images/ggplot-02.jpg){width="475"}

## Modelo para Construção de um Gráfico

No caso do ggplot2, podemos definir uma espécie de modelo (template) para a sintaxe de construção de gráficos:

![](images/ggplot_template-01.jpg){width="556"}

------------------------------------------------------------------------

#### ggplot

A função ggplot() inicia um gráfico que será completado com as camadas adicionadas na sequência. Adicione uma geometria (geom) para cada camada.

Usando o modelo anterior e o que vimos até aqui, vamos gerar nosso primeiro gráfico. Como base de dados usaremos a tabela **mtcars**. Para maiores informação sobre as colunas e dados do mtcars, digite ?mtcars.

```{r}

mtcars
```

```{r}
ggplot(data = mtcars) +
  geom_point (mapping = aes(x = hp, y = mpg ))
```

::: callout-note
Observe que mesmo sem definirmos escalas, temas, estatísticas ou outras camadas, o gráfico ainda assim foi gerado. Isto é porque o ggplot tem valores padrões dinâmicos que tentam prover o melhor resultado possível com o mínimo de esforço.
:::

::: callout-tip
A definição da estética com seu mapeamento, feito neste exemplo na função de geometria (geom_point) poderá ser feito também na função ggplot().
:::

Apesar do gráfico final ser similar, a estética mapeamento poderá ser utilizada pelas funções geom\_\*() nas camadas seguintes, sem a necessidade de repetí-la, caso contrário, ela será restrito apenas àquela geom() na qual foi declarada. Veja:

```{r}
ggplot(data = mtcars, mapping = aes(x = hp, y = mpg))+
  geom_point()
```

Por ser comum o uso do argumento data = e mapping =, podemos excluídas do código, deixando-o mais enxuto, porém mais difícil para quem não tem tanta familiaridade, veja:

```{r}
ggplot(mtcars,aes(x = hp, y = mpg)) +
  geom_point()
```

#### last_plot

Use para retornar o último gráfico gerado.

```{r}
last_plot()
```

#### ggsave

Use para salvar o gráfico em uma imagem. O tipo de imagem é selecionado pela extensão do arquivo de saída.

Por exemplo, para salvar o diretório atual um arquivo com o gráfico chamado "plot-01.png" com o formato de imagem ".PNG" de tamanho 5x5 centímetros, fazemos:

```{r}
ggsave("plot-01.png", width = 5, height = 5, units = "cm")
```

## Estética (aes)

Cada estética possui valores padrões que serão usados por determinada função de geometria ou de estatística. Mas existem valores que são comuns a quase todas as geom/stat(), a seguir veremos alguns deles:

#### color e fill

Use para definir a cor (color) ou preenchimento (fill) para a estética.

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg, color = "red"))
```

Na string de color =, podemos usar valores de cores em inglês, como "red" ou "blue", ou também códigos RGB, como ""#00ABFF" ou "FF00AA".

::: callout-important
Observe que o valor definido da cor, dentro fora dos parênteses da função aes(), ou seja, ela está fazendo o mapeamento da cor com os dados. Se utilizarmos o argumento color = da função geom_point(),estaremos definindo um valor fora do mapeamento.
:::

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg) , color = "red")
```

Apesar do resultado ser similar, observe que no exemplo anterior tivemos color como um mapeamento da estética, como definimos o valor fixo com a cor "red", seria como tivessemos em nossos dados uma coluna onde todas as linhas tivessem o valor "red". Já no exemplo acima, estamos simplemente dizendo à função da geometria que queremos a cor vermelha para ela.

Vejamos um outro exemplo para que fique claro este ponto. Vamos gerar o mesmo gráfico onde colocamos "red" como parte da estética, porém agora, iremos mapeá-la com a coluna "qsec" de nossos dados mtcars:

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg, color = qsec))
```

#### linetype

Use para definir a linha utilizada no gráfico. Podemos utilizar um número de 0 a 6 ou um nome:

*(0 = "blank", 1 = "solid", 2 = "dashed", 3 = "dotted", 4 = "dotdash", 5 = "longdash",6 = "twodash")*

Por exemplo, ao invés de utilizarmos a geometria de pontos (geom_point), vamos utilzar a geometria de linha (geom_line):

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg) , linetype = "dotted")
```

#### size

Use para definir o tamanho, no caso de uma linha em "mm".

Como dito anteriormente, estes valores são comuns para vários geometrias. Por exemplo, podemos utilizar o argumento size também na geometria de pontos (geom_point):

```{r}
#| layout-ncol: 2

ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), size = 5)

ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), size = 5)
```

#### lineend

Use para definir o terminador da linha. Os valores podem ser: *round*, *butt* e *square*.

::: panel-tabset
## squared

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "square", size = 4)
```

## butt

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "butt", size = 4)
```

## round

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "round", size = 4)
```
:::

#### linejoin

Use para definir a junção da linha. Os valores podem ser: *round*, *mitre* e *bevel*.

::: panel-tabset
## round

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "round", size = 4)
```

## mitre

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "mitre", size = 4)
```

## bevel

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "bevel", size = 4)
```
:::

#### shape

Use para definir a forma. Podemos passar um número ou um nome em inglês da forma conforme abaixo:

![](images/aes_shape-01.jpg)

```{r}
#| layout-ncol: 2 

ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), shape = "square cross",  size = 3)
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), shape = 5, size = 3)
```

## Geometrias (geoms) {#geometrias-geoms}

Use as funções de geometria para representar os pontos de dados. Use as estéticas das geometrias para representar as variáveis.

::: callout-warning
Lembre-se que cada função retornará uma camada, portanto, a ordem de criação das camadas afeta o resultado do gráfico, pois uma será criada sobre a anterior.
:::

### Gráficos Primitivos

Para os exemplos a seguir, utilizaremos duas bases de dados, uma chamada **economics** e outra **chamada** seals.

::: panel-tabset
## Economics

```{r}
economics
```

## Seals

```{r}
seals
```
:::

Para simplificar o código dos próximos exemplos, iremos criar dois objetos gráfico do ggplot:

O primeiro chamado "**a**", irá conter um objeto ggplot com os dados de **economics**, mapeando a estética de x para a variável "date" e y para a variável "unemployed".

O segundo chamado "**b**", irá conter um objeto ggplot com os dados de **seals**, mapeando a estética de x para a variável "long" e y para a variável "lat".

Desta forma trabalharemos com os mesmos objetos base e adicionaremos apenas novas camadas afim de identificar os detalhes das diversas funções de geometria.

```{r}
a <- ggplot(economics, aes(date, unemploy))
b <- ggplot(seals, aes(x = long, y = lat))
```

::: callout-note
Para simplificar o código, em algum momentos podemos omitir o argumento, como data=, mapping = , x = , y = . Isto porque já estamos os valores na ordem da função.
:::

Agora com os objetos inicialmente criados, iremos adicionar novas camadas afim de obtermos os gráficos e entendermos algumas das funções de geometria para gráficos primitivos.

#### geom_blank

Use para garantir limites para todos os gráficos de acordo com os dados.

```{r}
a + geom_blank()
```

::: callout-tip
Use a função **expand_limits**() para expandir os limites do gráfico usando dados. Ver ?expand_limits para mais detalhes.
:::

#### geom_curve

Use para criar curvas.

```{r}
b + geom_curve(aes(yend = lat + 1, xend = long + 1), curvature = 1)
```

#### geom_path

Use para conectar observações.

```{r}
a + geom_path(lineend = "butt", linejoin = "round", linemitre = 1)
```

#### geom_polygon

Use para criar poligonos. É similar a geom_path(), porém a parte interna é preenchida com argumento fill =.

```{r}
a + geom_polygon(aes(alpha = 50))
```

::: callout-note
O argumento alpha = , é muito comum na definição de cores. De maneira simplificada, ele indica o nível de transparência de uma cor, sendo 0, nenhuma transparência e 1 transparência total.
:::

#### geom_rect

Use para criar retângulos.

```{r}
b + geom_rect(aes(xmin = long, ymin = lat,
xmax = long + 1, ymax = lat + 1))
```

::: callout-note
A função **geom_title()** fazem a mesma coisa, porém são parametrizadas de forma diferente. A geom_rect usa a localização dos 4 cantos do quadrado, enquanto a geom_tile usa o centro e seu tamanho (largura e altura) para dimensionar.
:::

#### geom_ribbon

Use para criar uma "fita". Para cada valor de x, ela mostra um intervalo y, definido por ymin e ymax. Veja que geom_area() é um caso especial do geom_ribbon(), onde o ymin é fixo em 0 e y é usado no lugar de ymax.

```{r}
a + geom_ribbon (aes(ymin = unemploy - 900,
ymax = unemploy + 900))
```

### Segmentos de Linhas

Estas funções de geometrias, permitem criar diversos tipo de segmentos de linha e são úteis quando precisamos "marcar" ou definir algo no gráfico, com linhas verticais ou horizontais por exemplo.

#### geom_abline

Use para criar uma linha de um ponto "a" até um ponto "b", passando o intercepto e a inclinação da reta.

```{r}
b +  geom_abline(aes(intercept = 0, slope = 1))
```

#### geom_hline

Use para criar uma ou mais linhas horizontais.

```{r}
b + geom_hline(aes(yintercept = lat))
```

Veja que no exemplo anterior, fizemos o mapeamento do argumento yintercept como parte da estética (aes), mapeando este argumento com a variável "lat" de nossos dados.

Se quisermos simplesmente traçar uma linha com o intercepto do eixo y, correspondendo ao valor 40 (por exemplo, se fosse um tipo de meta), podemos definir este valor fora do mapeamento:

```{r}
b + geom_hline(yintercept = 40)
```

#### geom_vline

Use para criar uma ou mais linhas horizontais.

```{r}
b + geom_vline(aes(xintercept = long))
```

#### geom_segment

É similar ao geom_curve, porém ao invés de criar uma curva, criar um segmento de reta.

```{r}
b + geom_segment(aes(yend = lat + 1, xend = long + 1))
```

#### geom_spoke

Use para criar um segmento, parametrizado pela localização, direção e distância.

```{r}
b + geom_spoke(aes(angle = 1:1155, radius = 1))
```

### Uma Variável Contínua

Quando precisamos analisar um varíavel contínua, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto "**c**" e outro "**c2**", aos quais iremos adicionar novas camadas. Similar ao que fizemos anteriormente, porém agora utilizaremos a base de dados "**mpg**".

```{r}
mpg
```

Criando os objetos ggplot:

```{r}
c <- ggplot(mpg, aes(hwy))
c2 <- ggplot(mpg)
```

::: callout-important
Observe que o objeto "**c**", usa a base "mpg" **já atribuindo a variável "hwy" para x= da estética**. Esta configuração será aplicada para qualquer funções geom\_\*() a não ser que explicitamente tenhamos uma estética redefinindo isso dentro de outra camanda de geometria.

Já para o objeto "**c2**", **não temos a estética** de x definida, portanto, teremos que definí-la em nas próximas camadas com a funções de geometria (geom\_\*()).
:::

#### geom_histogram

Use para criar histogramas, ou seja, uma forma de visualizar uma variável contínua dividindo no eixo x em classes e contando o número de observações de cada classe no eixo y.

O argumento binwidth = define o tamanho das classes.

No exemplo a seguir, dividimos a variável contínua de consumo por rodagem (hwy) em classes com 2 observações cada.

```{r}
c + geom_histogram(binwidth = 2) 
```

Se desejar definir o número de classes ao invés de quantas observações terão cada classe, utilize o argumento bins =.

```{r}
c + geom_histogram(bins = 16) 
```

#### geom_freqpoly

Use para gerar um gráfico de polígonos de frequência. Enquanto o histograma gera um gráfico de barras, esta geometria gera uma linha.

```{r}
c + geom_freqpoly(bins = 30)
```

#### geom_area

Use para criar um gráfico de área, onde para cada valor no eixo x, há um valor y máximo e o valor de y mínimo é sempre zero.

::: callout-note
Você verá um argument (stat = "bin") abaixo. Veremos as **estatísticas** na seção [ESTATÍSTICAS (STATS)](#estatísticas-stats). Por hora, pense apenas que é uma forma de definirmos os valores que iremos mostrar para o eixo y. Por padrão o número de agrupamento (bin) é 30.
:::

```{r}
c + geom_area(stat = "bin", bins = 32)
```

#### geom_density

Use para fazer um gráfico de **densidade**. Usando funções de estimativa de densidade de kernel, seria uma versão mais "arredondada" do histogram, mostrando a função densidade de **probabilidade** da variável.

Há a possibilidade de configurar vários kernels das funções de densidade, como "gaussian", "rectangular", "triangular", "epanechnikov", "biweight", "cosine" ou "optcosine".

```{r}
c + geom_density(kernel = "gaussian")
```

::: callout-tip
Veja que podemos criar duas geometrias, uma com o histograma e outra de densidade sobrepostas. Para isto temos que sobreescrever a estética definida previamente para o eixo y (antes era count) usando ..density..
:::

```{r}
c + geom_histogram(aes(y = ..density..)) +
  geom_density()
```

#### geom_dotplot

Use para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.

```{r}
c + geom_dotplot() 
```

#### geom_qq

Use para criar um gráfico de quantil-quantil. Em geral utilizado para confirmar se uma variável tem uma distribuição gaussiana.

```{r}
c2 + geom_qq(aes(sample = hwy))
```

### Uma Variável Discreta

Quando precisamos analisar um varíavel discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**d**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente usando a base de dados **mpg**. Utilizaremos a variável combustível (fl).

```{r}
d <- ggplot(mpg, aes(fl))
```

#### geom_bar

Use para criar um gráfico de barras.

```{r}
d + geom_bar()
```

Veja outro exemplo: Como aconteceu com o combustível (fl), podemos pegar a variável tipo da classe do veículo (class) e gerar um gráfico de barras também.

```{r}
d + geom_bar(aes(x = class))
```

Usando o argumento da estética para cor do preenchimento (fill), podemos mapear uma variável igual ou diferente. Com isto, o ggplot automaticamente criará uma legenda para os diferentes valores da varíavel. Veja o que acontece quando temos x=fl e fill = class:

```{r}
d + geom_bar(aes(fill =class))
```

Note que como a estética herdada do objeto ggplot base (d) tinha o mapeamento de x para a variável combustível (fl), ela ainda permanece no eixo x.

Se sobrescrevermos este mapeamento para a estética do geom_bar com a mesma variável para x e fill, teremos:

```{r}
d + geom_bar (aes(x = class, fill = class)) 
```

Note que o resultado automático do gráfico foi um pouco diferente. Quando tivemos x = fl e fill = class as barras foram **empilhadas** (stack) e quando tivemos x = class e fill = class, as barras foram lado colocadas **lado a lado** (dogde).

Por padrão, o ggplot, quando múltiplas barras ocupam o mesmo ponto, elas são empilhadas. Este comportamento pode ser definido através do argumento **position =** .

Veja as diferentes opções:

::: panel-tabset
## dodge

```{r}
d + geom_bar(aes(fill =class), position = "dodge")
```

## dodge2

```{r}
d + geom_bar(aes(fill =class), position = "dodge2")
```

## stack

```{r}
d + geom_bar(aes(fill = class) , position = "stack")
```

## fill

```{r}

d + geom_bar(aes(fill =class), position = "fill")
```
:::

::: callout-tip
As geometrias podem ter valores calculados autometicamente "computed variables". Isto é para faciliar a geração dos gráficos com valores padrões. No caso da geom_bar, não precisamos passar que no eixo y gostaríamos de ter a contagem da variável que está no eixo x. Veja que então, a variável y não ficou sem um valor, ele apenas foi substituído pela contagem (count) automaticamente. A geom_bar tem "count" e "prop" como varíveis computadas.

Para saber quais varíaveis são computadas automaticamente para cada geometria, veja a ajuda com ?geom_bar.
:::

### Duas Variáveis Discretas

Quando precisamos analisar um duas varáveis discretas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**g**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **diamonds**. Utilizaremos as variáveis corte (cut) e cor (color).

```{r}
g <- ggplot(diamonds, aes(cut, color))
```

#### geom_count

Esta é uma variante do geom_point() que conta o número de observação em cada localização e então mapeia a contagem na área do ponto.

```{r}
g + geom_count()

```

#### geom_jitter

É similar ao geom_point, porém adiciona uma variação aleatória em cada ponto.

```{r}
g + geom_jitter(height = 2, width = 2)
```

Como várias outras geometrias, podemos adicionar uma cor na estética do geom_jitter, mapeando outra váriável, como por exemplo o corte (cut) para facilitar a visualização:

```{r}
g + geom_jitter(aes(color = cut), height = 2, width = 2)
```

### Uma Variável Contínua e Outra Discreta

Quando precisamos analisar uma varável contínua e outra discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**f**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg**. Utilizaremos as variáveis classe (class) e consumo na estrada (hwy).

```{r}
f <- ggplot(mpg, aes(class, hwy))
```

#### geom_col

Use para criar um gráfico de colunas. Ele é similar ao gráfico de barras, porém agora, no eixo y, teremos uma variável contínua. Observe que enquanto no geom_bar, o eixo y é calculado automaticamente, aqui na geom_col, você precisa ter a variável já nos seus dados.

```{r}
f + geom_col()
```

Assim, como no geom_bar, podemos definir a cor de preenchimento da estética para geom_col, usando fill =.

Vamos usar a variável de número de cilindros (cyl) como exemplo.

```{r}
f + geom_col(aes(fill = cyl))
```

::: callout-warning
Veja que no caso acima, o ggplot tentou automaticamente ajustar a escala de cores para uma escala contínua. Dá a impressão que temos veículos com 7 cilindros inclusive.
:::

Isto é porque em nossos dados, a variável "cyl" é do tipo inteiro (integer) e com isto, o ggplot2 entende como um variável contínua.

Para obter o efeito pretendido, temos algumas opções. Uma seria mudar a variável cyl para o tipo fator (factor) usando a função as_factor(). Veja:

```{r}
f + geom_col(aes(fill = as_factor(cyl)))
```

Por padrão, as classes são colocadas de forma empilhada, similar ao que vimos na [geom_bar]. Se quisermos colocadas lado a lado, devemos fazer:

```{r}
f + geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = "dodge")
```

::: callout-tip
A largura das colunas é expandida automaticamente, pois não temos valores para todas as combinações. Por exemplo, não temos 8 cilindros em carros compatos. Há formas difrentes de ajutar isso, uma delas é ajustar a base de dados, criando as combinações possíveis utilização a função tidyr::**complete**()
:::

```{r}
complete(mpg, class, cyl) |> ggplot () +
  geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = "dodge")
```

#### geom_boxplot

Use para criar um gráfico boxplot (box e whiskers). Este gráfico é bastante interessante, pois mostra cinco estatísticas automaticamente (a mediana, primeiro e terceiro quartis e os limites max e min) e os pontos fora da curva individualmente (outlyers).

Para este exemplo, iremos além de definir uma cor de preenchimento através do argumento fill = , iremos remover a legenda desta camada usando show.legend = FALSE.\

```{r}
f + geom_boxplot(aes(fill = factor(class)), show.legend = FALSE)
```

Para mostrar a média ao invés da media, podemos fazer:

```{r}
#| eval: false
f + geom_boxplot(aes(middle = mean(hwy)))
```

#### geom_dotplot

Use para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.

```{r}
f + geom_dotplot(aes(color = class),binaxis = "y", stackdir = "center")
```

#### geom_violin

Use para criar um gráfico de violino. Ele mostra de forma compacta a distribuição de uma variável contínua.

```{r}
f + geom_violin(aes(fill = class), scale = "area")
```

### Duas Variáveis Contínuas

Quando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**e**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg**. Utilizaremos as variáveis consumo na cidade (cty) e consumo na estrada (hwy).

```{r}
e <- ggplot(mpg, aes(cty, hwy))
```

#### geom_label

Use para adicionar uma camada de texto (labels) no gráfico. Ela pode ser utilizada sozinha como em gráficos de dispersão, mas é mais comum, usá-la em conjunto com outras geometrias. Por exemplo, colocar os valores acima de cada barra em um geom_bar(). Por padrão, o texto a ser adicionado, tem um retângulo atrás para facilitar a leitura.

O argumento nudge\_\* =, ajusta a posição casos textos estejam no mesmo ponto

```{r}
e + geom_label(aes(label = cty), nudge_x = 1, nudge_y = 1)
```

No exemplo acima, temos um gráfico com um texto em cada ponto de cruzamento entre a variável no eixo x e a correspondente no eixo y.

Veja um uso do geom_label em conjunto com outra geom.

**Exemplo 1:**

Neste caso, iremos sumarizar os dados e obtermos um tabela contendo cada classe e a soma do consumo na estrada (hwy). Depois criaremos uma geometria de colunas e adicionaremos uma camada com o texto.

::: panel-tabset
## geom_label

```{r}
dados <- mpg |> group_by(class) |> summarise(hwy = sum(hwy))

dados |> ggplot(aes(class, hwy, fill = class)) +
  geom_col() +
  geom_label(aes(label = hwy))
```

## dados

```{r}
dados
```
:::

::: callout-tip
Podemos utilizar o argumento position = e através da função position_stacked centralizar o ajuste vertical (vjust) para colocar o texto no centro da coluna e remover a camada da legenda:
:::

```{r}
dados |> 
  ggplot(aes(class, hwy, fill = class)) +
  geom_col() +
  geom_label(aes(label = hwy), 
             position = position_stack(vjust = 0.5),
             show.legend = FALSE)
```

**Exemplo 3:**

Neste exemplo, seguiremos uma outra abordagem. Vimos na seção da geom_bar que ela calcula automaticamente a contagem dos valores para o eixo y, ou seja, nós não tinhamos esta contagem em nossos dados e não queremos preparar um tabela resumida com fizemos no exemplo anterior. Neste caso, podemos utilzar esta estatística calculada usando o parametro stat.

Veremos mais detalhes sobre as estatisticas na seção [Estatísticas (stats)](#estatísticas-stats)

```{r}
ggplot(mpg, aes(x = fl, fill = fl))+
  geom_bar() + 
  geom_label(stat  = "count", 
             aes(label = paste0("Total = ", after_stat(count))),
             size = 2,
             show.legend = FALSE)
```

::: callout-note
Veja acima que podemos controlar o tamanho (size) e definirmos um string junto com a variável que colocamos no texto utilziando a função **paste0**().
:::

#### geom_point

Use para gerar um gráfico de pontos ou dispersão. Este tipo de gráfico é muito úteil quando queremos mostrar relações entre as duas variáveis contínuas. Apesar dele também poder ser usado para comparar uma contínua com uma discreta, as opções de geometria como geom_jitter ou geom_count são mais apropriadas.

```{r}
e + geom_point()
```

::: callout-tip
Um gráfico de bolhas (bubblechart) é um gráfico de pontos com uma terceira variável associada ao tamanho dos pontos.
:::

```{r}
e + geom_point(aes(size = displ), alpha = 0.3)
```

#### geom_quantile

Use para criar um gráfico de quantis. Seria o equivalente contínuo do boxplot.

```{r}
e + geom_quantile()
```

Podemos definir quantis quantis queremos obter, por exemplo, se quisermos obter uma quebra de 5% , 50% e 95% podemos fazer:

```{r}
e + geom_quantile(quantiles = c(0.05, .5, 0.95))
```

#### geom_rug

Use para criar um gráfico de tapete (rug chart) com pequenas linhas para complementar uma visão 2Ds com duas visões de uma dimensão.

O argumento sides é uma string que controla onde os tapetes irão aparecer no gráfico: "trbl" = top, right, bottom e left.

```{r}
e + geom_rug(sides = "bl")
```

Fica interessante colocar uma camada adicional com geom_point para entender melhor o que acontece neste tipo de gráfico. Veja que as linhas do tapete ficam mais próximas quando temos mais concentração de pontos. Como este gráfico mostra todos os pontos, ele faz mais sentido com pequenos conjuntos de dados.

```{r}
e + geom_rug(sides = "bl") +
    geom_point()
```

#### geom_smooth

Use para ajudar a encontrar padrões na visualização quando há muitos dados sobrepostos.

```{r}
e + geom_smooth(method = "lm")
```

Você pode usá-lo para traçar linhas de tendência também.

```{r}
e + geom_point() +
    geom_smooth(method = "lm", se= FALSE)
```

#### geom_text

Use para criar uma geometria com textos. É similar ao geom_label, porém não tem um quadrado envolta do texto por padrão:

```{r}
e + geom_text(aes(label = cty), nudge_x = 1, nudge_y = 1)
```

Assim como aocntece no geom_label, podemos utilizar como camada adicional à outras geometrias. Veja:

```{r}
dados |> 
  ggplot(aes(class, hwy, fill = class)) +
  geom_col() +
  geom_text(aes(label = hwy), 
             position = position_stack(vjust = 0.5),
             show.legend = FALSE)
```

### Mapas de Calor e Densidade

En alguns casos, precisamos mostrar como as duas variáveis contínuas se relacionam, dividindo o plano em retângulos e plotando os número de casos em cada retãngulo e preenchendo a cor de acordo com o número de casos. Para os exemplos a seguir, usaremos novamente a base "**diamonds**" em um objeto "**h**" .

```{r}
h <- ggplot(diamonds, aes(carat, price))
```

#### geom_bind2d

Use para gerar um mapa de calor com classe de contagem 2d. O gráfico é formado dividindo o plano em retângulos e plotando os número de casos em cada retangulo e preenchendo a cor de acordo com o número de casos.

```{r}
h + geom_bin2d(binwidth = c(0.25, 500))

```

#### geom_density_2d

Use para gerar um gráfico de contorno. É um gráfico de densidade (ver [geom_density]) só que para duas variáveis.

```{r}
h + geom_density_2d()
```

#### geom_hex

Use para gerar um mapa de calor hexagonal. O gráfico é formado dividindo o plano em hexagonos e plotando os número de casos em cada retangulo e preenchendo a cor de acordo com o número de casos.

```{r}
h + geom_hex(bins = 40)

```

### Duas Variáveis Discretas

Quando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**g**" e "**e**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg e diamonds**. Utilizaremos as variáveis de mpg consumo na cidade (cty) e consumo na estrada (hwy) e de diamonds (cut e color).

```{r}
g <- ggplot(diamonds, aes(cut, color))
e <- ggplot(mpg, aes(cty, hwy))
```

#### geom_count

Esta geometria é uma variante da geom_point que conta o número de observações para cada localização do gráfico e então mapeia o número da contagem com cada ponto.

```{r}
g + geom_count()
```

#### geom_jitter

Use para criar um gráfico de pontos com o uma dispersão aleatória em cada ponto sobreescrito. É similar a escrever geom_point(position = "jitter").

```{r}
e + geom_jitter(height = 1, width = 1)
```

Para entender como esta dispersão aleatória funciona, compare uma geometria de pontos onde temos vaŕios pontos no mesmo local (sem a dispersão em vermelho) e com a dispersão (jitter).

```{r}
e +
  geom_jitter(alpha = 0.4, height = 1, width = 1) +
  geom_point(color = "red")
  
```

### Mapas

O ggplot2 também pode gerar gráficos de mapas.

Para isso iremos criar um conjunto de dados à partir da base "**USArrests**", contendo onúmero de assassinatos por estado americano. Depois iremos usar usar a função **map_data**() para criar um data frame com as iformações para o mapa (latitude e longitude). Depois usaremos este data frame para a geometria de mapas (geom_map).

::: panel-tabset
## mapa

```{r}
data <- data.frame(murder = USArrests$Murder,
state = tolower(rownames(USArrests)))

map <- map_data("state")
k <- ggplot(data, aes(fill = murder))

k + geom_map(aes(map_id = state), map = map) +
    expand_limits(x = map$long, y = map$lat)

```

## data frame

```{r}
data
```

## data frame de mapa

```{r}
map
```
:::

### Visualizando Erros

Quando precisamos analisar intervalos verticais, com linhas, barras e barras de erros, podemos usar as seguintes geometrias abaix. Porém, como nas demais seções, iremos preparar nosso objeto básico para evitar repetição de código.

Agora teremos um objeto "**j**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base "**df**" que criaremos a seguir.

```{r}
df <- data.frame(grp = c("A", "B"), fit = 4:5, se = 1:2)
j <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))
```

Vamos entender como é a base de dados "df" criada.

```{r}
df
```

::: callout-note
A coluna "SE", significa "standard error" ou erro padrão.
:::

Já o objeto ggplot base que criamos tem a variável grp no eixo x, fit no eixo y. Também definimos o y-min como fit - se (erro padrão) e o ymax como fit + se.

```{r}
#| eval: false
j <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))
```

#### geom_crossbar

Use para criar uma barra no intervalo vertical. Esta função criará duas barras com um ponto central baseado em ymin, x e ymax. o argumento fatten = , é um fator multiplicador para o separador do meio.

```{r}
j + geom_crossbar(fatten = 5)
```

Veja que a distância do ponto central de A até seu limite de baixo é definido por fit + se em nossa tabela de dados e nosso objeto "j". O mesmo ocorre para o limite inferior.

#### geom_errorbar

Use para traçar barras de erro. Similar ao geom_crossbar, mas não mostra o ponto central ou as linhas laterais.

```{r}
j + geom_errorbar()
```

#### geom_linerange

Similar a geom_errorbar, mas sem as linha superior ou inferior.

```{r}
j + geom_linerange()
```

#### geom_pointrange

Similar à geom_linerange, porém monstrando o ponto central.

```{r}
j + geom_pointrange()
```

### Três Variáveis

O ggplot não consegue criar gráficos 3D verdadeiros, porém permite visualizar superfícies 3D em 2 duas dimensões. Quando precisamos criar tais gráficos, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto "**l**" ao qual iremos adicionar novas camadas. Isto é similar ao que fizemos anteriormente, só que agora usando a base de dados **seals**. Faremos um ajuste, criando uma coluna "z", que será a raiz quadrada das somas dos quadrados de delta_long e delta_lat. Mapearemos nosso objeto ggplot base com x = long e y = lat:

```{r}
seals$z <- with(seals, sqrt(delta_long^2 + delta_lat^2))
l <- ggplot(seals, aes(long, lat))
```

#### geom_contour

```{r}
l + geom_contour(aes(z = z))
```

#### geom_contour_filled

```{r}
l + geom_contour_filled(aes(z = z, color = z))
```

#### geom_raster

```{r}
l + geom_raster(aes(fill = z), hjust = 0.5,
vjust = 0.5, interpolate = FALSE)
```

#### geom_tile

```{r}
l + geom_tile(aes(fill = z))
```

## Estatísticas (stats) {#estatísticas-stats}

Podemos dizer que as estatísticas, ou mais precisamente, uma transformação estatística, é uma maneira diferente de construirmos uma camada.

Assim como cada camada de geometria possui uma transformação estatística padrão, cada estatística possui uma geometria padrão.

A transformação estatística cria novas variáveis que não estavam presentes em nossos dados originais (ex: count, pop)

![](images/ggplot-03.jpg){width="412"}

Podemos visualizar uma transofrmação estatística mudando a estatística padrão de uma geometria (ex: **geom_bar(stat="count")** ou usando uma função stat() (ex: **stat_count(geom="bar")** que chama uma geometria padrão para criar uma camada.

::: callout-note
Podemos usar a sintaxe **..nome..** para mapear uma estatística em uma estética (aes()).
:::

Para ficar mais claro, vejamos o seguinte caso:

```{r}
#| eval: false
i + stat_density_2d(aes(fill = ..level..),
geom = "polygon")
```

Explicando com mais detalhes o exemplo acima, vemos que estamos uma adicionando uma camada no gráfico representado pela letra "i".

Depois estamos criando uma nova camada através da estatística "stat_density_2d". Esta função cria diversas variáveis calculadas automaticamente que podem ser acessadas por ..level.., e neste caso estamos atribuindo uma variável calculada ao mapeamento de preenchimento fill =.

Ao final, estamos forçando uma geometria "polygon" ou invés da geometria padrão desta função que seria "density_2d".

Veja o exemplo abaixo:

```{r}
#| layout-ncol: 2
mpg |> ggplot(aes(x = class, fill = class))+
  stat_count()

mpg |> ggplot(aes(x = class, color = class))+
  stat_count( geom = "point")
```

Neste caso, estamos criando no gráfico da esquerda, uma camada usando a função stat_count (que tem com padrão a geom="bar") e no gráfico da direita, estamos forçando uma geometria de pontos.

O mesmo poderia ser feito, utilizando a geometria e alterando a estatística padrão. Veja como seria:

```{r}
#| layout-ncol: 2
mpg |> ggplot(aes(x = class, fill = class))+
  geom_bar()

mpg |> ggplot(aes(x = class, color = class))+
  geom_point(stat = "count")
```

Veja que tivemos que alterar a estatística padrão apenas da geom_point. Isto porque a geom_bar, já possui a estatística "count" como padrão, já a geom_point, possui a estatística "identity" como padrão.

::: callout-important
A transformação estatística "**identity**", significa nenhuma transformação, ou seja, utiliza os dados que estão em nossa tabela original. É muito utilizada quando não queremos que alguma geometria faça o cálculo da transformação estatística para nós, mas sim, quando quisermos utilizar os dados já calculados em alguma coluna da tabela.
:::

A seguir teremos uma sequência, demonstrando a criação de diversas camadas utilizando as transformações estatísticas e suas respectiva geometrias padrão.

::: callout-tip
Para maiores detalhes dos argumentos, variáveis computadas e geometrias padrão, digite ?\<nome_função_estatística\> (ex: ?stat_count)
:::

```{r}
#| layout-ncol: 3
c + stat_bin(binwidth = 1, boundary = 10)
c + stat_count(width = 1)
c + stat_density(adjust = 1, kernel = "gaussian")
```

```{r}
#| layout-ncol: 2
#| layout-nrow: 2
e + stat_bin_2d(bins = 30, drop = T)
e + stat_bin_hex(bins = 30)
e + stat_density_2d(contour = TRUE, n = 100)
e + stat_ellipse(level = 0.95, segments = 51, type = "t")
```

```{r}
#| layout-ncol: 3
#| layout-nrow: 2

l + stat_contour(aes(z = z))
l + stat_summary_hex(aes(z = z), bins = 30, fun = max)
l + stat_summary_2d(aes(z = z), bins = 30, fun = mean)
f + stat_boxplot(coef = 1.5)
f + stat_ydensity(kernel = "gaussian", scale = "area")
```

```{r}
#| layout-ncol: 3

e + stat_ecdf(n = 40)

e + stat_quantile(quantiles = c(0.1, 0.9),
formula = y ~ log(x), method = "rq")

e + stat_smooth(method = "lm", formula = y ~ x, se = T,
level = 0.95)

```

```{r}
#| layout-ncol: 3
#| layout-nrow: 3
ggplot() + xlim(-5, 5) + 
  stat_function(fun = dnorm, n = 20, geom = "point")

ggplot() + stat_qq(aes(sample = 1:100))

e + stat_sum()

e + stat_summary(fun.data = "mean_cl_boot")

h + stat_summary_bin(fun = "mean", geom = "bar")

e + stat_identity()

e + stat_unique()

```

## Escalas (scales)


### Escalas de Propósito Geral

### Escalas de Localização X & Y

### Escalas de Cor e Preenchimento

### Variáveis Discretas

### Variáveis Contínuas

### Escalas de Forma e Tamanho

## Sistema de Coordenadas

## Ajuste de Posição

## Temas

## Facetas

## Texto e Legendas

## Zoom
