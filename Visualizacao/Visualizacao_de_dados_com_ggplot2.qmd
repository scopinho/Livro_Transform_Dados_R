# Visualização de Dados com GGPLOT2

## Introdução

A seguir temos vários exemplos de visualização de dados utilizando o pacote GGPLOT2 do R.

::: callout-note
Apesar de visualização de dados não ser especificamente parte das etapas de transformação e manipulação de dados, acreditamos ser importante um conhecimento básico sobre o tema, pois muitas vezes, para explicarmos aquilo que estamos transformando ou manipulando, o fazemos de forma gráfica para melhor compreensão.

O objetivo não é explicar a aplicabilidade e/ou o a função de cada gráfico, mas sim, como ele pode ser construído.
:::

Para saber mais sobre este pacote, acesse:

[https://cran.r-project.org/package=ggplot2](https://cran.r-project.org/package=stringr){.uri}.

::: callout-warning
Para melhor utilizar este material, é importante que você tenha uma introdução à linguagem R e saiba carregar pacotes (packages) no R. Para mais informações acesse:

<https://education.rstudio.com/learn/beginner/>.
:::

Para os exemplos, iremos carregar os seguintes pacotes:

-   **tidyverse**

-   **gt**

```{r}
#| echo: true
library (tidyverse)
library (gt)
```

### Exemplos da Folha de Referência

A maioria dos exemplos, visam ajudar na interpretação dos exemplos e funções encontradas na [**Folha de Referência**](https://github.com/scopinho/R-cheatsheets/blob/main/translations/portuguese/data-visualization_pt_br.pdf) do stringr disponível no site do [RStudio](rstudio.com).

------------------------------------------------------------------------

## Tipos de Variáveis

Não é intuito deste tópico aprofundar neste tema, porém como a natureza de cada gráfico pode estar relacionada ao tipo de variável que ele irá representar, vamos rever de forma resumida os tipos de variáveis no contexto de análise de dados.

Este conhecimento é importante, pois iremos nos referir a eles, principalmente quando tratarmos das funções de [Geometrias (geoms)](#geometrias-geoms).

Podemos categorizar as variáveis em Qualitativas ou Quantitativas. [@favero]

#### **Qualitativas**

Representam as características de um indivíduo, objeto ou elemento que não podem ser medidas ou quantificadas.

As variáveis **qualitativas**, também poder ser classificadas em função do número de categorias em:

-   **Dicotômica** ou Binária: Apenas duas categorias.

-   **Policotômica**: Mais que duas categorias.

Ou em função da escala de mensuração em:

-   **Nominal**: As unidades são classificadas em categorias em relação à características representadas. Sem ordem ou relação entre si. (ex: sexo)

-   **Ordinal**: As unidades são classificadas em categorias em relação à características representadas. Há uma ordem ou relação entre si. (ex: grau de escolaridade)

::: callout-note
Tipicamente, um dado qualitativo em natureza representa valores discretos que pertencem a um conjunto finito de classes. Estes valores discretos podem ser representados através de um número ou textos.

Em geral, variáveis qualitativas são representadas no R com o tipo fatores "factors".
:::

#### **Quantitativas**

Representam as características de um indivíduo, objeto ou elemento resultantes de uma contagem ou mensuração.

As variáveis **quantitativas**, também podem ser classificadas em função da escala de precisão.

-   **Discreta**: Assumem conjunto finito de valores, frequentemente de uma contagem (ex: número de filhos, quantidade de carros, etc)

-   **Contínua**: Assumem conjunto infinito de valores, frequentemente com resultado de uma mensuração (ex: peso, altura, salário, etc)

Ou em função da escala de mensuração em:

-   **Intervalar**: As unidades são ordenadas em relação à características mensurada e possui um unidade de constante. A origem, ou ponto zero, não expressa ausência de quantidade. (ex: temperatura)

-   **Razão**: As unidades são ordenadas em relação à características mensurada e possui um unidade de constante. A origem, ou ponto zero, é única e expressa ausência de quantidade.(ex: temperatura)

::: callout-caution
Vale lembrar que nem sempre uma variável representada por um número é quantitativa. O número da carteira de identidade é um exemplo disso. Apesar dos números ela é uma variável qualitativa.
:::

::: callout-note
O ggplot2, em geral irá tratar as variáveis **caractere** (char) e **fatores** (factors) em escalas **discretas**. Já as variáveis **numéricas** com escalas **contínuas**. A separação nas seções adiante, seguem estas definições para segregar os tipos de gráficos e escalas. Quando tivermos variáveis que não seguem este padrão, devemos "transformá-las, usando funções como as_factor(), as.integer(), as.double, etc.
:::

## Gramática dos Gráficos

O pacote ggplot2 é uma implementação do livro "***Grammar of Graphics***", que apresenta um conceito de quais seriam os elementos de um gráfico e suas interconexões. O modelo teórico proposto no livro é que através de camadas definidas qualquer gráfico pode ser construído. Abaixo o modelo, que deve ser interpretado de baixo para cima.

![](images/grammar-01.jpg){width="354"}

De uma forma bem resumida, a idéia é que você possa construir qualquer gráfico com base nestes mesmos elementos: um **conjunto de dados**, um **sistema de coordenadas** e **geoms**, que seriam marcas visuais que representas os pontos dos dados.

![](images/ggplot-01.jpg){width="475"}

No caso do ggplot2, para mostrar valores no gráfico, as varíaveis do conjunto de dados são **mapeadas** em propriedadas visuais da geometria (geom).

Este mapeamento de estética (aesthetic) é feito através da função aes() e podemos fazer mapeamentos estéticos como cor ou tamanho.

![](images/ggplot-02.jpg){width="475"}

## Modelo para Construção de um Gráfico

No caso do ggplot2, podemos definir uma espécie de modelo (template) para a sintaxe de construção de gráficos:

![](images/ggplot_template-01.jpg){width="556"}

------------------------------------------------------------------------

#### ggplot

A função ggplot() inicia um gráfico que será completado com as camadas adicionadas na sequência. Adicione uma geometria (geom) para cada camada.

Usando o modelo anterior e o que vimos até aqui, vamos gerar nosso primeiro gráfico. Como base de dados usaremos a tabela **mtcars**. Para maiores informação sobre as colunas e dados do mtcars, digite ?mtcars.

```{r}

mtcars
```

```{r}
ggplot(data = mtcars) +
  geom_point (mapping = aes(x = hp, y = mpg ))
```

::: callout-note
Observe que mesmo sem definirmos escalas, temas, estatísticas ou outras camadas, o gráfico ainda assim foi gerado. Isto é porque o ggplot tem valores padrões dinâmicos que tentam prover o melhor resultado possível com o mínimo de esforço.
:::

::: callout-tip
A definição da estética com seu mapeamento, feito neste exemplo na função de geometria (geom_point) poderá ser feito também na função ggplot().
:::

Apesar do gráfico final ser similar, a estética mapeamento poderá ser utilizada pelas funções geom\_\*() nas camadas seguintes, sem a necessidade de repetí-la, caso contrário, ela será restrito apenas àquela geom() na qual foi declarada. Veja:

```{r}
ggplot(data = mtcars, mapping = aes(x = hp, y = mpg))+
  geom_point()
```

Por ser comum o uso do argumento data = e mapping =, podemos excluídas do código, deixando-o mais enxuto, porém mais difícil para quem não tem tanta familiaridade, veja:

```{r}
ggplot(mtcars,aes(x = hp, y = mpg)) +
  geom_point()
```

#### last_plot

Use para retornar o último gráfico gerado.

```{r}
last_plot()
```

#### ggsave

Use para salvar o gráfico em uma imagem. O tipo de imagem é selecionado pela extensão do arquivo de saída.

Por exemplo, para salvar o diretório atual um arquivo com o gráfico chamado "plot-01.png" com o formato de imagem ".PNG" de tamanho 5x5 centímetros, fazemos:

```{r}
ggsave("plot-01.png", width = 5, height = 5, units = "cm")
```

## Estética (aes)

Cada estética possui valores padrões que serão usados por determinada função de geometria ou de estatística. Mas existem valores que são comuns a quase todas as geom/stat(), a seguir veremos alguns deles:

#### color e fill

Use para definir a cor (color) ou preenchimento (fill) para a estética.

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg, color = "red"))
```

Na string de color =, podemos usar valores de cores em inglês, como "red" ou "blue", ou também códigos RGB, como ""#00ABFF" ou "FF00AA".

::: callout-important
Observe que o valor definido da cor, dentro fora dos parênteses da função aes(), ou seja, ela está fazendo o mapeamento da cor com os dados. Se utilizarmos o argumento color = da função geom_point(),estaremos definindo um valor fora do mapeamento.
:::

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg) , color = "red")
```

Apesar do resultado ser similar, observe que no exemplo anterior tivemos color como um mapeamento da estética, como definimos o valor fixo com a cor "red", seria como tivessemos em nossos dados uma coluna onde todas as linhas tivessem o valor "red". Já no exemplo acima, estamos simplemente dizendo à função da geometria que queremos a cor vermelha para ela.

Vejamos um outro exemplo para que fique claro este ponto. Vamos gerar o mesmo gráfico onde colocamos "red" como parte da estética, porém agora, iremos mapeá-la com a coluna "qsec" de nossos dados mtcars:

```{r}
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg, color = qsec))
```

#### linetype

Use para definir a linha utilizada no gráfico. Podemos utilizar um número de 0 a 6 ou um nome:

*(0 = "blank", 1 = "solid", 2 = "dashed", 3 = "dotted", 4 = "dotdash", 5 = "longdash",6 = "twodash")*

Por exemplo, ao invés de utilizarmos a geometria de pontos (geom_point), vamos utilzar a geometria de linha (geom_line):

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg) , linetype = "dotted")
```

#### size

Use para definir o tamanho, no caso de uma linha em "mm".

Como dito anteriormente, estes valores são comuns para vários geometrias. Por exemplo, podemos utilizar o argumento size também na geometria de pontos (geom_point):

```{r}
#| layout-ncol: 2

ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), size = 5)

ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), size = 5)
```

#### lineend

Use para definir o terminador da linha. Os valores podem ser: *round*, *butt* e *square*.

::: panel-tabset
## squared

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "square", size = 4)
```

## butt

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "butt", size = 4)
```

## round

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), lineend = "round", size = 4)
```
:::

#### linejoin

Use para definir a junção da linha. Os valores podem ser: *round*, *mitre* e *bevel*.

::: panel-tabset
## round

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "round", size = 4)
```

## mitre

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "mitre", size = 4)
```

## bevel

```{r}
ggplot(mtcars)+
  geom_line(aes(x = hp, y = mpg), linejoin = "bevel", size = 4)
```
:::

#### shape

Use para definir a forma. Podemos passar um número ou um nome em inglês da forma conforme abaixo:

![](images/aes_shape-01.jpg)

```{r}
#| layout-ncol: 2 

ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), shape = "square cross",  size = 3)
ggplot(mtcars)+
  geom_point(aes(x = hp, y = mpg), shape = 5, size = 3)
```

## Geometrias (geoms) {#geometrias-geoms}

Use as funções de geometria para representar os pontos de dados. Use as estéticas das geometrias para representar as variáveis.

::: callout-warning
Lembre-se que cada função retornará uma camada, portanto, a ordem de criação das camadas afeta o resultado do gráfico, pois uma será criada sobre a anterior.
:::

### Gráficos Primitivos

Para os exemplos a seguir, utilizaremos duas bases de dados, uma chamada **economics** e outra **chamada** seals.

::: panel-tabset
## Economics

```{r}
economics
```

## Seals

```{r}
seals
```
:::

Para simplificar o código dos próximos exemplos, iremos criar dois objetos gráfico do ggplot:

O primeiro chamado "**a**", irá conter um objeto ggplot com os dados de **economics**, mapeando a estética de x para a variável "date" e y para a variável "unemployed".

O segundo chamado "**b**", irá conter um objeto ggplot com os dados de **seals**, mapeando a estética de x para a variável "long" e y para a variável "lat".

Desta forma trabalharemos com os mesmos objetos base e adicionaremos apenas novas camadas afim de identificar os detalhes das diversas funções de geometria.

```{r}
a <- ggplot(economics, aes(date, unemploy))
b <- ggplot(seals, aes(x = long, y = lat))
```

::: callout-note
Para simplificar o código, em algum momentos podemos omitir o argumento, como data=, mapping = , x = , y = . Isto porque já estamos os valores na ordem da função.
:::

Agora com os objetos inicialmente criados, iremos adicionar novas camadas afim de obtermos os gráficos e entendermos algumas das funções de geometria para gráficos primitivos.

#### geom_blank

Use para garantir limites para todos os gráficos de acordo com os dados.

```{r}
a + geom_blank()
```

::: callout-tip
Use a função **expand_limits**() para expandir os limites do gráfico usando dados. Ver ?expand_limits para mais detalhes.
:::

#### geom_curve

Use para criar curvas.

```{r}
b + geom_curve(aes(yend = lat + 1, xend = long + 1), curvature = 1)
```

#### geom_path

Use para conectar observações.

```{r}
a + geom_path(lineend = "butt", linejoin = "round", linemitre = 1)
```

#### geom_polygon

Use para criar poligonos. É similar a geom_path(), porém a parte interna é preenchida com argumento fill =.

```{r}
a + geom_polygon(aes(alpha = 50))
```

::: callout-note
O argumento alpha = , é muito comum na definição de cores. De maneira simplificada, ele indica o nível de transparência de uma cor, sendo 0, nenhuma transparência e 1 transparência total.
:::

#### geom_rect

Use para criar retângulos.

```{r}
b + geom_rect(aes(xmin = long, ymin = lat,
xmax = long + 1, ymax = lat + 1))
```

::: callout-note
A função **geom_title()** fazem a mesma coisa, porém são parametrizadas de forma diferente. A geom_rect usa a localização dos 4 cantos do quadrado, enquanto a geom_tile usa o centro e seu tamanho (largura e altura) para dimensionar.
:::

#### geom_ribbon

Use para criar uma "fita". Para cada valor de x, ela mostra um intervalo y, definido por ymin e ymax. Veja que geom_area() é um caso especial do geom_ribbon(), onde o ymin é fixo em 0 e y é usado no lugar de ymax.

```{r}
a + geom_ribbon (aes(ymin = unemploy - 900,
ymax = unemploy + 900))
```

### Segmentos de Linhas

Estas funções de geometrias, permitem criar diversos tipo de segmentos de linha e são úteis quando precisamos "marcar" ou definir algo no gráfico, com linhas verticais ou horizontais por exemplo.

#### geom_abline

Use para criar uma linha de um ponto "a" até um ponto "b", passando o intercepto e a inclinação da reta.

```{r}
b +  geom_abline(aes(intercept = 0, slope = 1))
```

#### geom_hline

Use para criar uma ou mais linhas horizontais.

```{r}
b + geom_hline(aes(yintercept = lat))
```

Veja que no exemplo anterior, fizemos o mapeamento do argumento yintercept como parte da estética (aes), mapeando este argumento com a variável "lat" de nossos dados.

Se quisermos simplesmente traçar uma linha com o intercepto do eixo y, correspondendo ao valor 40 (por exemplo, se fosse um tipo de meta), podemos definir este valor fora do mapeamento:

```{r}
b + geom_hline(yintercept = 40)
```

#### geom_vline

Use para criar uma ou mais linhas horizontais.

```{r}
b + geom_vline(aes(xintercept = long))
```

#### geom_segment

É similar ao geom_curve, porém ao invés de criar uma curva, criar um segmento de reta.

```{r}
b + geom_segment(aes(yend = lat + 1, xend = long + 1))
```

#### geom_spoke

Use para criar um segmento, parametrizado pela localização, direção e distância.

```{r}
b + geom_spoke(aes(angle = 1:1155, radius = 1))
```

### Uma Variável Contínua

Quando precisamos analisar um varíavel contínua, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nossos objetos básicos para evitar repetição de código. Agora teremos um objeto "**c**" e outro "**c2**", aos quais iremos adicionar novas camadas. Similar ao que fizemos anteriormente, porém agora utilizaremos a base de dados "**mpg**".

```{r}
mpg
```

Criando os objetos ggplot:

```{r}
c <- ggplot(mpg, aes(hwy))
c2 <- ggplot(mpg)
```

::: callout-important
Observe que o objeto "**c**", usa a base "mpg" **já atribuindo a variável "hwy" para x= da estética**. Esta configuração será aplicada para qualquer funções geom\_\*() a não ser que explicitamente tenhamos uma estética redefinindo isso dentro de outra camanda de geometria.

Já para o objeto "**c2**", **não temos a estética** de x definida, portanto, teremos que definí-la em nas próximas camadas com a funções de geometria (geom\_\*()).
:::

#### geom_histogram

Use para criar histogramas, ou seja, uma forma de visualizar uma variável contínua dividindo no eixo x em classes e contando o número de observações de cada classe no eixo y.

O argumento binwidth = define o tamanho das classes.

No exemplo a seguir, dividimos a variável contínua de consumo por rodagem (hwy) em classes com 2 observações cada.

```{r}
c + geom_histogram(binwidth = 2) 
```

Se desejar definir o número de classes ao invés de quantas observações terão cada classe, utilize o argumento bins =.

```{r}
c + geom_histogram(bins = 16) 
```

#### geom_freqpoly

Use para gerar um gráfico de polígonos de frequência. Enquanto o histograma gera um gráfico de barras, esta geometria gera uma linha.

```{r}
c + geom_freqpoly(bins = 30)
```

#### geom_area

Use para criar um gráfico de área, onde para cada valor no eixo x, há um valor y máximo e o valor de y mínimo é sempre zero.

::: callout-note
Você verá um argument (stat = "bin") abaixo. Veremos as **estatísticas** na seção [ESTATÍSTICAS (STATS)](#estatísticas-stats). Por hora, pense apenas que é uma forma de definirmos os valores que iremos mostrar para o eixo y. Por padrão o número de agrupamento (bin) é 30.
:::

```{r}
c + geom_area(stat = "bin", bins = 32)
```

#### geom_density

Use para fazer um gráfico de **densidade**. Usando funções de estimativa de densidade de kernel, seria uma versão mais "arredondada" do histogram, mostrando a função densidade de **probabilidade** da variável.

Há a possibilidade de configurar vários kernels das funções de densidade, como "gaussian", "rectangular", "triangular", "epanechnikov", "biweight", "cosine" ou "optcosine".

```{r}
c + geom_density(kernel = "gaussian")
```

::: callout-tip
Veja que podemos criar duas geometrias, uma com o histograma e outra de densidade sobrepostas. Para isto temos que sobreescrever a estética definida previamente para o eixo y (antes era count) usando ..density..
:::

```{r}
c + geom_histogram(aes(y = ..density..)) +
  geom_density()
```

#### geom_dotplot

Use para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.

```{r}
c + geom_dotplot() 
```

#### geom_qq

Use para criar um gráfico de quantil-quantil. Em geral utilizado para confirmar se uma variável tem uma distribuição gaussiana.

```{r}
c2 + geom_qq(aes(sample = hwy))
```

### Uma Variável Discreta

Quando precisamos analisar um varíavel discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**d**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente usando a base de dados **mpg**. Utilizaremos a variável combustível (fl).

```{r}
d <- ggplot(mpg, aes(fl))
```

#### geom_bar

Use para criar um gráfico de barras.

```{r}
d + geom_bar()
```

Veja outro exemplo: Como aconteceu com o combustível (fl), podemos pegar a variável tipo da classe do veículo (class) e gerar um gráfico de barras também.

```{r}
d + geom_bar(aes(x = class))
```

Usando o argumento da estética para cor do preenchimento (fill), podemos mapear uma variável igual ou diferente. Com isto, o ggplot automaticamente criará uma legenda para os diferentes valores da varíavel. Veja o que acontece quando temos x=fl e fill = class:

```{r}
d + geom_bar(aes(fill =class))
```

Note que como a estética herdada do objeto ggplot base (d) tinha o mapeamento de x para a variável combustível (fl), ela ainda permanece no eixo x.

Se sobrescrevermos este mapeamento para a estética do geom_bar com a mesma variável para x e fill, teremos:

```{r}
d + geom_bar (aes(x = class, fill = class)) 
```

Note que o resultado automático do gráfico foi um pouco diferente. Quando tivemos x = fl e fill = class as barras foram **empilhadas** (stack) e quando tivemos x = class e fill = class, as barras foram lado colocadas **lado a lado** (dogde).

Por padrão, o ggplot, quando múltiplas barras ocupam o mesmo ponto, elas são empilhadas. Este comportamento pode ser definido através do argumento **position =** .

Veja as diferentes opções:

::: panel-tabset
## dodge

```{r}
d + geom_bar(aes(fill =class), position = "dodge")
```

## dodge2

```{r}
d + geom_bar(aes(fill =class), position = "dodge2")
```

## stack

```{r}
d + geom_bar(aes(fill = class) , position = "stack")
```

## fill

```{r}

d + geom_bar(aes(fill =class), position = "fill")
```
:::

::: callout-tip
As geometrias podem ter valores calculados autometicamente "computed variables". Isto é para faciliar a geração dos gráficos com valores padrões. No caso da geom_bar, não precisamos passar que no eixo y gostaríamos de ter a contagem da variável que está no eixo x. Veja que então, a variável y não ficou sem um valor, ele apenas foi substituído pela contagem (count) automaticamente. A geom_bar tem "count" e "prop" como varíveis computadas.

Para saber quais varíaveis são computadas automaticamente para cada geometria, veja a ajuda com ?geom_bar.
:::

### Duas Variáveis Discretas

Quando precisamos analisar um duas varáveis discretas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**g**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **diamonds**. Utilizaremos as variáveis corte (cut) e cor (color).

```{r}
g <- ggplot(diamonds, aes(cut, color))
```

#### geom_count

Esta é uma variante do geom_point() que conta o número de observação em cada localização e então mapeia a contagem na área do ponto.

```{r}
g + geom_count()

```

#### geom_jitter

É similar ao geom_point, porém adiciona uma variação aleatória em cada ponto.

```{r}
g + geom_jitter(height = 2, width = 2)
```

Como várias outras geometrias, podemos adicionar uma cor na estética do geom_jitter, mapeando outra váriável, como por exemplo o corte (cut) para facilitar a visualização:

```{r}
g + geom_jitter(aes(color = cut), height = 2, width = 2)
```

### Uma Variável Contínua e Outra Discreta

Quando precisamos analisar uma varável contínua e outra discreta, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**f**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg**. Utilizaremos as variáveis classe (class) e consumo na estrada (hwy).

```{r}
f <- ggplot(mpg, aes(class, hwy))
```

#### geom_col

Use para criar um gráfico de colunas. Ele é similar ao gráfico de barras, porém agora, no eixo y, teremos uma variável contínua. Observe que enquanto no geom_bar, o eixo y é calculado automaticamente, aqui na geom_col, você precisa ter a variável já nos seus dados.

```{r}
f + geom_col()
```

Assim, como no geom_bar, podemos definir a cor de preenchimento da estética para geom_col, usando fill =.

Vamos usar a variável de número de cilindros (cyl) como exemplo.

```{r}
f + geom_col(aes(fill = cyl))
```

::: callout-warning
Veja que no caso acima, o ggplot tentou automaticamente ajustar a escala de cores para uma escala contínua. Dá a impressão que temos veículos com 7 cilindros inclusive.
:::

Isto é porque em nossos dados, a variável "cyl" é do tipo inteiro (integer) e com isto, o ggplot2 entende como um variável contínua.

Para obter o efeito pretendido, temos algumas opções. Uma seria mudar a variável cyl para o tipo fator (factor) usando a função as_factor(). Veja:

```{r}
f + geom_col(aes(fill = as_factor(cyl)))
```

Por padrão, as classes são colocadas de forma empilhada, similar ao que vimos na [geom_bar]. Se quisermos colocadas lado a lado, devemos fazer:

```{r}
f + geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = "dodge")
```

::: callout-tip
A largura das colunas é expandida automaticamente, pois não temos valores para todas as combinações. Por exemplo, não temos 8 cilindros em carros compatos. Há formas difrentes de ajutar isso, uma delas é ajustar a base de dados, criando as combinações possíveis utilização a função tidyr::**complete**()
:::

```{r}
complete(mpg, class, cyl) |> ggplot () +
  geom_col(aes(y= hwy, x=class, fill = factor(cyl)), position = "dodge")
```

#### geom_boxplot

Use para criar um gráfico boxplot (box e whiskers). Este gráfico é bastante interessante, pois mostra cinco estatísticas automaticamente (a mediana, primeiro e terceiro quartis e os limites max e min) e os pontos fora da curva individualmente (outlyers).

Para este exemplo, iremos além de definir uma cor de preenchimento através do argumento fill = , iremos remover a legenda desta camada usando show.legend = FALSE. \

```{r}
f + geom_boxplot(aes(fill = factor(class)), show.legend = FALSE)
```

Para mostrar a média ao invés da media, podemos fazer:

```{r}
#| eval: false
f + geom_boxplot(aes(middle = mean(hwy)))
```

#### geom_dotplot

Use para criar um gráfico de pontos, com a largura dos pontos correspondem à largura do agrupamento e os pontos são empilhados. Cada ponto corresponde à uma observação dos dados, portanto em geral é utilizado quando temos poucas observações.

```{r}
f + geom_dotplot(aes(color = class),binaxis = "y", stackdir = "center")
```

#### geom_violin

Use para criar um gráfico de violino. Ele mostra de forma compacta a distribuição de uma variável contínua.

```{r}
f + geom_violin(aes(fill = class), scale = "area")
```

### Duas Variáveis Contínuas

Quando precisamos analisar duas variáveis contínuas, as geometrias a seguir ajudam a fornecer um gráfico apropriado.

Novamente, iremos preparar nosso objeto básico para evitar repetição de código. Agora teremos um objeto "**e**" ao qual iremos adicionar novas camadas. Similar ao que fizemos anteriormente, só que agora usando a base de dados **mpg**. Utilizaremos as variáveis consumo na cidade (cty) e consumo na estrada (hwy).

```{r}
e <- ggplot(mpg, aes(cty, hwy))
```

#### geom_label

#### geom_point

#### geom_quantile

#### geom_rug

#### geom_smooth

#### geom_text

#### 

### Duas Variáveis Distribuição Bivariada Contínua

### Duas Variáveis Discretas

### Mapas

### Visualizando Erros

### Três Variáveis

## Estatísticas (stats) {#estatísticas-stats}

## Escalas (scales)

### Escalas de Propósito Geral

### Escalas de Localização X & Y

### Escalas de Cor e Preenchimento

### Variáveis Discretas

### Variáveis Contínuas

### Escalas de Forma e Tamanho

## Sistema de Coordenadas

## Ajuste de Posição

## Temas

## Facetas

## Texto e Legendas

## Zoom
